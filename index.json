[{"categories":["개발","라즈베리파이"],"content":"라즈베리파이 OS를 설치한 microSD카드를 꽂고 전원을 연결하면 바로 라즈베리파이 OS가 부팅된다. 하지만 해당 장치를 사용하려면 HDMI로 모니터에 연결하고 (혹은 DSI 커넥터에 디스플레이 모듈 연결) 키보드, 마우스를 연결해야 한다. Headless 방식은 위 장치들이 없이 네트워크 혹은 시리얼 케이블로 연결하는 환경을 말한다. (보통 위 3가지 장치를 묶어서 KVM 스위치 등으로 여러 컴퓨터를 동시 제어할 때 쓰기도 한다.) 본 문서에서는 라즈베리파이를 처음부터 Headless로 사용하기 위해 필요한 설정 방법을 설명할 것이다. 순서는 아래와 같다. 네트워크/시리얼 포트로 라즈베리파이와 연결 가능한 환경 확보 SSH 원격 접속을 설정하여 CLI로 접속 가능하게 하기 VNC 원격 접속을 설정하여 GUI로 접속 가능하게 하기 본 문서에서는 처음부터 headless로 사용하기 위해 라즈베리파이 OS가 설치된 microSD의 내용을 변경하는 방법을 설명한다. 라즈베리파이 OS가 설치된 microSD카드는 FAT32로 포맷된 boot 파티션과 ext4로 포멧된 rootfs 파티션이 있을 것이다. 본 문서에서는 boot파티션의 내용 수정을 주로 설명할 것이다. ","date":"2020-11-05","objectID":"/posts/rpi/headless-config-in-sd/:0:0","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"/posts/rpi/headless-config-in-sd/"},{"categories":["개발","라즈베리파이"],"content":"라즈베리파이와 연결 가능한 환경 확보하기 ","date":"2020-11-05","objectID":"/posts/rpi/headless-config-in-sd/:1:0","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"/posts/rpi/headless-config-in-sd/"},{"categories":["개발","라즈베리파이"],"content":"WiFi 자동 접속 설정하기 라즈베리파이를 유선랜으로 연결할 수 있다면 가장 좋겠지만, 불가능한 경우 WiFi에 자동 접속하도록 설정해주자. 라즈베리파이는 wpa_supplicant를 사용하므로 해당 설정 파일을 미리 작성해서 넣으면 된다. boot 파티션에 wpa_supplicant.conf 파일을 생성하고 WiFi 연결 정보를 작성한다. 아래는 WiFi AP 이름이 “testing”, 비밀번호가 “testingPassword\"일 때의 작성 예시다. ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=GB network={ ssid=\"testing\" psk=\"testingPassword\" } country= 부분에는 현재 WiFi의 국가를 설정하는 부분인데, 한국이라서 KR로 입력하면 WiFi 사용에 문제가 있는 경우가 있으므로, 일단은 GB 혹은 US로 설정해 주도록 하자. (링크를 보면 알겠지만, 한국에서 WiFi 사용을 위한 주파수 밴드가 대부분 비활성화 되어 있어 생기는 문제다.) 비밀번호 없는 WiFi 접속 설정 network={ } 안에 비밀번호 대신 key_mgmt=NONE를 입력하면 된다. 아래는 비밀번호 없는 WiFi AP 이름이 “testing\"일 때의 작성 예시다. network={ ssid=\"testing\" key_mgmt=NONE } 숨겨진 WiFi 접속 설정 network={ } 안에 scan_ssid=1을 추가하면 된다. 아래는 숨겨진 WiFi AP 이름이 “hiddenSSID”, 비밀번호가 “testingPassword\"일 때의 작성 예시다. network={ ssid=\"hiddenSSID\" scan_ssid=1 psk=\"testingPassword\" } 2개 이상의 WiFi 접속 설정 각 WiFi AP에 대한 **network={ }**를 여러 개 입력하면 된다. 각 WiFi AP간 우선순위는 **priority=**으로 표기한다. 아래는 WiFi AP 이름이 “firstSSID”, 비밀번호가 “firstPassword\"이고 다른 WiFi AP의 이름이 “secondSSID”, 비밀번호가 “secondPassword\"이며, “firstSSID\"를 우선적으로 접속하고 싶을 때의 작성 예시이다. network={ ssid=\"firstSSID\" psk=\"firstPassword\" priority=1 } network={ ssid=\"secondSSID\" psk=\"secondPassword\" priority=2 } WiFi 비밀번호 암호화하기 이전까지의 설정은 모두 비밀번호가 평문으로 저장된다는 문제점이 있다. 비밀번호를 노출하고 싶지 않다면, 미리 암호화된 비밀번호로 변환하여 저장하는 방법이 있다. (해당 방법은 wpa_supplicant를 직접 사용해야하며, 윈도우즈에서는 일반적으로 설치하기 힘든 것으로 보인다.) $ wpa_passphrase $SSID $PASSPHRASE wpa_supplicant를 설치하면 wpa_passphrase 명령어도 같이 설치되는데, 위와 같이 명령어의 인자로 WiFi AP의 이름과 비밀번호를 입력하면 사용해야 할 network={ } 내용을 생성해준다. 원문 비밀번호는 앞에 #으로 주석처리되어 있는데, 평문을 노출하지 않고 저장하는 것이 목적이므로 해당 줄만 삭제하면 된다. 아래는 WiFi AP 이름이 “testing”, 비밀번호가 “testingPassword\"일 때 평문을 감추는 예시다. $ wpa_passphrase testing testingPassword network={ ssid=\"testing\" #psk=\"testingPassword\" psk=131e1e221f6e06e3911a2d11ff2fac9182665c004de85300f9cac208a6a80531 } wpa_supplicant를 직접 사용할 수 없는 경우에는 Wireshark에서 제공하는 변환 페이지를 사용할 수도 있다. ","date":"2020-11-05","objectID":"/posts/rpi/headless-config-in-sd/:1:1","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"/posts/rpi/headless-config-in-sd/"},{"categories":["개발","라즈베리파이"],"content":"라즈베리파이 제로를 USB 이더넷 장치로 사용할 수 있게 설정하기 라즈베리파이 제로의 경우 WiFi가 지원되지 않는다. 하지만 해당 제품에서 USB 연결 설정을 변경하여 PC에서 USB 이더넷 장치로 인식하게 하는 방법이 있다. Addon board나 dongle expansion breakout module kit을 사용한다면 PC에서 라즈베리파이를 마치 이더넷 어댑터에 연결한 것 처럼 사용할 수 있다. 이 방법은 라즈베리파이 제로 W도 적용 가능하다. boot 파티션의 cmdline.txt 파일을 아래와 같이 수정한다. console=serial0,115200 console=tty1 root=PARTUUID=384c22b9-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait modules-load=dwc2,g_ether splash plymouth.ignore-serial-consoles 해당 파일은 1줄짜리로 되어있는데, 내용 중 rootwait 부분과 quit 사이에 modules_load=dwc2,g_ether를 추가해준다. 또한 config.txt 파일에 dtoverlay=dwc2를 추가한다. 50 51 52 53 54 55 56 57 58 # Uncomment this to enable infrared communication. #dtoverlay=gpio-ir,gpio_pin=17 #dtoverlay=gpio-ir-tx,gpio_pin=18 # Additional overlays and parameters are documented /boot/overlays/README dtoverlay=dwc2 # Enable audio (loads snd_bcm2835) dtparam=audio=on 라즈베리 파이 제로의 USB controller인 DesignWare Core2의 OTG 설정을 활성화해주고, USB OTG 모듈 중 g_ether 모듈을 사용하게 하는 것이다. 윈도우즈에서는 이렇게 설정한 라즈베리파이를 연결하면 RNDIS 장치로 인식하게 되는데, 해당 장치 연결 시 컴퓨터가 느려지는 문제가 있다. ","date":"2020-11-05","objectID":"/posts/rpi/headless-config-in-sd/:1:2","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"/posts/rpi/headless-config-in-sd/"},{"categories":["개발","라즈베리파이"],"content":"라즈베리파이에게 DHCP로 IP를 할당해 줄 수 없을 때 라즈베리파이 제로를 USB로 연결하거나, 공유기 등에서 DHCP 기능을 사용하지 않는 경우 라즈베리파이는 IP를 할당받지 못하게 된다. 고정IP 설정은 boot 파티션 수정으로 할 수 없기 때문에 rootfs 파티션 내부를 수정하거나, 링크 로컬 주소를 사용해야 한다. 위에서 말한대로 rootfs는 ext4로 포멧되어있으니 윈도우즈만 사용하는 경우에는 고정IP 설정은 바로 할 수 없다고 생각하면 된다. rootfs에서 고정 IP 설정하기 rootfs의 /etc/dhcpcd.conf 파일 끝에 아래와 같이 수정한다. interface $IF_NAME static ip_address=$DEV_IP_ADDR/$PREFIX_BITS static routers=$GATEWAY_IP_ADDR static domain_name_servers=$DNS_IP_ADDR $IF_NAME은 사용할 네트워크 장치의 이름을 입력한다. (유선랜: eth0, WiFi: wlan0) $DEV_IP_ADDR는 라즈베리파이가 사용할 주소를, $PREFIX_BITS는 서브넷 마스크의 비트 수를 입력하면 된다. $GATEWAY_IP_ADDR는 공유기의 주소를 입력한다. $DNS_IP_ADDR는 DNS의 주소를 입력한다. (대부분 공유기가 DNS요청을 대신 처리해주기 때문에 공유기의 주소를 입력해도 된다.) 유선랜과 WiFi의 설정을 같이 입력해도 된다. 아래는 유선랜이 172.16.1.101, WiFi가 172.16.2.101로 잡히도록 설정한 예시이다. (공유기는 172.16.0.1로 가정) interface eth0 static ip_address=172.16.1.101/16 static routers=172.16.0.1 static domain_name_servers=172.16.0.1 interface wlan0 static ip_address=172.16.2.101/16 static routers=172.16.0.1 static domain_name_servers=172.16.0.1 ","date":"2020-11-05","objectID":"/posts/rpi/headless-config-in-sd/:1:3","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"/posts/rpi/headless-config-in-sd/"},{"categories":["개발","라즈베리파이"],"content":"SSH 원격 접속 설정하기 boot 파티션 안에 ssh 혹은 ssh.txt 파일만 생성하면 된다. 해당 파일의 내용은 관계없다. (빈 파일도 상관없다.) 리눅스의 경우 touch 명령어를 사용하여 생성할 수 있다. # touch $RPI_BOOT/ssh ","date":"2020-11-05","objectID":"/posts/rpi/headless-config-in-sd/:2:0","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"/posts/rpi/headless-config-in-sd/"},{"categories":["개발","라즈베리파이"],"content":"VNC 원격 접속 설정하기 VNC 서버 설정은 boot 파티션 수정으로 할 수 없다. 원칙적으로 VNC 원격 접속 설정은 라즈베리파이를 부팅하고 나서, raspi-config를 사용하여 Interfacing option에서 VNC 서버 사용 여부를 수정해야한다. 하지만 해당 명령어의 코드를 보면 systemctl을 이용하여 VNC 서비스 데몬을 enable시키는 것을 확인할 수 있다. systemctl enable의 역할은 미리 작성된 서비스 데몬의 파일을 자동 실행되도록 심볼릭 링크를 달아주는 것이므로 rootfs에서 미리 수정할 수 있다. 위에서 말한대로 rootfs는 ext4로 포멧되어있으니 윈도우즈만 사용하는 경우에는 VNC 원격 접속 설정은 바로 할 수 없다고 생각하면 된다. # ln -s -f /usr/lib/systemd/system/vncserver-x11-serviced.service $RPI_ROOTFS/etc/systemd/system/multi-user.target.wants/vncserver-x11-serviced.service chroot를 통해 미리 라즈베리파이 OS의 rootfs 위에서 작업하거나, 혹은 mount된 경로를 고려하여 심볼릭 링크를 생성해주면 된다. 원본 VNC 서비스 데몬 스크립트 위치: /usr/lib/systemd/system/vncserver-x11-serviced.service 연결할 자동 실행 위치: /etc/systemd/system/multi-user.target.wants/ 원본 VNC 서비스 데몬 스크립트의 경로는 위에 설명한 경로로 고정되어야 한다. (라즈베리파이 안에서 해당 스크립트의 위치를 찾으면 되기 때문이다.) ","date":"2020-11-05","objectID":"/posts/rpi/headless-config-in-sd/:3:0","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"/posts/rpi/headless-config-in-sd/"},{"categories":["개발","라즈베리파이"],"content":"참고 링크 [1] boot 파티션 상세 설명(https://www.raspberrypi.org/documentation/configuration/boot_folder.md) [2] WiFi 설정을 위한 wpa_supplicant 설명(https://www.raspberrypi.org/documentation/configuration/wireless/headless.md) [3] 라즈베리파이 제로의 USB OTG 모드 설정(https://gist.github.com/gbaman/50b6cca61dd1c3f88f41) ","date":"2020-11-05","objectID":"/posts/rpi/headless-config-in-sd/:4:0","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"/posts/rpi/headless-config-in-sd/"},{"categories":["개발","라즈베리파이"],"content":"최근 라즈베리파이 사이트에서는 손쉽게 라즈베리파이 OS설치를 위한 프로그램 Raspberry Pi Imager를 제공하지만, 본 문서에서는 해당 프로그램을 사용하지 않고 직접 설치하는 과정을 설명하려 한다. 당연히 최근의 라즈베리파이는 microSD카드를 사용하지만, 본 글에서는 편의상 SD카드라고 표현하도록 하겠다. OS 이미지를 다운받아서 준비해놓자. Raspberry Pi OS with desktop and recommended software: 기본적인 GUI 뿐만 아니라 모든 추천 SW가 설치되어 있는 상태 Raspberry Pi OS with desktop: 기본적인 GUI와 최소한의 SW만 설치되어 있는 상태 Raspberry Pi OS Lite: 최소한의 OS 구성요소만 설치됨 (GUI도 설치되어 있지 않음) ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:0:0","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["개발","라즈베리파이"],"content":"윈도우즈에서 SD카드에 OS 설치하기 먼저 SD카드를 포맷해야 한다. 윈도우즈의 포맷 기능 사용 SD 그룹의 포맷 도구 사용 SD카드 내에 1개의 파티션으로, FAT32로 포맷하면 된다. ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:1:0","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["개발","라즈베리파이"],"content":"SD카드의 용량이 64GB이상일 때 (SDXC) SD카드의 용량이 32GB보다 큰 용량이라면 SD카드 포맷 시 추가적으로 수행해야 할 작업이 있다. (보통 용량이 32GB 다음에 64GB이므로 64GB라고 표현하였다.) 문제가 되는 SD카드는 표면에 SDXC 혹은 SDUC라고 써있는 카드들이다. SDUC는 표준상 2TB 이상일텐데, 라즈베리파이에 그만큼 비싼 카드를 사용할 사람은 없으리라 생각하여 SDXC만 고려하도록 하겠다. 특히 2020년 기준으로는 SD카드의 단가가 많이 내려간 편이라 64GB의 가성비가 32GB의 가성비보다 좋은 경우가 있고, 일부 브랜드의 경우 용량이 더 큰데도 가격이 더 싼 경우가 존재하므로 다루는 것이 좋을 것이라 생각했다. 문제의 원인은 SDXC에서 기본 파일시스템 형식을 exFAT로 선정했기 때문인데, 일반적인 방법으로는 윈도우즈에서 SDXC 카드를 FAT32로 포맷할 수 없기 때문이다. 라즈베리파이의 부팅 파티션은 FAT32만 가능하기 때문에 이를 수정해줘야 한다. FAT32 포맷 GUI 버전 FAT32 포맷 CLI 버전 ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:1:1","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["개발","라즈베리파이"],"content":"라즈베리파이 OS 이미지 올리기 Win32DiskImager balenaEtcher Upshift imgFlasher 위 도구 중 하나를 사용하여 다운받았던 OS 이미지를 올리면 된다. ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:1:2","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["개발","라즈베리파이"],"content":"리눅스에서 터미널로 SD카드에 OS 설치하기 ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:2:0","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["개발","라즈베리파이"],"content":"SD카드 블록 장치 이름 확인 $ lsblk -p lsblk 명령을 통해 연결된 블록 장치(저장장치)를 확인한다. 사이즈, 마운트 경로 등을 통해 SD카드의 장비 이름을 알아내도록 하자. (만약 블록 장치가 많거나 유사해서 확인하기 힘들다면, SD카드를 연결하기 전의 명령어 결과와 연결한 후의 명령어 결과를 비교하여 유추하도록 하자) $ lsblk -p NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 1 60.1G 0 disk ├─/dev/sda1 8:1 1 256M 0 part /mnt/boot └─/dev/sda2 8:2 1 59.8G 0 part /mnt/rootfs /dev/nvme0n1 259:0 0 476.9G 0 disk ├─/dev/nvme0n1p1 259:1 0 512M 0 part /efi ├─/dev/nvme0n1p2 259:2 0 444.4G 0 part / └─/dev/nvme0n1p3 259:3 0 32G 0 part [SWAP] 나의 경우는 노트북의 OS가 nvme0에 설치되어있으므로 SD카드는 sda임을 알 수 있다. ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:2:1","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["개발","라즈베리파이"],"content":"라즈베리파이 OS 이미지 쓰기 # dd bs=4M status=progress if=$RPI_OS_IMG of=$SD_DEVICE dd 명령으로 라즈베리파이 OS 이미지를 SD카드에 기록한다. 위 명령어의 $RPI_OS_IMG는 라즈베리파이 OS 이미지 파일을 압축해제한 경로를 넣으면 되고, $SD_DEVICE는 위에서 찾은 SD카드 블록 장치의 경로를 입력한다. $ sudo dd bs=4M status=progress if=./2020-08-20-raspios-buster-armhf.img of=/dev/sda 3812622336 bytes (3.8 GB, 3.6 GiB) copied, 209 s, 18.2 MB/s 911+0 records in 911+0 records out 3821010944 bytes (3.8 GB, 3.6 GiB) copied, 537.638 s, 7.1 MB/s ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:2:2","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["개발","라즈베리파이"],"content":"파티션 상태 확인, 확장하기 $ lsblk -p $SD_DEVICE 라즈베리파이 OS 이미지가 기록된 SD카드의 파티션 정보를 확인해보자. 이미 우리는 SD카드의 블록 장치 이름을 알고 있으니, 해당 장치 이름만 사용해서 해당 디스크의 상태를 확인하자. $ lsblk -p /dev/sda NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 1 60.1G 0 disk ├─/dev/sda1 8:1 1 256M 0 part └─/dev/sda2 8:2 1 3.3G 0 part 결과를 자세히 보면 2개의 파티션으로 나눠져 있는데, sda1은 라즈베리파이 부팅 설정을 위한 파티션으로 FAT32로 포맷되어있다. sda2는 라즈베리파이의 rootfs이다. (부팅 후 ‘/‘에 마운트되는 파일시스템) 문제는 두 파티션 용량의 합이 전체 SD카드의 용량에 비해 터무니없이 작다는 것이다. 약 56GB가 낭비되고 있는데, 이 공간을 rootfs가 사용할 수 있게 파티션을 변경해보자. 여기서는 fdisk를 사용하도록 하겠다. (참고로 라즈베리파이를 부팅한 이후에도 자체적으로 파티션 확장하는 기능이 제공되긴 한다.) # fdisk $SD_DEVICE $ sudo fdisk /dev/sda Welcome to fdisk (util-linux 2.36). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): p Disk /dev/sda: 60.06 GiB, 64490569728 bytes, 125958144 sectors Disk model: Storage Device Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x58ce116e Device Boot Start End Sectors Size Id Type /dev/sda1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/sda2 532480 7462911 6930432 3.3G 83 Linux SD카드의 장치 이름을 인자로 fdisk를 실행한다. 먼저 p 명령을 입력하여 현재 SD카드의 상세 정보를 출력한다. 여기에서 중요한 값은 Disk의 전체 sector 갯수(예시의 125958144), rootfs(2번째 파티션)의 시작 sector 값(예시의 532480)이다. Command (m for help): d Partition number (1,2, default 2): 2 Partition 2 has been deleted. fdisk에서는 파티션을 바로 확장하는 명령어가 제공되지 않는다. 파티션을 삭제하고 용량을 키워서 다시 할당해야 한다. (해당 파티션의 내용이 삭제되는 것이 아니라, 파티션의 범위 정보만 변경되는 것이다.) d 명령을 입력하여 rootfs 파티션의 정보만 삭제한다. Command (m for help): n Partition type p primary (1 primary, 0 extended, 3 free) e extended (container for logical partitions) Select (default p): p Partition number (2-4, default 2): 2 First sector (2048-125958143, default 2048): 532480 Last sector, +/-sectors or +/-size{K,M,G,T,P} (532480-125958143, default 125958143): Created a new partition 2 of type 'Linux' and of size 59.8 GiB. Partition #2 contains a ext4 signature. Do you want to remove the signature? [Y]es/[N]o: n 이제 기존 파티션의 위치에 맞춰서 용량을 늘려서 다시 생성하자. n 명령을 입력하여 새로 생성한다. primary type으로 선택, 파티션 번호는 기존의 2번으로 선택하자. (위의 extended 파티션 타입은 해당 파티션이 Logical partition일 때 이를 확장하기 위해 사용되는 파티션이므로 지금 파티션 크기를 확장시키는 것과 다른 것이다.) 이제 파티션의 시작 sector, 마지막 sector를 설정해줘야 한다. 삭제하기 전의 sda2 파티션의 시작 sector 값을 입력하자. (위에서 확인했던 532480) 자세히 보면 비어있는 공간이 2048번 sector에도 존재하기 때문에 기본값으로 입력하면 의도하지 않은 파티션을 생성할 수도 있다. 마지막 sector의 기본값은 전체 sector의 끝이므로 그냥 사용해도 된다. Command (m for help): p Disk /dev/sda: 60.06 GiB, 64490569728 bytes, 125958144 sectors Disk model: Storage Device Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x58ce116e Device Boot Start End Sectors Size Id Type /dev/sda1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/sda2 532480 125958143 125425664 59.8G 83 Linux 이후 다시 p 명령을 입력하여 수정된 파티션 테이블을 확인하자. 이번엔 rootfs의 크기가 59.8GB로 늘어난 것을 확인할수 있다. 현재 상태는 이렇게 파티션 테이블을 재구성한다고 한 것이지 아직 반영된 것이 아니다. Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. w 명령을 입력하여 현재 설정된 파티션 테이블을 실제로 반영하도록 하자. 해당 파티션이 변경되면 fdisk는 자동으로 종료된다. ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:2:3","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["개발","라즈베리파이"],"content":"파티션 마운트하기 이제 아래에서 라즈베리파이 부팅 설정을 수정하려면 boot 파티션을 마운트해야한다. mount 명령으로 각 파티션을 특정 디렉토리에 마운트하자. # mount $SD_DEVICE_PARTITION $MOUNT_PATH $ lsblk -p /dev/sda NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 1 60.1G 0 disk ├─/dev/sda1 8:1 1 256M 0 part └─/dev/sda2 8:2 1 59.8G 0 part $ ls -d $PWD/* /mnt/boot /mnt/rootfs $ sudo mount -t vfat /dev/sda1 /mnt/boot $ sudo mount -t ext4 /dev/sda2 /mnt/rootfs # mount -t $FS_TYPE $SD_DEVICE_PARTITION $MOUNT_PATH 일반적으로는 mount 명령시 파일시스템 타입을 입력하지 않아도 알아서 해당 파일시스템 타입에 맞게 알아서 마운트해주지만, 만약 특별히 명시해야 할 필요가 있을 경우에는 FAT32는 “vfat\"로, ext4는 “ext4\"로 입력해주면 된다. 이후 마운트 된 path에 진입하면 파일들이 존재하는 것을 확인할 수 있을 것이다. ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:2:4","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["개발","라즈베리파이"],"content":"참고 링크 [1] 라즈베리파이 OS 설치 방법(https://www.raspberrypi.org/documentation/installation/installing-images/) [2] SD카드 요구사항(https://www.raspberrypi.org/documentation/installation/sd-cards.md) [3] SDXC 카드 포맷하기(https://www.raspberrypi.org/documentation/installation/sdxc_formatting.md) [4] 윈도우즈에서 설치 방법(https://www.raspberrypi.org/documentation/installation/installing-images/windows.md) [5] 리눅스에서 설치 방법(https://www.raspberrypi.org/documentation/installation/installing-images/linux.md) ","date":"2020-11-04","objectID":"/posts/rpi/flash-rpi-os-into-sd/:3:0","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"/posts/rpi/flash-rpi-os-into-sd/"},{"categories":["리뷰"],"content":"본 리뷰는 리얼리눅스로부터 어떠한 지원도 받지 않았으며, 제 사비로 수강한 경험에 대한 리뷰입니다. ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:0:0","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["리뷰"],"content":"리뷰 요약 추천 대상 시스템 분야에 대한 이해가 필요한 초급~중급 수준의 개발자 장점 시스템 \u0026 OS 분야를 다루는 강의 이론 이해 \u0026 실습 적용이 적절히 어우러진 밸런스 있는 강의 지식 전달만이 아닌 해결법도 같이 가르치는 강의 수강 이후에도 질문 가능한 Q\u0026A 단점 강의 주제가 한정적 \u0026 매번 강의가 열리지 않는다는 점 저렴한 것은 아닌 수강비용 실습이 완벽하게 진행되지 않을 수도 있음 ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:1:0","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["리뷰"],"content":"수강 계기 나는 원래 페스타, 온오프믹스 등 모임 주관 사이트같은 곳에서 강의 등을 찾아보고 괜찮은 강의나 행사에 참여하는 편이다. 내가 모르는 개발 트렌드나 새로운 지식의 범위를 넓히는 방법 중 하나다. 원래 2019년에 iamroot 커널 스터디에 참여할 예정이었는데, 스터디 시작 일정과 전문연구요원 훈련소 일정이 겹치는 바람에 해당 스터디에는 참여할 수 없었다. 대신 2020년에 스터디 진행하기 전에 커널이나 C언어 심화 공부나 리눅스 커널 관련 책을 독학할 예정이었는데, 이때 페스타에서 리얼리눅스 강의를 발견했다. 위 사진에서 볼 수 있듯, 나는 5번이나 리얼리눅스 강의를 수강하였으며, 당연히 강의가 만족스러웠기 때문에 여러 번에 걸쳐 다양한 강의를 수강했다. 본 리뷰에서는 Try 오픈소스 컨트리뷰션을 제외한 나머지 리눅스 커널에 관련된 강의들만 리뷰하도록 하겠다. (Try 오픈소스 컨트리뷰션은 따로 글을 할당하여 리뷰할 예정.) ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:2:0","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["리뷰"],"content":"좋은 점 나는 현재 임베디드 FW 개발 업무를 하고 있는데, 내 업무와 관련된 강의는 정말 찾기 힘든 편이다. 시스템 \u0026 OS 관련 강의는 정말 찾기 힘들고, 가끔 있는 강의는 각 회사별 제품 사용에 관련된 강의로 개념적인 부분을 중점적으로 보는 강의는 거의 못 본 것 같다. ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:3:0","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["리뷰"],"content":"실습 위주의 강의 내가 이전까지 시스템 \u0026 OS 공부 할 때 느꼈던 문제는 이런 것들이 있다. 내용 자체가 너무 넓고, 복잡하고, 서로 관계가 깊이 얽혀 있고 어렵다. (책을 읽어도 머리속에 하나도 들어오지 않는다.) 각 기능이 유기적으로 연결되어있어 적당한 시작점이 존재하지 않는다. (공부할 때 임시로 배제하면서 진행하는 수 밖에 없다.) 해당 상황을 겪어 보기 전 까지는 각 기법이 사용되는 이유를 이해하기 힘들다. (머리로는 이해한다고 하지만 딱히 문제의 심각성 등을 이해하지 못한다.) 직접 디버깅을 해 보면서 단계적으로 코드 흐름을 따라가기 어렵다. (코드가 너무 복잡하거나, 내가 찍을 수 있는 시간 간격보다 너무 짧거나) 각 문제들의 내용을 종합하자면 시스템 \u0026 OS 공부는 직접 상황을 맞닥드리지 않는 이상은 Bottom-up 방식으로 공부하게 되는 것이고, 어디부터 건드려야할지 감이 안 온다는 것이다. 보통 여기서 열리는 강의는 특정 주제에 대한 특강 식으로 진행된다. 각 특강에서는 단계적으로 어떤 기능 하나에 대해서만 직접 확인하는 것을 목적으로 하기 때문에 공부 범위가 발산하는 것을 어느정도 방지할 수 있고, Trace라는 방식으로 실제 커널의 동작 과정을 확인해 볼 수 있기 때문에 위의 문제점을 많이 해결해 주는 편이다. ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:3:1","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["리뷰"],"content":"uftrace, ftrace, sysfs 등을 통해 이론을 증명하는 실습 실습에는 uftrace, ftrace, sysfs를 사용한다. 개념적인 설명이 진행된다. 기능 확인을 위해 작성된 C 프로그램 코드에 대해 간략히 설명한다. 해당 프로그램을 uftrace로 실행하면서 각 함수 실행 흐름을 기록한다. Trace된 함수 흐름을 따라 리눅스 커널의 코드를 읽으면서 예상 흐름을 확인한다. 직접 작성한 코드로 재현하기 힘들거나, 실시간으로 일어나는 현상을 확인할 때는 ftrace나 sysfs 설정을 통해 확인한다. ftrace는 실제 커널 디버깅 과정에서도 사용하는 것으로 알고 있다. 이런 도구 사용법을 같이 설명하므로 추후 개별적인 문제 해결에서도 도움이 될 수 있다. ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:3:2","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["리뷰"],"content":"아쉬운 점 물론 아쉬운 점이 없는 것은 아니다. 솔직히 값어치는 하지만 쉽게 수강할 만큼 싼 비용은 아니다. (굳이 비교하자면 다른 현장 강의 가격대와 비교했을 때 비싼 건 아니다.) ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:4:0","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["리뷰"],"content":"완벽하게 진행되지는 않는 실습 실습을 통해 이론을 실제로 증명하는 것이 이 강의의 핵심인데, 실습이 완벽하게 매번 똑같이 잘 이루어 지는 것은 아니다. 첫번째 원인은 각 실습 환경이 완전히 동일하지 않기 때문이다. 강의에서는 최대한 동일한 환경을 제공하기 위해 VirtualBox 이미지로 제공하는데, 아무리 가상머신으로 표준화 해도 Host OS에서 문제를 일으키면 답이 안나온다. 최악의 경우 모든 실습이 잘 진행되지 않아 강의 내내 구경만 하는 경우가 생길 수도 있다. 두번째 원인은 원하는 대로 Trace하는 것이 생각만큼 쉽지 않다는 것이다. Trace 중간에 스케쥴링이 일어나서 생기는 함수도 같이 추적되는 것은 물론이며, 일부 기능을 제대로 확인하려면 매번 cache를 비워줘야 하는 등 원하는 대로 쉽게 Trace되지 않는다. 이 외에도 사소한 오류로 인해 강의가 잘 진행되지 않는 문제가 가끔 있는데, 이건 강의 횟수가 더 늘어남에 따라 점점 보완될 것이라 생각한다. 강의나 실습 조교 등을 해 본 사람이라면 공감할텐데, 수강생이 일으키는 예외의 범위는 강사의 예상 범위를 뛰어넘는다. 가르치는 입장에서는 당연하다고 생각되는 부분에서도 오류가 발생하기 때문이다. ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:4:1","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["리뷰"],"content":"수강 대상 강의 정보에 수강대상, 강의 수준이 나와있다. 본인 실력에 대하여 너무 과대평가하거나 과소평가하지 말고 냉정하게 생각해보면 자신이 초급인지, 초급과 중급 사이인지, 중급인지 알 수 있을 것이다. 만약 본인이 해당 강의를 수강하기에 적합할지 잘 모르겠다면 상담을 요청해 보는 것도 괜찮다. 나는 실제로 초급과 중급 사이라고 생각하고 리눅스 SW 기본반을 들었었는데, 배운게 없는 것은 아니지만 이미 아는 내용을 중복으로 듣는 것 같은 느낌이 있었다. (물론 기본반을 들으면서 OS 중급반을 같이 듣는 것도 원인 중 하나라고 생각한다.) 위에서 설명한 uftrace, ftrace, sysfs를 통한 디버깅 등을 직접 수행할 수 있는 사람이라면 중급 이상은 된다고 생각하면 될 것 같다. 현재까진 고급 주제를 다루는 완전 심화반은 열리지 않은 것으로 알고있다. ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:5:0","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["리뷰"],"content":"리뷰 하는 이유 초반에 말했듯 시스템 \u0026 OS 관련 강의는 정말 찾아보기 힘들다. 대학교 강의를 제외하고는 기업 내부 초청 강연, 제품 홍보나 관련 협회의 교육이 거의 전부다. (물론 다른 IT관련 학원에도 그나마 관련된 강좌가 있겠지만, 입학생들에게 일단 전화걸고 보는 악명높은 학원은 당연히 고려대상에서 제외했다.) 웹, 모바일 어플리케이션 개발, 요새 뜨는 트렌드 관련 교육은 생활코딩, 인프런 등 무료나 저렴한 가격으로도 수강할 수 있다. 이런 시스템 \u0026 OS 관련 분야 강의가 더 많아져서 전체적인 파이가 커 지길 바라는 마음에 리뷰를 작성했다. ","date":"2020-10-02","objectID":"/posts/review/lecture-reallinux-kernels/:6:0","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"/posts/review/lecture-reallinux-kernels/"},{"categories":["개발"],"content":"GUI 기반으로 작성한 프로그램은 직관적이지만, 해당 기능을 사용하기 위해 마우스를 사용해야 하며, 이로 인해 자동화하기 어렵다는 문제점이 있다. 물론 매크로 등을 활용할 수 있지만, 사람이 직접 수행하지 않을 뿐, 결국 프로그램으로 마우스 클릭 등을 반복하는 것이다. GUI 기반으로 개발된 파일을 변환해주는 프로그램들을 CI/CD 과정에 사용하려 한다고 가정해보자. GUI를 실행하기 위한 Desktop Environment가 없는 Container/Build server일 수 있다. GUI가 있는 환경이라도, 해당 환경에 맞춰 매크로를 기록해야 한다. 매크로를 사용해도 Build server에 RDP 등으로 접속 시, 해상도 변경, 좌표 변경 등 이슈가 발생한다. 여러 GUI 기반 프로그램들을 실행할 때, 마우스 위치가 점유 자원으로서 병렬성을 방해한다. 해당 프로그램의 실행 결과도 GUI로 나타나므로, 이를 쉽게 확인할 수 없다. 위의 상황은 극단적으로 가정한 것이지만, 최소 1개 이상 실제 문제가 될 것이라 예상한다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:0:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"목표 Window Manager(Windows Explorer, Gnome 등)나 Shell(Bash, Command Prompt 등)에서 실행 시, GUI 환경으로 실행 Shell에서 실행할 때 특정 인자를 입력하면(혹은 Windows Manager의 Shortcut에 인자 추가) GUI를 띄우지 않고, 해당 인자에 따라 기능을 수행한 뒤 종료. 필요에 따라 진행 과정에 대한 Log를 출력한다. 해당 프로그램의 성공/실패 여부에 따라 확인할 수 있게 Error code를 반환하며 종료한다. 위의 목표를 개발자 기준의 요구사항으로 해석하면 아래와 같다. 기존의 GUI 실행에 관련된 코드를 뒤엎지 않고 기능을 추가해야 한다. 해당 프로그램 실행의 인자를 읽고, 특정 조건 시 GUI를 실행시키는 함수를 호출하지 않아야 한다. stdio (특히 stdout, stderr)가 해당 프로그램을 실행시킨 shell과 연결되어 있어야 한다. GUI를 실행시키지 않은 상태에서 원하는 exit code로 프로그램을 종료시켜야 한다. MFC같이 안 좋은 GUI framework에서 개발해야 한다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:1:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"진단 이제 MFC 프로그램을 작성하고, Shell에서 실행시켜보자. MFC 응용 프로그램 프로젝트를 ConsoleGuiTool로 가정하겠다. (대화 상자 기반으로 작성하였으나, 다른 종류도 크게 문제되지 않는다.) 빌드하고 Command Prompt에서 실행시켜보면 아래 스크린샷과 같은 상황을 확인할 수 있을 것이다. 분명 해당 프로그램이 종료되지 않았음에도 Shell과의 연결이 끊어졌다. 요구사항 3, 4의 상황에서 문제가 생길 수 있다. (자세한 설명은 Command Prompt 명령어 설명에서 다루도록 한다.) ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:2:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"Console 실행 모드 추가하기 일단 수정해야 할 파일은 현재 MFC 프로그램의 진입점 부분이다. CWinApp을 상속하고 있는 클래스의 소스 코드를 찾자. (특별히 이름을 변경하지 않았다면, 프로젝트 이름과 같은 *.h, *.cpp일 것이다.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // ConsoleGuiTool.h : main header file for the PROJECT_NAME application // #pragma once #ifndef __AFXWIN_H__ #error \"include 'stdafx.h' before including this file for PCH\" #endif #include \"resource.h\" // main symbols // CConsoleGuiToolApp: // See ConsoleGuiTool.cpp for the implementation of this class // class CConsoleGuiToolApp : public CWinApp { public: CConsoleGuiToolApp(); // Overrides public: virtual BOOL InitInstance(); // Implementation DECLARE_MESSAGE_MAP() }; extern CConsoleGuiToolApp theApp; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 // ConsoleGuiTool.cpp : Defines the class behaviors for the application. // #include \"stdafx.h\"#include \"ConsoleGuiTool.h\"#include \"ConsoleGuiToolDlg.h\" #ifdef _DEBUG #define new DEBUG_NEW #endif // CConsoleGuiToolApp BEGIN_MESSAGE_MAP(CConsoleGuiToolApp, CWinApp) ON_COMMAND(ID_HELP, \u0026CWinApp::OnHelp) END_MESSAGE_MAP() // CConsoleGuiToolApp construction CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, // Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() { // InitCommonControlsEx() is required on Windows XP if an application // manifest specifies use of ComCtl32.dll version 6 or later to enable // visual styles. Otherwise, any window creation will fail. INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // Set this to include all the common control classes you want to use // in your application. InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(\u0026InitCtrls); CWinApp::InitInstance(); // Create the shell manager, in case the dialog contains // any shell tree view or shell list view controls. CShellManager *pShellManager = new CShellManager; // Activate \"Windows Native\" visual manager for enabling themes in MFC controls CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // Standard initialization // If you are not using these features and wish to reduce the size // of your final executable, you should remove from the following // the specific initialization routines you do not need // Change the registry key under which our settings are stored // TODO: You should modify this string to be something appropriate // such as the name of your company or organization SetRegistryKey(_T(\"Local AppWizard-Generated Applications\")); CConsoleGuiToolDlg dlg; m_pMainWnd = \u0026dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) { // TODO: Place code here to handle when the dialog is // dismissed with OK } else if (nResponse == IDCANCEL) { // TODO: Place code here to handle when the dialog is // dismissed with Cancel } else if (nResponse == -1) { TRACE(traceAppMsg, 0, \"Warning: dialog creation failed, so application is terminating unexpectedly.\\n\"); TRACE(traceAppMsg, 0, \"Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\"); } // Delete the shell manager created above. if (pShellManager != NULL) { delete pShellManager; } // Since the dialog has been closed, return FALSE so that we exit the // application, rather than start the application's message pump. return FALSE; } 해당 class에 기존 GUI환경의 init을 담당할 InitGuiWindow()와 콘솔모드로 실행할 RunConsole() 함수를 추가한다. 이후 기존의 InitInstance()함수를 InitGuiWindow()로 교체하고, 새로운 InitInstance()를 아래와 같이 작성한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // ConsoleGuiTool.h : main header file for the PROJECT_NAME application // #pragma once #ifndef __AFXWIN_H__ #error \"include 'stdafx.h' before including this file for PCH\" #endif #include \"resource.h\" // main symbols // CConsoleGuiToolApp: // See ConsoleGuiTool.cpp for the implementation of this class // class CConsoleGuiToolApp : public CWinApp { public: CConsoleGuiToolApp(); // Overrides public: virtual BOOL InitInstance(); // Implementation DECLARE_MESSAGE_MAP() BOOL InitGuiWindow(); BOOL RunConsole(); }; extern CConsoleGuiToolApp theApp; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // ConsoleGuiTool.cpp : Defines the class behaviors for the application. // #include \"stdafx.h\"#include \"ConsoleGuiTool.h\"#include \"ConsoleGuiToolDlg.h\" #ifdef _DEBUG #define new DEBUG_NEW #endif // CConsoleGuiToolApp BEGIN_MESSAGE_MAP(CConsoleGuiToolApp, CWinApp) ON_COMMAND(ID_HELP, \u0026CWinApp::OnHelp) END_MESSAGE_MAP() // CConsoleGuiToolApp construction CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, // Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() { int nArgCnt = __argc; if (nArgCnt == 1) { return InitGuiWindow(); } else { return RunConsole(); } } BOOL CConsoleGuiToolApp::InitGuiWindow() { // InitCommonControlsEx() is required on Windows XP if an application // manifest specifies use of ComCtl32.dll version 6 or later to enable // visual styles. Otherwise, any window creation will fail. INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // Set this to include all the common control classes you want to use // in your application. InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(\u0026InitCtrls); CWinApp::InitInstance(); // Create the shell manager, in case the dialog contains // any shell tree view or shell list view controls. CShellManager *pShellManager = new CShellManager; // Activate \"Windows Native\" visual manager for enabling themes in MFC controls CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // Standard initialization // If you are not using these features and wish to reduce the size // of your final executable, you should remove from the following // the specific initialization routines you do not need // Change the registry key under which our settings are stored // TODO: You should modify this string to be something appropriate // such as the name of your company or organization SetRegistryKey(_T(\"Local AppWizard-Generated Applications\")); CConsoleGuiToolDlg dlg; m_pMainWnd = \u0026dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) { // TODO: Place code here to handle when the dialog is // dismissed with OK } else if (nResponse == IDCANCEL) { // TODO: Place code here to handle when the dialog is // dismissed with Cancel } else if (nResponse == -1) { TRACE(traceAppMsg, 0, \"Warning: dialog creation failed, so application is terminating unexpectedly.\\n\"); TRACE(traceAppMsg, 0, \"Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\"); } // Delete the shell manager created above. if (pShellManager != NULL) { delete pShellManager; } // Since the dialog has been closed, return FALSE so that we exit the // application, rather than start the application's message pump. return FALSE; } BOOL CConsoleGuiToolApp::RunConsole() { printf(\"Program is running in console mode\\n\"); Sleep(5000); printf(\"It seems program did some job, 5 second passed\\n\"); return FALSE; } 일단 콘솔 모드 진입 조건은 실행파일 뒤에 인자가 하나라도 붙는 것으로 설정했다. 콘솔 모드 진입시, 콘솔 모드로 실행된다는 메시지를 출력하고, 5초 이후 무언가 완료되었다고 하고 종료되게 설정하였다. 빌드하고 Command Prompt에서 실행시켜보면 아래 스크린샷과 같은 상황을 확인할 수 있을 것이다. 일단 실행 인자 옵션에 따라 기존 GUI 구동을 유지한 상태에서, 콘솔 모드 실행에 성공했다. 하지만 printf를 통한 메시지 출력이 되지 않는 것을 확인할 수 있다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:3:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"프로그램을 실행시킨 shell과 stdio 연결 해당 증상의 원인은 MFC 프로그램 실행 시, stdio가 기존 shell에서 떨어지기 때문이다. MFC 프로그램을 실행시킨 부모 프로세스(Command Prompt 혹은 PowerShell)의 stdio와 연결해야한다. 기존의 RunConsole() 함수를 아래와 같이 수정한다. (코드 상단에 #include \u003ciostream\u003e을 해야한다.) 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 BOOL CConsoleGuiToolApp::RunConsole() { if (AttachConsole(ATTACH_PARENT_PROCESS)) { FILE *pfStdin; FILE *pfStdout; FILE *pfStderr; freopen_s(\u0026pfStdin, \"CONIN$\", \"r\", stdin); freopen_s(\u0026pfStdout, \"CONOUT$\", \"w\", stdout); freopen_s(\u0026pfStderr, \"CONOUT$\", \"w\", stderr); std::cin.clear(); std::cout.clear(); std::cerr.clear(); } printf(\"Program is running in console mode\\n\"); Sleep(5000); printf(\"It seems program did some job, 5 second passed\\n\"); return FALSE; } L116~128의 내용은 부모 프로세스의 콘솔에 연결하고 stdin, stdout, stderr를 다시 여는 작업을 수행한다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:4:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"임의의 Exit Code로 종료시키기 원칙적으로는 main() 함수의 return값으로 exit code를 보내는 것이 정석이나, 우리가 현재 수정 가능한 코드 범위에서는 main() 함수를 수정할 수 없기 때문에 차선책인 exit() 함수를 사용하면 된다. stdin의 연결 상태를 확인할 겸, 아래와 같이 RunConsole() 함수를 수정한다. 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 BOOL CConsoleGuiToolApp::RunConsole() { int nExitCode; if (AttachConsole(ATTACH_PARENT_PROCESS)) { FILE *pfStdin; FILE *pfStdout; FILE *pfStderr; freopen_s(\u0026pfStdin, \"CONIN$\", \"r\", stdin); freopen_s(\u0026pfStdout, \"CONOUT$\", \"w\", stdout); freopen_s(\u0026pfStderr, \"CONOUT$\", \"w\", stderr); std::cin.clear(); std::cout.clear(); std::cerr.clear(); } printf(\"Program is running in console mode\\n\"); Sleep(5000); printf(\"It seems program did some job, 5 second passed\\n\"); printf(\"Enter exit code to get: \"); std::cin \u003e\u003e nExitCode; exit(nExitCode); return FALSE; } 위 목표를 모두 달성했다. 이제 실행인자를 잘 입력 받았는지 확인하고, 이를 비교하기만 하면 된다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:5:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"실행 인자 사용을 위한 추가 설명 이전의 설명은 CWinApp::InitInstance() 메서드를 수정하여 GUI를 띄우지 않고 콘솔에서 입출력을 수행하는 부분을 설명했다. 실행 인자를 입력받는 방법은 __argc, __argv, __wargv 전역변수를 활용한다. 해당 변수는 stdlib.h에서 제공하며, Microsoft에서만 제공하는 확장 기능이다. (C,C++ 표준이 아님) (Multi-Byte Character Set으로 빌드한 경우 __argv를, Unicode Character Set으로 빌드한 경우 __wargv를 사용) 이외에도 GetCommandLine(), CWinApp::ParseCommandLine() 등의 방법으로도 실행 인자를 얻을 수 있다. 이 중 ParseCommandLine()에서 사용하는 CCommandLineInfo는 Windows에서 제공하는 기능의 일부를 해석해준다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:6:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"Command Prompt 명령어 설명 사실 Windows에서 제공하는 Command Prompt, PowerShell에서 GUI를 사용하는 프로그램을 실행시키면 자동으로 해당 shell에서 detach하게 되어있다. 현재 수정한 방식은 GUI를 화면에 출력하기 전에 기능을 수행하고 종료시킨 것이므로, 똑같이 shell에서 detach하게 되어있다. Command Prompt에서 콘솔 모드 사용을 위해서는 아래와 같은 옵션을 고려해야 한다. start /wait \u003cPROGRAM\u003e \u003cPROGRAM\u003e을 실행시키고, 해당 \u003cPROGRAM\u003e이 종료될 때 까지 기다린다. cmd /v:on /c “echo !time! … Batch file을 실행할 때, 환경변수 등은 %VAR%를 통해 그 값으로 치환할 수 있다. 하지만 위 예시와 같이 프로그램의 실행 시간을 측정하기 위해 한 명령행 안에 %VAR%로 넣을 경우, 즉시 치환된다. (!time! 대신 %time%로 입력 시, 실제 소요시간과 관계없이 같은 시간이 나타난다.) 해당 변수에 접근하는 순간 치환되길 원한다면, 위와 같이 !VAR!로 표기해야 한다. 또한 위와 같은 delayed environment variable expansion을 사용하려면 현재 콘솔에 옵션을 설정하거나 cmd로 실행시킬 때, /v:on 옵션을 주고 실행시켜야 한다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:7:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"해설 C/C++로 작성한 프로그램의 기본 진입점은 main()함수이다. main()함수의 매개변수로 int argc, char** argv를 사용하여 실행 인자를 프로그램 내에서 확인할 수 있다. 하지만 MFC로 프로젝트를 생성할 경우, main()함수를 개발자가 직접 편집할 수 없다. 이전의 코드에서 봤던 것 처럼 개발자가 수정 가능한 프로그램의 최초 진입 지점은 CWinApp::InitInstance() 메서드이다. main()함수 역할을 수행하는 WinAPI에서 제공하는 진입점은 _tWinMain() 함수이다. MFC에서 작성된 _tWinMain()함수의 정의는 VC\\atlmfc\\src\\mfc\\appmodul.cpp에서 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // This is a part of the Microsoft Foundation Classes C++ library. // Copyright (C) Microsoft Corporation // All rights reserved. // // This source code is only intended as a supplement to the // Microsoft Foundation Classes Reference and related // electronic documentation provided with the library. // See these sources for detailed information regarding the // Microsoft Foundation Classes product. #include \"stdafx.h\"#include \"sal.h\" ///////////////////////////////////////////////////////////////////////////// // export WinMain to force linkage to this module extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow); extern \"C\" int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow) #pragma warning(suppress: 4985) { // call shared/exported WinMain return AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow); } ///////////////////////////////////////////////////////////////////////////// // initialize app state such that it points to this module's core state BOOL AFXAPI AfxInitialize(BOOL bDLL, DWORD dwVersion) { AFX_MODULE_STATE* pModuleState = AfxGetModuleState(); pModuleState-\u003em_bDLL = (BYTE)bDLL; ASSERT(dwVersion \u003c= _MFC_VER); UNUSED(dwVersion); // not used in release build #ifdef _AFXDLL pModuleState-\u003em_dwVersion = dwVersion; #endif : _tWinMain()에서 호출하는 AfxWinMain()의 정의는 VC\\atlmfc\\src\\mfc\\winmain.cpp에서 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // This is a part of the Microsoft Foundation Classes C++ library. // Copyright (C) Microsoft Corporation // All rights reserved. // // This source code is only intended as a supplement to the // Microsoft Foundation Classes Reference and related // electronic documentation provided with the library. // See these sources for detailed information regarding the // Microsoft Foundation Classes product. #include \"stdafx.h\"#include \"sal.h\" ///////////////////////////////////////////////////////////////////////////// // Standard WinMain implementation // Can be replaced as long as 'AfxWinInit' is called first int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow) { ASSERT(hPrevInstance == NULL); int nReturnCode = -1; CWinThread* pThread = AfxGetThread(); CWinApp* pApp = AfxGetApp(); // AFX internal initialization if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow)) goto InitFailure; // App global initializations (rare) if (pApp != NULL \u0026\u0026 !pApp-\u003eInitApplication()) goto InitFailure; // Perform specific initializations if (!pThread-\u003eInitInstance()) { if (pThread-\u003em_pMainWnd != NULL) { TRACE(traceAppMsg, 0, \"Warning: Destroying non-NULL m_pMainWnd\\n\"); pThread-\u003em_pMainWnd-\u003eDestroyWindow(); } nReturnCode = pThread-\u003eExitInstance(); goto InitFailure; } nReturnCode = pThread-\u003eRun(); InitFailure: #ifdef _DEBUG // Check for missing AfxLockTempMap calls if (AfxGetModuleThreadState()-\u003em_nTempMapLock != 0) { TRACE(traceAppMsg, 0, \"Warning: Temp map lock count non-zero (%ld).\\n\", AfxGetModuleThreadState()-\u003em_nTempMapLock); } AfxLockTempMaps(); AfxUnlockTempMaps(-1); #endif AfxWinTerm(); return nReturnCode; } ///////////////////////////////////////////////////////////////////////////// AfxGetApp()를 통해 개발자가 정의한 Application 변수의 주소를 얻고, 해당 변수에서 InitInstance() 메서드를 호출한다. 해당 함수는 개발자가 재정의할 수 있으며, 우리는 이 InitInstance()함수를 수정하여 MFC dialog를 띄우지 않고 콘솔에서 처리할 수 있도록 변형한 것이다. 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 : // CConsoleGuiToolApp construction CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, // Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() : ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:8:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"다른 GUI framework에서의 진입점 (main 함수) 아래는 각 C/C++로 작성된 GUI framework의 진입점이다. 대부분의 GUI framework는 main() 함수를 편집할 수 있다. WxWidget은 MFC와 같이 main() 함수를 편집할 수 없으므로, wxApp이 제공하는 메서드를 사용해야 한다. QT #include \u003cQApplication\u003e#include \u003cQCommandLineParser\u003e#include \u003cQCommandLineOption\u003e #include \"mainwindow.h\" int main(int argc, char *argv[]) { Q_INIT_RESOURCE(application); QApplication app(argc, argv); QCoreApplication::setOrganizationName(\"QtProject\"); QCoreApplication::setApplicationName(\"Application Example\"); QCoreApplication::setApplicationVersion(QT_VERSION_STR); QCommandLineParser parser; parser.setApplicationDescription(QCoreApplication::applicationName()); parser.addHelpOption(); parser.addVersionOption(); parser.addPositionalArgument(\"file\", \"The file to open.\"); parser.process(app); MainWindow mainWin; if (!parser.positionalArguments().isEmpty()) mainWin.loadFile(parser.positionalArguments().first()); mainWin.show(); return app.exec(); } GTK+ #include \u003cgtk/gtk.h\u003e #include \"gtk_app.h\" int main (int argc, char **argv) { GtkApplication *app; int status; app = gtk_application_new (\"org.gtk.example\", G_APPLICATION_FLAGS_NONE); g_signal_connect (app, \"activate\", G_CALLBACK (activate), NULL); status = g_application_run (G_APPLICATION (app), argc, argv); g_object_unref (app); return status; } FLTK #include \u003cFL/Fl.H\u003e#include \u003cFL/Fl_Window.H\u003e#include \u003cFL/Fl_Button.H\u003e int main(int argc, char *argv[]) { Fl_Window* w = new Fl_Window(330, 190); new Fl_Button(110, 130, 100, 35, \"Okay\"); w-\u003eend(); w-\u003eshow(argc, argv); return Fl::run(); } ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:8:1","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"참고 링크 [1] MFC 기본코드 분석(https://petra.tistory.com/1296) ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:9:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["Project Whitecat"],"content":"Project Whitecat은 우리 집 안에 있는 모든 네트워크 관련 장비를 벽 안에 밀어넣는 프로젝트이다. 벽 안에 뭘 밀어넣는다는 부분에서 에드거 앨런 포의 소설 검은 고양이에서 영감을 받아 현재 벽 색상인 흰색으로 바꿔서 이름지었다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:0:0","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"이전의 네트워크는 뭐가 불만족스러웠길래? 처음 집 안의 네트워크를 뜯어고치게 된 원인은 아래와 같다. IPTV를 사용하고 있다. (셋톱박스가 필요하다.) 셋톱박스는 유선연결만 지원한다. 공유기는 거실에 있다. (셋톱박스가 거실 TV에 붙어 있기 때문에) 내 방에서 유선으로 컴퓨터를 쓰고 싶다. 내가 인터넷 쓸 때 셋톱박스에 영향을 주지 않았으면 좋겠다. 내가 게임 다운받는다고 3Mbps 이상의 대역폭을 사용하면 IPTV 화면이 멈추고 소리만 나오는 등의 문제가 있었다. 결국 나는 다운로드 대역폭을 낮추거나, 밤에 잘 때 대역폭을 높여 써야 하는 상황이었다. 밤에 잘 때도 WiFi로 연결되어 있기 때문에 최대 대역폭도 낮은 편이었다. 이러느니 그냥 내 방에 공유기를 하나 따로 설치해서 쓰는게 낫겠다 생각해서 공유기를 사왔으나, 해당 공유기를 쓸 수 없었다. 이유는 간단하다. 각 벽에 있는 랜선 벽단자 중 거실에 있는 랜선 벽단자만 살아있기 때문이었다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:1:0","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"통신 단자함 통신 단자함은 인터넷 배선(혹은 TV 케이블도)을 선택할 수 있는 박스를 말한다. 통신 단자함 박스는 보통 집 안(전력 차단기 근처) 혹은 바깥(집 근처 복도 쪽) 벽에 매설되어있다. (건물 상황에 따라서 IDF 단자함이라 한다.) 출처: https://extrememanual.net/10935 2010년대 이후에 지어진 건물은 아마도 위와 같은 형태의 통신 단자함으로 되어 있을 것이다. (초고속정보통신건물 인증제도 덕분에 일반화 된 것으로 알고 있다.) 단자함 내부에 RJ45포트로 연결할 수 있고, 내부에 스위칭 허브를 넣을 공간과 콘센트도 있다. 한편 그 이전에 지어진 건물의 경우 위와 같은 형태의 통신 단자함을 볼 수 있을 것이다.(우리 집이 이 형태를 사용한다.) 이 단자함보다 더 이전 버전도 존재하지만, 2000년대에 인터넷 고속화 과정에서 대부분 위와 같이 변경되었을 것이다. 여기에 연결된 부분은 110 블럭이라 한다. (참고로 신형 통신 단자함 뒷편의 케이블 연결, 랜선 벽단자의 케이블 연결 부분은 키스톤 잭이라 한다.) 위 사진은 다른 상태지만, 보통 외부 인터넷선(국선)과 집 안에 있는 방 중 1곳(우리 집의 경우, 거실)과 연결하게 되어있다. 즉, 다른 방의 랜선 벽단자는 연결이 끊겨 있는 상태이기 때문에 아무리 공유기를 연결하고 설정을 변경해도 인터넷이 안 되는 것이다. 현재 통신 단자함은 구형이라서 안에 스위칭 허브를 넣을 공간도 없고, 전원도 공급받을 수 없기 때문에 랜선 벽단자는 여전히 1개만 사용 가능했다. 사실 신형 통신 단자함도 똑같이 110 블럭을 사용할 수도 있다. 통신 단자함 안에 스위칭 허브를 넣을 만큼의 공간적 여유, 콘센트 여부를 가지고 신형과 구형을 구분하면 될 것이다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:1:1","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"그 외 다른 문제들 통신 단자함에서 외부 인터넷선과 거실 랜선 벽단자 사이 연결은 4가닥으로 되어있었다. 이론 상 4선만으로도 이더넷 사용은 가능하지만, 기가급 인터넷 사용을 위해선 8가닥으로 늘려줘야 했다. 게다가 확인해보니 거실에서 연결된 공유기가 오래된 공유기라서 대역폭 관리를 잘 못하는 것이 확인되어, 이를 새로 산 신형 공유기로 교체하였다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:1:2","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"편법으로 랜선 끌어오기 통신 단자함을 통해 각 랜선 벽단자가 연결되는 방식을 알아냈으므로, 간접적으로 랜선을 끌어 올 수 있는 방법이 생겼다. 이더넷 선은 방향을 따지지 않으므로 (엄밀히 말하면 네트워크 장비와 단말 장비 간 방향을 따지긴 하나, 이를 자동으로 감지해서 변경하는 기능이 지원된다.) 가까운 방(Room2)의 랜선 벽단자를 출력 용도가 아닌 입력 용도로 사용한다. 통신 단자함에서는 Room2와 Room1을 연결해버리면 긴 랜선을 통해 최종적으로 내 방(Room1) 랜선 벽단자를 사용할 수 있다. (공유기에서 직접 연결된 회선으로) 그림에 보이는 집 구조처럼 내 방으로 직접 끌고 올 경우 바닥에 선이 걸리는데, 가까운 방으로 돌리면 최대한 벽에 붙여, 발에 걸리지 않게 할 수 있다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:1:3","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"여전히 뭔가 불만족스러운데? 이전까지의 설명은 2019년 7월쯤 완료된 상태를 설명한 것이다. 하지만 여전히 불만족스러운 점이 있었다. 랜선에 연결하고 싶은 장비들은 다 내 방에 있는데 공유기는 여전히 거실에 있다. (장비가 늘어났음) 긴 랜선이 거실의 공유기에서 출발해서 다른 방으로 타고 들어간다. (최대한 안 보이게 하긴 했지만 여전히 거슬림) 공유기 설정 바꾸거나 재시작할때 셋톱박스가 영향을 받는다. (인터넷 망에서 IPTV를 분리해버리고 싶다) 이 문제를 해결하는 방법은 다음과 같았다. 스위칭 허브를 구매하여 외부 인터넷선에서 IPTV용, 공유기용으로 분리해버린다. 기존 거실의 랜선 벽단자는 셋톱박스만 연결한다. 공유기를 내 방에 설치한다. (셋톱박스의 연결만 해결되면 공유기가 굳이 거실에 있을 필요 없음) 문제는 스위칭 허브를 설치하기에 우리집 통신 단자함은 구형 통신단자함이므로 스위칭 허브를 밖에서 연결하고도 거실 랜선 벽단자로 회선 연결을 해야 했다. 또한 이전에 회선을 추가한 것과 달리 국선을 변경하는 작업, 랜선 벽단자를 건드리기 때문에 인터넷이 안 될 수도 있다. 나는 작업을 하고 있을테니 인터넷 접속 여부가 상관없지만, 부모님은 TV도 안되고 인터넷도 안되면 집에서 할 수 있는게 많이 줄어들기 때문에, 부모님이 집을 오랫동안 비울 때를 기다렸다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:2:0","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"관로포설 관로포설은 벽 안에 선을 넣는 걸 말한다. 그러니깐 지금은 랜선 벽단자에 랜선이 1개만 연결되어 있는데, 선을 하나 더 추가하는 것이다. 2개 이상의 랜선을 꽂을 수 있는 벽단자를 찾던 중 아래와 같은 물건을 구입했다. 심지어 원하는 대로 랜선 단자와 TV케이블 단자 순서 등을 변경할 수 있는 물건이었다. 그래서 내 방의 TV케이블 벽단자를 이걸로 교체하고, 내 방에서 거실 방향으로 관로포설하면 되겠다고 생각했다. 하지만 TV케이블 벽단자를 뜯어본 뒤, 이 방법은 불가능한 것을 알게 되었다. 랜선 벽단자와 TV케이블 벽단자 내부가 이어져 있을줄 알았는데 각각 개별적인 박스로 구성되어있음. (뚫을 수 없는 두꺼운 플라스틱 재질) TV케이블 하나만 들어오는 줄 알았는데 릴레이 식으로 연결되어 있음. (TV케이블이 있을 공간이 필요함) 게다가 케이블이 통과하는 관로가 너무 좁아서 새로 추가가 불가능함. 어차피 IPTV보는데 TV케이블 뽑아버리면 되는거 아닐까 하는 생각도 잠시 들었었는데, 릴레이 식으로 연결되어 있는걸 봐선 다른 집으로도 연결되어 있을 가능성도 있을 것 같았고, 맘대로 뽑았다가 나중에 다시 복원시켜야 할 때는 답이 안 나오겠다 싶어서 결국 TV케이블쪽은 포기하고 기존 랜선 벽단자 안에 추가로 관로포설을 하기로 했다. 확인해보니 내 방으로 들어오는 랜선 벽단자 내부에서 3개 선이 들어와서, 2개는 아까 room2, 거실쪽으로 배선되고, 짧은 하나만 내 방 벽단자로 연결되는 것이었다. 내 맘대로 이쪽 벽에서 저쪽 벽으로 보낼 수 있는 게 아니라, 이미 연결된 회선에 따라 가능/불가능 여부가 결정되는 것이었다. 내부적으로 튜브같은게 존재하는데, 이 튜브는 벽단자 - 벽단자 간에 연결되어 있고, 이 튜브 안에 랜선이 포설되어 있는 것이다. 결국 내 방이 통신 단자함과 가장 가깝기 때문에, 그나마 랜선 추가가 가장 쉬운 상태였다. 기존 내 방과 통신단자함 사이에 연결된 랜선을 제거하고, 새로운 랜선 2개를 밀어넣었다. (접어서 2겹으로 밀어넣고, 반대편에서 가운데를 끊어버림으로서 2개를 넣음) ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:2:1","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"관로포설, 통신 단자함 연결 시 주의사항 통신 단자함 내 각 단자 간 연결, 관로포설 시 해당 케이블이 단선인지, 연선인지 잘 확인해야 한다. 출처: https://www.mirazon.com/network-cables-and-connectors-twisted-pair-cat5/ 대부분의 단선 케이블은 문제가 되지 않는다. 하지만 연선인 경우 문제가 되는데, 연선의 내부 두께가 얇기 때문에 110블럭/키스톤잭의 칼날이 연선의 전도체와 닿지 않을 수도 있다. 케이블이 칼날과 연결되지 않는데 단자 간 연결이나, 관로포설을 해 봤자 해당 케이블에서 전기가 흐르지 않기 때문에 단선된 상태와 똑같은 증상이 나타난다. 각 선이 단선인지 연선인지 자르지 않고 구분하는 편법은 다음과 같다. 작업용 케이블(200m 이상 단위의 박스로 파는 케이블, 보통 길이만큼 잘라서 사용)은 단선일 가능성이 높다. 편의점, 할인마트 등에서 구매할 수 있는 케이블(대부분 5m~30m)은 연선일 가능성이 높다. 연선의 경우 내부 두께가 얇은 편이므로, 케이블 피복과 내부 선 사이에 공간이 많이 남는 편이다. 해당 케이블을 접거나 굽히는 등 모양을 만든 뒤, 해당 모양이 어느 정도 잘 유지되면 단선일 가능성이 높다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:2:2","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"통신 단자함 재배치 이후 통신 단자함에 새로 추가한 랜선을 꽂을 110 블럭을 배치했다. 뽑아서 옮기는 와중에 110 블럭이 부러지는 일이 일어나긴 했다. 원래는 110블럭을 뽑거나 끼우는데 사용하는 전용 도구가 있는데, 그냥 펜치로 뽑고 끼우다가 틀어져서 부러졌다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:2:3","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"공유기 배치 공유기는 거실쪽에서도 신호가 잘 닿도록 문 방향으로 배치했다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:2:4","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"여기서 만족했으면 글 이름이 관로포설이었겠지? 그렇다. 여기서 또 뭔가 만족스럽지 않아서 Project Whitecat이 되어가는 것이다. 그 문제는 다음 글에서… ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:3:0","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["문자열 처리"],"content":"정규표현식은 특정한 규칙을 지닌 문자열의 집합에 대한 표현식이다. 정규표현식이 사용될 예시는 아래와 같다. E-mail 주소(abcd@efg.com) 형태의 문자열인지 확인하고 mailto: 처리를 하려 할 때 어떤 프로그램의 로그 파일 중 특정 이벤트나 메시지만을 필터링 하려는 경우 IDE의 도움 없이 코드에서 특정 변수만 이름을 변경하고자 하는 경우 위와 같이 주어진 문자열 속에서(대부분 긴) 내가 원하는 문자열을 패턴화 시켜 추출해내고, 교체할 수 있게 해 준다. 거의 대부분의 프로그래밍 언어는 정규표현식 기능을 제공한다. ","date":"2019-01-21","objectID":"/posts/basic-regex/:0:0","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"기초 정규표현식 본 포스트에서는 문자열 추출을 위해 필요한 가장 기초적인 기호 및 사용법에 대하여 설명한다. 좀 더 효율적으로 표현하기 위해 중요한 기술이나, 치환 등에 필요한 내용은 다음 포스트에서 다루도록 하겠다. 아래에서 설명하는 정규표현식의 표현법은 프로그래밍 언어, 환경마다 다를 수 있다. $var 는 변수를 표현하기 위함이다. 해당 문자열에 $가 포함된다는 뜻이 아니다. ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:0","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"1. 리터럴 문자 기초적인 문자(일부 특수 기호)를 표현한다. 기호 의미 예시 / 추가 설명 $text $text 문자열 그대로 추출 /LINE/ -\u003e INLINE 일치 \\t | \\v 수평 | 수직 방향 탭 을 표현함 예시 / 추가 설명 불필요 \\r 캐리지 리턴을 표현함 예시 / 추가 설명 불필요 \\n 줄넘김 (개행 문자) 을 표현함 예시 / 추가 설명 불필요 \\f 페이지 넘김을 표현함 예시 / 추가 설명 불필요 \\\\ 역슬래시 문자를 표현 예시 / 추가 설명 불필요 \\x$HX 16진수 $HX 의 값을 추출 /\\x61/ -\u003e abcab 일치 (0x61 == ‘a’) \\0$OCT 8진수 $OCT 의 값을 추출 예시 / 추가 설명 불필요 위의 표에 나와있는 항목 외에도 정규표현식에서 사용하는 특수문자들을 리터럴 값으로 표현하기 위해 \\로 escape를 사용한다. 하지만 정규표현식을 사용하는 환경에 따라 escape를 한 것을 리터럴로 취급하는지 혹은 반대인지 차이가 있을 수 있다. ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:1","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"2. 문자 클래스 1개의 문자를 추출하기 위해, 비슷한 부류의 문자들을 종류에 따라 묶어 표현한다. 기호 의미 예시 / 추가 설명 [$keys] $keys에 속하는 모든 문자 /[01234]/ -\u003e ‘0’, ‘1’, ‘2’, ‘3’, ‘4’ 일치 [$a-$b] $a에서 $b 범위에 속하는 모든 문자 /[0-4]/ == /[01234]/ [^$a] $a를 제외한 모든 문자 /[^0-9]/ -\u003e 숫자를 제외한 모든 글자 일치 . 개행 문자를 제외한 모든 문자 예시 / 추가 설명 불필요 \\w 알파벳(대+소), 숫자, _에 해당하는 모든 문자 /\\w/ == /[A-Za-z0-9_]/ \\W 알파벳(대+소), 숫자, _를 제외한 모든 문자 /\\W/ == /[^A-Za-z0-9_]/ \\d 모든 숫자(0~9) 문자 /\\d/ == /[0-9]/ \\D 모든 숫자를 제외한 모든 문자 /\\D/ == /[^0-9]/ \\s 모든 빈칸(스페이스, 탭, 줄바꿈) 문자 /\\s/ == /[ \\t\\r\\n\\v\\f]/ \\S 모든 빈칸(스페이스, 탭, 줄바꿈)을 제외한 문자 /\\S/ == /[^ \\t\\r\\n\\v\\f]/ ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:2","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"3. 수량자 수량자를 통해 패턴의 표현 횟수를 줄이거나, 유연하게 처리하게 할 수 있다. 기호 의미 예시 / 추가 설명 {$t} 앞의 표현식을 $t번 반복하는 부분을 추출 /[\\da-fA-F]{2}/ -\u003e 2자리 16진수 일치 {$t,} 앞의 표현식을 $t번 이상 반복하는 부분을 추출 /\\d{5}/ -\u003e 5자리 이상의 숫자 일치 {$s,$e} 앞의 표현식을 $s번 이상, $e번 이하 반복하는 부분을 추출 /\\d{3,5}/ -\u003e 3~5자리의 숫자 일치 ? 앞의 표현식이 0번 혹은 1번 나타나는 부분을 추출 /https?/ -\u003e http, https 일치 * 앞의 표현식이 0번 이상 나타나는 부분을 추출 /\\w*/ == \\w{0,} + 앞의 표현식이 1번 이상 나타나는 부분을 추출 /\\d+/ == \\d{1,} 수량자에는 추가적으로 게으른 문자(lazy evaluation)라는 개념이 있는데 이는 나중에 따로 다루도록 하겠다. ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:3","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"4. 그룹 조건 수량자를 표현식 단위로 적용하거나, 표현식 여러 개를 묶어 OR 연산을 할 수도 있다. 기호 의미 예시 / 추가 설명 ($exp) 표현식 $exp를 묶어 수량자 연산 등을 가능케 함 /(0x[\\da-fA-F]{2} ?)+/ -\u003e 16진법 배열 일치 ($e1|$e2) 표현식 $e1 이나 $e2 중 해당하는 부분을 추출 (OR) /(Str|string)/ -\u003e Str, string 일치 ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:4","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"5. 위치 지정 문자열 추출시 위치에 대한 조건을 둘 수 있다. 여기에서 $는 변수를 뜻하는 것이 아니라 글자 ‘$‘를 뜻하는 것이다. 여기에서 설명하는 문자열은 일반적으로 \\r 혹은 \\n으로 구분되는 문장을 뜻한다. 단어의 기준은 일반적으로 \\s (스페이스, 탭, 줄바꿈) 사이의 글자들을 말한다. 기호 의미 예시 / 추가 설명 ^ 문자열의 시작 부분 /^An/ -\u003e 문자열의 시작의 An Ancestor 에서 맨 앞의 An만 일치 $ 문자열의 끝 부분 /er$/ -\u003e 문자열의 끝의 better stronger 에서 맨 끝의 er만 일치 \\b 단어의 경계 /\\bor/ -\u003e organ, inventor 는 일치하지만 bored는 일치하지 않음 \\B 단어의 중간 /\\Bor/ -\u003e bored 는 일치하지만 organ, inventor는 일치하지 않음 ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:5","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"정규표현식 관련 사이트 언어/환경별 정규표현식 표현 비교 표 영문 위키 “Regular Expression” 정규표현식 공부할 수 있는 사이트 regexone : 설명을 보고 아래 예제를 맞추는 방식으로 진행하는 형태 regexcrossword : 가로세로 퍼즐처럼 문제풀이 (확인용) 언어/환경별 정규표현식 실험 사이트 https://regexr.com/ (Javascript, PCRE) http://regexstorm.net/tester (.NET) http://www.regexplanet.com/advanced/java/index.html (Java) 정규표현식 자동 생성 txt2re : 문자열을 입력하면 각 부분마다 표현하기 위한 정규표현식을 자동 생성해줌 ","date":"2019-01-21","objectID":"/posts/basic-regex/:2:0","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"}]