[{"categories":["개발"],"content":"GUI 기반으로 작성한 프로그램은 직관적이지만, 해당 기능을 사용하기 위해 마우스를 사용해야 하며, 이로 인해 자동화하기 어렵다는 문제점이 있다. 물론 매크로 등을 활용할 수 있지만, 사람이 직접 수행하지 않을 뿐, 결국 프로그램으로 마우스 클릭 등을 반복하는 것이다. GUI 기반으로 개발된 파일을 변환해주는 프로그램들을 CI/CD 과정에 사용하려 한다고 가정해보자. GUI를 실행하기 위한 Desktop Environment가 없는 Container/Build server일 수 있다. GUI가 있는 환경이라도, 해당 환경에 맞춰 매크로를 기록해야 한다. 매크로를 사용해도 Build server에 RDP 등으로 접속 시, 해상도 변경, 좌표 변경 등 이슈가 발생한다. 여러 GUI 기반 프로그램들을 실행할 때, 마우스 위치가 점유 자원으로서 병렬성을 방해한다. 해당 프로그램의 실행 결과도 GUI로 나타나므로, 이를 쉽게 확인할 수 없다. 위의 상황은 극단적으로 가정한 것이지만, 최소 1개 이상 실제 문제가 될 것이라 예상한다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:0:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"목표 Window Manager(Windows Explorer, Gnome 등)나 Shell(Bash, Command Prompt 등)에서 실행 시, GUI 환경으로 실행 Shell에서 실행할 때 특정 인자를 입력하면(혹은 Windows Manager의 Shortcut에 인자 추가) GUI를 띄우지 않고, 해당 인자에 따라 기능을 수행한 뒤 종료. 필요에 따라 진행 과정에 대한 Log를 출력한다. 해당 프로그램의 성공/실패 여부에 따라 확인할 수 있게 Error code를 반환하며 종료한다. 위의 목표를 개발자 기준의 요구사항으로 해석하면 아래와 같다. 기존의 GUI 실행에 관련된 코드를 뒤엎지 않고 기능을 추가해야 한다. 해당 프로그램 실행의 인자를 읽고, 특정 조건 시 GUI를 실행시키는 함수를 호출하지 않아야 한다. stdio (특히 stdout, stderr)가 해당 프로그램을 실행시킨 shell과 연결되어 있어야 한다. GUI를 실행시키지 않은 상태에서 원하는 exit code로 프로그램을 종료시켜야 한다. MFC같이 안 좋은 GUI framework에서 개발해야 한다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:1:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"진단 이제 MFC 프로그램을 작성하고, Shell에서 실행시켜보자. MFC 응용 프로그램 프로젝트를 ConsoleGuiTool로 가정하겠다. (대화 상자 기반으로 작성하였으나, 다른 종류도 크게 문제되지 않는다.) 빌드하고 Command Prompt에서 실행시켜보면 아래 스크린샷과 같은 상황을 확인할 수 있을 것이다. 분명 해당 프로그램이 종료되지 않았음에도 Shell과의 연결이 끊어졌다. 요구사항 3, 4의 상황에서 문제가 생길 수 있다. (자세한 설명은 Command Prompt 명령어 설명에서 다루도록 한다.) ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:2:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"Console 실행 모드 추가하기 일단 수정해야 할 파일은 현재 MFC 프로그램의 진입점 부분이다. CWinApp을 상속하고 있는 클래스의 소스 코드를 찾자. (특별히 이름을 변경하지 않았다면, 프로젝트 이름과 같은 *.h, *.cpp일 것이다.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // ConsoleGuiTool.h : main header file for the PROJECT_NAME application // #pragma once #ifndef __AFXWIN_H__ #error \"include 'stdafx.h' before including this file for PCH\" #endif #include \"resource.h\" // main symbols // CConsoleGuiToolApp: // See ConsoleGuiTool.cpp for the implementation of this class // class CConsoleGuiToolApp : public CWinApp { public: CConsoleGuiToolApp(); // Overrides public: virtual BOOL InitInstance(); // Implementation DECLARE_MESSAGE_MAP() }; extern CConsoleGuiToolApp theApp; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 // ConsoleGuiTool.cpp : Defines the class behaviors for the application. // #include \"stdafx.h\"#include \"ConsoleGuiTool.h\"#include \"ConsoleGuiToolDlg.h\" #ifdef _DEBUG #define new DEBUG_NEW #endif // CConsoleGuiToolApp BEGIN_MESSAGE_MAP(CConsoleGuiToolApp, CWinApp) ON_COMMAND(ID_HELP, \u0026CWinApp::OnHelp) END_MESSAGE_MAP() // CConsoleGuiToolApp construction CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, // Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() { // InitCommonControlsEx() is required on Windows XP if an application // manifest specifies use of ComCtl32.dll version 6 or later to enable // visual styles. Otherwise, any window creation will fail. INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // Set this to include all the common control classes you want to use // in your application. InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(\u0026InitCtrls); CWinApp::InitInstance(); // Create the shell manager, in case the dialog contains // any shell tree view or shell list view controls. CShellManager *pShellManager = new CShellManager; // Activate \"Windows Native\" visual manager for enabling themes in MFC controls CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // Standard initialization // If you are not using these features and wish to reduce the size // of your final executable, you should remove from the following // the specific initialization routines you do not need // Change the registry key under which our settings are stored // TODO: You should modify this string to be something appropriate // such as the name of your company or organization SetRegistryKey(_T(\"Local AppWizard-Generated Applications\")); CConsoleGuiToolDlg dlg; m_pMainWnd = \u0026dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) { // TODO: Place code here to handle when the dialog is // dismissed with OK } else if (nResponse == IDCANCEL) { // TODO: Place code here to handle when the dialog is // dismissed with Cancel } else if (nResponse == -1) { TRACE(traceAppMsg, 0, \"Warning: dialog creation failed, so application is terminating unexpectedly.\\n\"); TRACE(traceAppMsg, 0, \"Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\"); } // Delete the shell manager created above. if (pShellManager != NULL) { delete pShellManager; } // Since the dialog has been closed, return FALSE so that we exit the // application, rather than start the application's message pump. return FALSE; } 해당 class에 기존 GUI환경의 init을 담당할 InitGuiWindow()와 콘솔모드로 실행할 RunConsole() 함수를 추가한다. 이후 기존의 InitInstance()함수를 InitGuiWindow()로 교체하고, 새로운 InitInstance()를 아래와 같이 작성한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // ConsoleGuiTool.h : main header file for the PROJECT_NAME application // #pragma once #ifndef __AFXWIN_H__ #error \"include 'stdafx.h' before including this file for PCH\" #endif #include \"resource.h\" // main symbols // CConsoleGuiToolApp: // See ConsoleGuiTool.cpp for the implementation of this class // class CConsoleGuiToolApp : public CWinApp { public: CConsoleGuiToolApp(); // Overrides public: virtual BOOL InitInstance(); // Implementation DECLARE_MESSAGE_MAP() BOOL InitGuiWindow(); BOOL RunConsole(); }; extern CConsoleGuiToolApp theApp; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // ConsoleGuiTool.cpp : Defines the class behaviors for the application. // #include \"stdafx.h\"#include \"ConsoleGuiTool.h\"#include \"ConsoleGuiToolDlg.h\" #ifdef _DEBUG #define new DEBUG_NEW #endif // CConsoleGuiToolApp BEGIN_MESSAGE_MAP(CConsoleGuiToolApp, CWinApp) ON_COMMAND(ID_HELP, \u0026CWinApp::OnHelp) END_MESSAGE_MAP() // CConsoleGuiToolApp construction CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, // Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() { int nArgCnt = __argc; if (nArgCnt == 1) { return InitGuiWindow(); } else { return RunConsole(); } } BOOL CConsoleGuiToolApp::InitGuiWindow() { // InitCommonControlsEx() is required on Windows XP if an application // manifest specifies use of ComCtl32.dll version 6 or later to enable // visual styles. Otherwise, any window creation will fail. INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // Set this to include all the common control classes you want to use // in your application. InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(\u0026InitCtrls); CWinApp::InitInstance(); // Create the shell manager, in case the dialog contains // any shell tree view or shell list view controls. CShellManager *pShellManager = new CShellManager; // Activate \"Windows Native\" visual manager for enabling themes in MFC controls CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // Standard initialization // If you are not using these features and wish to reduce the size // of your final executable, you should remove from the following // the specific initialization routines you do not need // Change the registry key under which our settings are stored // TODO: You should modify this string to be something appropriate // such as the name of your company or organization SetRegistryKey(_T(\"Local AppWizard-Generated Applications\")); CConsoleGuiToolDlg dlg; m_pMainWnd = \u0026dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) { // TODO: Place code here to handle when the dialog is // dismissed with OK } else if (nResponse == IDCANCEL) { // TODO: Place code here to handle when the dialog is // dismissed with Cancel } else if (nResponse == -1) { TRACE(traceAppMsg, 0, \"Warning: dialog creation failed, so application is terminating unexpectedly.\\n\"); TRACE(traceAppMsg, 0, \"Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\"); } // Delete the shell manager created above. if (pShellManager != NULL) { delete pShellManager; } // Since the dialog has been closed, return FALSE so that we exit the // application, rather than start the application's message pump. return FALSE; } BOOL CConsoleGuiToolApp::RunConsole() { printf(\"Program is running in console mode\\n\"); Sleep(5000); printf(\"It seems program did some job, 5 second passed\\n\"); return FALSE; } 일단 콘솔 모드 진입 조건은 실행파일 뒤에 인자가 하나라도 붙는 것으로 설정했다. 콘솔 모드 진입시, 콘솔 모드로 실행된다는 메시지를 출력하고, 5초 이후 무언가 완료되었다고 하고 종료되게 설정하였다. 빌드하고 Command Prompt에서 실행시켜보면 아래 스크린샷과 같은 상황을 확인할 수 있을 것이다. 일단 실행 인자 옵션에 따라 기존 GUI 구동을 유지한 상태에서, 콘솔 모드 실행에 성공했다. 하지만 printf를 통한 메시지 출력이 되지 않는 것을 확인할 수 있다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:3:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"프로그램을 실행시킨 shell과 stdio 연결 해당 증상의 원인은 MFC 프로그램 실행 시, stdio가 기존 shell에서 떨어지기 때문이다. MFC 프로그램을 실행시킨 부모 프로세스(Command Prompt 혹은 PowerShell)의 stdio와 연결해야한다. 기존의 RunConsole() 함수를 아래와 같이 수정한다. (코드 상단에 #include \u003ciostream\u003e을 해야한다.) 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 BOOL CConsoleGuiToolApp::RunConsole() { if (AttachConsole(ATTACH_PARENT_PROCESS)) { FILE *pfStdin; FILE *pfStdout; FILE *pfStderr; freopen_s(\u0026pfStdin, \"CONIN$\", \"r\", stdin); freopen_s(\u0026pfStdout, \"CONOUT$\", \"w\", stdout); freopen_s(\u0026pfStderr, \"CONOUT$\", \"w\", stderr); std::cin.clear(); std::cout.clear(); std::cerr.clear(); } printf(\"Program is running in console mode\\n\"); Sleep(5000); printf(\"It seems program did some job, 5 second passed\\n\"); return FALSE; } L116~128의 내용은 부모 프로세스의 콘솔에 연결하고 stdin, stdout, stderr를 다시 여는 작업을 수행한다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:4:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"임의의 Exit Code로 종료시키기 원칙적으로는 main() 함수의 return값으로 exit code를 보내는 것이 정석이나, 우리가 현재 수정 가능한 코드 범위에서는 main() 함수를 수정할 수 없기 때문에 차선책인 exit() 함수를 사용하면 된다. stdin의 연결 상태를 확인할 겸, 아래와 같이 RunConsole() 함수를 수정한다. 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 BOOL CConsoleGuiToolApp::RunConsole() { int nExitCode; if (AttachConsole(ATTACH_PARENT_PROCESS)) { FILE *pfStdin; FILE *pfStdout; FILE *pfStderr; freopen_s(\u0026pfStdin, \"CONIN$\", \"r\", stdin); freopen_s(\u0026pfStdout, \"CONOUT$\", \"w\", stdout); freopen_s(\u0026pfStderr, \"CONOUT$\", \"w\", stderr); std::cin.clear(); std::cout.clear(); std::cerr.clear(); } printf(\"Program is running in console mode\\n\"); Sleep(5000); printf(\"It seems program did some job, 5 second passed\\n\"); printf(\"Enter exit code to get: \"); std::cin \u003e\u003e nExitCode; exit(nExitCode); return FALSE; } 위 목표를 모두 달성했다. 이제 실행인자를 잘 입력 받았는지 확인하고, 이를 비교하기만 하면 된다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:5:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"실행 인자 사용을 위한 추가 설명 이전의 설명은 CWinApp::InitInstance() 메서드를 수정하여 GUI를 띄우지 않고 콘솔에서 입출력을 수행하는 부분을 설명했다. 실행 인자를 입력받는 방법은 __argc, __argv, __wargv 전역변수를 활용한다. 해당 변수는 stdlib.h에서 제공하며, Microsoft에서만 제공하는 확장 기능이다. (C,C++ 표준이 아님) (Multi-Byte Character Set으로 빌드한 경우 __argv를, Unicode Character Set으로 빌드한 경우 __wargv를 사용) 이외에도 GetCommandLine(), CWinApp::ParseCommandLine() 등의 방법으로도 실행 인자를 얻을 수 있다. 이 중 ParseCommandLine()에서 사용하는 CCommandLineInfo는 Windows에서 제공하는 기능의 일부를 해석해준다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:6:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"Command Prompt 명령어 설명 사실 Windows에서 제공하는 Command Prompt, PowerShell에서 GUI를 사용하는 프로그램을 실행시키면 자동으로 해당 shell에서 detach하게 되어있다. 현재 수정한 방식은 GUI를 화면에 출력하기 전에 기능을 수행하고 종료시킨 것이므로, 똑같이 shell에서 detach하게 되어있다. Command Prompt에서 콘솔 모드 사용을 위해서는 아래와 같은 옵션을 고려해야 한다. start /wait \u003cPROGRAM\u003e \u003cPROGRAM\u003e을 실행시키고, 해당 \u003cPROGRAM\u003e이 종료될 때 까지 기다린다. cmd /v:on /c “echo !time! … Batch file을 실행할 때, 환경변수 등은 %VAR%를 통해 그 값으로 치환할 수 있다. 하지만 위 예시와 같이 프로그램의 실행 시간을 측정하기 위해 한 명령행 안에 %VAR%로 넣을 경우, 즉시 치환된다. (!time! 대신 %time%로 입력 시, 실제 소요시간과 관계없이 같은 시간이 나타난다.) 해당 변수에 접근하는 순간 치환되길 원한다면, 위와 같이 !VAR!로 표기해야 한다. 또한 위와 같은 delayed environment variable expansion을 사용하려면 현재 콘솔에 옵션을 설정하거나 cmd로 실행시킬 때, /v:on 옵션을 주고 실행시켜야 한다. ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:7:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"해설 C/C++로 작성한 프로그램의 기본 진입점은 main()함수이다. main()함수의 매개변수로 int argc, char** argv를 사용하여 실행 인자를 프로그램 내에서 확인할 수 있다. 하지만 MFC로 프로젝트를 생성할 경우, main()함수를 개발자가 직접 편집할 수 없다. 이전의 코드에서 봤던 것 처럼 개발자가 수정 가능한 프로그램의 최초 진입 지점은 CWinApp::InitInstance() 메서드이다. main()함수 역할을 수행하는 WinAPI에서 제공하는 진입점은 _tWinMain() 함수이다. MFC에서 작성된 _tWinMain()함수의 정의는 VC\\atlmfc\\src\\mfc\\appmodul.cpp에서 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // This is a part of the Microsoft Foundation Classes C++ library. // Copyright (C) Microsoft Corporation // All rights reserved. // // This source code is only intended as a supplement to the // Microsoft Foundation Classes Reference and related // electronic documentation provided with the library. // See these sources for detailed information regarding the // Microsoft Foundation Classes product. #include \"stdafx.h\"#include \"sal.h\" ///////////////////////////////////////////////////////////////////////////// // export WinMain to force linkage to this module extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow); extern \"C\" int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow) #pragma warning(suppress: 4985) { // call shared/exported WinMain return AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow); } ///////////////////////////////////////////////////////////////////////////// // initialize app state such that it points to this module's core state BOOL AFXAPI AfxInitialize(BOOL bDLL, DWORD dwVersion) { AFX_MODULE_STATE* pModuleState = AfxGetModuleState(); pModuleState-\u003em_bDLL = (BYTE)bDLL; ASSERT(dwVersion \u003c= _MFC_VER); UNUSED(dwVersion); // not used in release build #ifdef _AFXDLL pModuleState-\u003em_dwVersion = dwVersion; #endif : _tWinMain()에서 호출하는 AfxWinMain()의 정의는 VC\\atlmfc\\src\\mfc\\winmain.cpp에서 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // This is a part of the Microsoft Foundation Classes C++ library. // Copyright (C) Microsoft Corporation // All rights reserved. // // This source code is only intended as a supplement to the // Microsoft Foundation Classes Reference and related // electronic documentation provided with the library. // See these sources for detailed information regarding the // Microsoft Foundation Classes product. #include \"stdafx.h\"#include \"sal.h\" ///////////////////////////////////////////////////////////////////////////// // Standard WinMain implementation // Can be replaced as long as 'AfxWinInit' is called first int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow) { ASSERT(hPrevInstance == NULL); int nReturnCode = -1; CWinThread* pThread = AfxGetThread(); CWinApp* pApp = AfxGetApp(); // AFX internal initialization if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow)) goto InitFailure; // App global initializations (rare) if (pApp != NULL \u0026\u0026 !pApp-\u003eInitApplication()) goto InitFailure; // Perform specific initializations if (!pThread-\u003eInitInstance()) { if (pThread-\u003em_pMainWnd != NULL) { TRACE(traceAppMsg, 0, \"Warning: Destroying non-NULL m_pMainWnd\\n\"); pThread-\u003em_pMainWnd-\u003eDestroyWindow(); } nReturnCode = pThread-\u003eExitInstance(); goto InitFailure; } nReturnCode = pThread-\u003eRun(); InitFailure: #ifdef _DEBUG // Check for missing AfxLockTempMap calls if (AfxGetModuleThreadState()-\u003em_nTempMapLock != 0) { TRACE(traceAppMsg, 0, \"Warning: Temp map lock count non-zero (%ld).\\n\", AfxGetModuleThreadState()-\u003em_nTempMapLock); } AfxLockTempMaps(); AfxUnlockTempMaps(-1); #endif AfxWinTerm(); return nReturnCode; } ///////////////////////////////////////////////////////////////////////////// AfxGetApp()를 통해 개발자가 정의한 Application 변수의 주소를 얻고, 해당 변수에서 InitInstance() 메서드를 호출한다. 해당 함수는 개발자가 재정의할 수 있으며, 우리는 이 InitInstance()함수를 수정하여 MFC dialog를 띄우지 않고 콘솔에서 처리할 수 있도록 변형한 것이다. 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 : // CConsoleGuiToolApp construction CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, // Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() : ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:8:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"다른 GUI framework에서의 진입점 (main 함수) 아래는 각 C/C++로 작성된 GUI framework의 진입점이다. 대부분의 GUI framework는 main() 함수를 편집할 수 있다. WxWidget은 MFC와 같이 main() 함수를 편집할 수 없으므로, wxApp이 제공하는 메서드를 사용해야 한다. QT #include \u003cQApplication\u003e#include \u003cQCommandLineParser\u003e#include \u003cQCommandLineOption\u003e #include \"mainwindow.h\" int main(int argc, char *argv[]) { Q_INIT_RESOURCE(application); QApplication app(argc, argv); QCoreApplication::setOrganizationName(\"QtProject\"); QCoreApplication::setApplicationName(\"Application Example\"); QCoreApplication::setApplicationVersion(QT_VERSION_STR); QCommandLineParser parser; parser.setApplicationDescription(QCoreApplication::applicationName()); parser.addHelpOption(); parser.addVersionOption(); parser.addPositionalArgument(\"file\", \"The file to open.\"); parser.process(app); MainWindow mainWin; if (!parser.positionalArguments().isEmpty()) mainWin.loadFile(parser.positionalArguments().first()); mainWin.show(); return app.exec(); } GTK+ #include \u003cgtk/gtk.h\u003e #include \"gtk_app.h\" int main (int argc, char **argv) { GtkApplication *app; int status; app = gtk_application_new (\"org.gtk.example\", G_APPLICATION_FLAGS_NONE); g_signal_connect (app, \"activate\", G_CALLBACK (activate), NULL); status = g_application_run (G_APPLICATION (app), argc, argv); g_object_unref (app); return status; } FLTK #include \u003cFL/Fl.H\u003e#include \u003cFL/Fl_Window.H\u003e#include \u003cFL/Fl_Button.H\u003e int main(int argc, char *argv[]) { Fl_Window* w = new Fl_Window(330, 190); new Fl_Button(110, 130, 100, 35, \"Okay\"); w-\u003eend(); w-\u003eshow(argc, argv); return Fl::run(); } ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:8:1","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["개발"],"content":"참고 링크 [1] MFC 기본코드 분석(https://petra.tistory.com/1296) ","date":"2020-09-14","objectID":"/posts/mfc-console-mode/:9:0","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"/posts/mfc-console-mode/"},{"categories":["Project Whitecat"],"content":"Project Whitecat은 우리 집 안에 있는 모든 네트워크 관련 장비를 벽 안에 밀어넣는 프로젝트이다. 벽 안에 뭘 밀어넣는다는 부분에서 에드거 앨런 포의 소설 검은 고양이에서 영감을 받아 현재 벽 색상인 흰색으로 바꿔서 이름지었다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:0:0","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"이전의 네트워크는 뭐가 불만족스러웠길래? 처음 집 안의 네트워크를 뜯어고치게 된 원인은 아래와 같다. IPTV를 사용하고 있다. (셋톱박스가 필요하다.) 셋톱박스는 유선연결만 지원한다. 공유기는 거실에 있다. (셋톱박스가 거실 TV에 붙어 있기 때문에) 내 방에서 유선으로 컴퓨터를 쓰고 싶다. 내가 인터넷 쓸 때 셋톱박스에 영향을 주지 않았으면 좋겠다. 내가 게임 다운받는다고 3Mbps 이상의 대역폭을 사용하면 IPTV 화면이 멈추고 소리만 나오는 등의 문제가 있었다. 결국 나는 다운로드 대역폭을 낮추거나, 밤에 잘 때 대역폭을 높여 써야 하는 상황이었다. 밤에 잘 때도 WiFi로 연결되어 있기 때문에 최대 대역폭도 낮은 편이었다. 이러느니 그냥 내 방에 공유기를 하나 따로 설치해서 쓰는게 낫겠다 생각해서 공유기를 사왔으나, 해당 공유기를 쓸 수 없었다. 이유는 간단하다. 각 벽에 있는 랜선 벽단자 중 거실에 있는 랜선 벽단자만 살아있기 때문이었다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:1:0","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"통신 단자함 통신 단자함은 인터넷 배선(혹은 TV 케이블도)을 선택할 수 있는 박스를 말한다. 통신 단자함 박스는 보통 집 안(전력 차단기 근처) 혹은 바깥(집 근처 복도 쪽) 벽에 매설되어있다. (건물 상황에 따라서 IDF 단자함이라 한다.) 출처: https://extrememanual.net/10935 2010년대 이후에 지어진 건물은 아마도 위와 같은 형태의 통신 단자함으로 되어 있을 것이다. (초고속정보통신건물 인증제도 덕분에 일반화 된 것으로 알고 있다.) 단자함 내부에 RJ45포트로 연결할 수 있고, 내부에 스위칭 허브를 넣을 공간과 콘센트도 있다. 한편 그 이전에 지어진 건물의 경우 위와 같은 형태의 통신 단자함을 볼 수 있을 것이다.(우리 집이 이 형태를 사용한다.) 이 단자함보다 더 이전 버전도 존재하지만, 2000년대에 인터넷 고속화 과정에서 대부분 위와 같이 변경되었을 것이다. 여기에 연결된 부분은 110 블럭이라 한다. 위 사진은 다른 상태지만, 보통 외부 인터넷선(국선)과 집 안에 있는 방 중 1곳(우리 집의 경우, 거실)과 연결하게 되어있다. 즉, 다른 방의 랜선 벽단자는 연결이 끊겨 있는 상태이기 때문에 아무리 공유기를 연결하고 설정을 변경해도 인터넷이 안 되는 것이다. 현재 통신 단자함은 구형이라서 안에 스위칭 허브를 넣을 공간도 없고, 전원도 공급받을 수 없기 때문에 랜선 벽단자는 여전히 1개만 사용 가능했다. 사실 신형 통신 단자함도 똑같이 110 블럭을 사용할 수도 있다. 통신 단자함 안에 스위칭 허브를 넣을 만큼의 공간적 여유, 콘센트 여부를 가지고 신형과 구형을 구분하면 될 것이다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:1:1","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"그 외 다른 문제들 통신 단자함에서 외부 인터넷선과 거실 랜선 벽단자 사이 연결은 4가닥으로 되어있었다. 이론 상 4선만으로도 이더넷 사용은 가능하지만, 기가급 인터넷 사용을 위해선 8가닥으로 늘려줘야 했다. 게다가 확인해보니 거실에서 연결된 공유기가 오래된 공유기라서 대역폭 관리를 잘 못하는 것이 확인되어, 이를 새로 산 신형 공유기로 교체하였다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:1:2","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"편법으로 랜선 끌어오기 통신 단자함을 통해 각 랜선 벽단자가 연결되는 방식을 알아냈으므로, 간접적으로 랜선을 끌어 올 수 있는 방법이 생겼다. 이더넷 선은 방향을 따지지 않으므로 (엄밀히 말하면 네트워크 장비와 단말 장비 간 방향을 따지긴 하나, 이를 자동으로 감지해서 변경하는 기능이 지원된다.) 가까운 방(Room2)의 랜선 벽단자를 출력 용도가 아닌 입력 용도로 사용한다. 통신 단자함에서는 Room2와 Room1을 연결해버리면 긴 랜선을 통해 최종적으로 내 방(Room1) 랜선 벽단자를 사용할 수 있다. (공유기에서 직접 연결된 회선으로) 그림에 보이는 집 구조처럼 내 방으로 직접 끌고 올 경우 바닥에 선이 걸리는데, 가까운 방으로 돌리면 최대한 벽에 붙여, 발에 걸리지 않게 할 수 있다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:1:3","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"여전히 뭔가 불만족스러운데? 이전까지의 설명은 2019년 7월쯤 완료된 상태를 설명한 것이다. 하지만 여전히 불만족스러운 점이 있었다. 랜선에 연결하고 싶은 장비들은 다 내 방에 있는데 공유기는 여전히 거실에 있다. (장비가 늘어났음) 긴 랜선이 거실의 공유기에서 출발해서 다른 방으로 타고 들어간다. (최대한 안 보이게 하긴 했지만 여전히 거슬림) 공유기 설정 바꾸거나 재시작할때 셋톱박스가 영향을 받는다. (인터넷 망에서 IPTV를 분리해버리고 싶다) 이 문제를 해결하는 방법은 다음과 같았다. 스위칭 허브를 구매하여 외부 인터넷선에서 IPTV용, 공유기용으로 분리해버린다. 기존 거실의 랜선 벽단자는 셋톱박스만 연결한다. 공유기를 내 방에 설치한다. (셋톱박스의 연결만 해결되면 공유기가 굳이 거실에 있을 필요 없음) 문제는 스위칭 허브를 설치하기에 우리집 통신 단자함은 구형 통신단자함이므로 스위칭 허브를 밖에서 연결하고도 거실 랜선 벽단자로 회선 연결을 해야 했다. 또한 이전에 회선을 추가한 것과 달리 국선을 변경하는 작업, 랜선 벽단자를 건드리기 때문에 인터넷이 안 될 수도 있다. 나는 작업을 하고 있을테니 인터넷 접속 여부가 상관없지만, 부모님은 TV도 안되고 인터넷도 안되면 집에서 할 수 있는게 많이 줄어들기 때문에, 부모님이 집을 오랫동안 비울 때를 기다렸다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:2:0","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"관로포설 관로포설은 벽 안에 선을 넣는 걸 말한다. 그러니깐 지금은 랜선 벽단자에 랜선이 1개만 연결되어 있는데, 선을 하나 더 추가하는 것이다. 2개 이상의 랜선을 꽂을 수 있는 벽단자를 찾던 중 아래와 같은 물건을 구입했다. 심지어 원하는 대로 랜선 단자와 TV케이블 단자 순서 등을 변경할 수 있는 물건이었다. 그래서 내 방의 TV케이블 벽단자를 이걸로 교체하고, 내 방에서 거실 방향으로 관로포설하면 되겠다고 생각했다. 하지만 TV케이블 벽단자를 뜯어본 뒤, 이 방법은 불가능한 것을 알게 되었다. 랜선 벽단자와 TV케이블 벽단자 내부가 이어져 있을줄 알았는데 각각 개별적인 박스로 구성되어있음. (뚫을 수 없는 두꺼운 플라스틱 재질) TV케이블 하나만 들어오는 줄 알았는데 릴레이 식으로 연결되어 있음. (TV케이블이 있을 공간이 필요함) 게다가 케이블이 통과하는 관로가 너무 좁아서 새로 추가가 불가능함. 어차피 IPTV보는데 TV케이블 뽑아버리면 되는거 아닐까 하는 생각도 잠시 들었었는데, 릴레이 식으로 연결되어 있는걸 봐선 다른 집으로도 연결되어 있을 가능성도 있을 것 같았고, 맘대로 뽑았다가 나중에 다시 복원시켜야 할 때는 답이 안 나오겠다 싶어서 결국 TV케이블쪽은 포기하고 기존 랜선 벽단자 안에 추가로 관로포설을 하기로 했다. 확인해보니 내 방으로 들어오는 랜선 벽단자 내부에서 3개 선이 들어와서, 2개는 아까 room2, 거실쪽으로 배선되고, 짧은 하나만 내 방 벽단자로 연결되는 것이었다. 내 맘대로 이쪽 벽에서 저쪽 벽으로 보낼 수 있는 게 아니라, 이미 연결된 회선에 따라 가능/불가능 여부가 결정되는 것이었다. 내부적으로 튜브같은게 존재하는데, 이 튜브는 벽단자 - 벽단자 간에 연결되어 있고, 이 튜브 안에 랜선이 포설되어 있는 것이다. 결국 내 방이 통신 단자함과 가장 가깝기 때문에, 그나마 랜선 추가가 가장 쉬운 상태였다. 기존 내 방과 통신단자함 사이에 연결된 랜선을 제거하고, 새로운 랜선 2개를 밀어넣었다. (접어서 2겹으로 밀어넣고, 반대편에서 가운데를 끊어버림으로서 2개를 넣음) ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:2:1","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"통신 단자함 재배치 이후 통신 단자함에 새로 추가한 랜선을 꽂을 110 블럭을 배치했다. 뽑아서 옮기는 와중에 110 블럭이 부러지는 일이 일어나긴 했다. 원래는 110블럭을 뽑거나 끼우는데 사용하는 전용 도구가 있는데, 그냥 펜치로 뽑고 끼우다가 틀어져서 부러졌다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:2:2","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"공유기 배치 공유기는 거실쪽에서도 신호가 잘 닿도록 문 방향으로 배치했다. ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:2:3","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["Project Whitecat"],"content":"여기서 만족했으면 글 이름이 관로포설이었겠지? 그렇다. 여기서 또 뭔가 만족스럽지 않아서 Project Whitecat이 되어가는 것이다. 그 문제는 다음 글에서… ","date":"2020-08-31","objectID":"/posts/project-whitecat/chap0-changing-home-network/:3:0","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"/posts/project-whitecat/chap0-changing-home-network/"},{"categories":["문자열 처리"],"content":"정규표현식은 특정한 규칙을 지닌 문자열의 집합에 대한 표현식이다. 정규표현식이 사용될 예시는 아래와 같다. E-mail 주소(abcd@efg.com) 형태의 문자열인지 확인하고 mailto: 처리를 하려 할 때 어떤 프로그램의 로그 파일 중 특정 이벤트나 메시지만을 필터링 하려는 경우 IDE의 도움 없이 코드에서 특정 변수만 이름을 변경하고자 하는 경우 위와 같이 주어진 문자열 속에서(대부분 긴) 내가 원하는 문자열을 패턴화 시켜 추출해내고, 교체할 수 있게 해 준다. 거의 대부분의 프로그래밍 언어는 정규표현식 기능을 제공한다. ","date":"2019-01-21","objectID":"/posts/basic-regex/:0:0","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"기초 정규표현식 본 포스트에서는 문자열 추출을 위해 필요한 가장 기초적인 기호 및 사용법에 대하여 설명한다. 좀 더 효율적으로 표현하기 위해 중요한 기술이나, 치환 등에 필요한 내용은 다음 포스트에서 다루도록 하겠다. 아래에서 설명하는 정규표현식의 표현법은 프로그래밍 언어, 환경마다 다를 수 있다. $var 는 변수를 표현하기 위함이다. 해당 문자열에 $가 포함된다는 뜻이 아니다. ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:0","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"1. 리터럴 문자 기초적인 문자(일부 특수 기호)를 표현한다. 기호 의미 예시 / 추가 설명 $text $text 문자열 그대로 추출 /LINE/ -\u003e INLINE 일치 \\t | \\v 수평 | 수직 방향 탭 을 표현함 예시 / 추가 설명 불필요 \\r 캐리지 리턴을 표현함 예시 / 추가 설명 불필요 \\n 줄넘김 (개행 문자) 을 표현함 예시 / 추가 설명 불필요 \\f 페이지 넘김을 표현함 예시 / 추가 설명 불필요 \\\\ 역슬래시 문자를 표현 예시 / 추가 설명 불필요 \\x$HX 16진수 $HX 의 값을 추출 /\\x61/ -\u003e abcab 일치 (0x61 == ‘a’) \\0$OCT 8진수 $OCT 의 값을 추출 예시 / 추가 설명 불필요 위의 표에 나와있는 항목 외에도 정규표현식에서 사용하는 특수문자들을 리터럴 값으로 표현하기 위해 \\로 escape를 사용한다. 하지만 정규표현식을 사용하는 환경에 따라 escape를 한 것을 리터럴로 취급하는지 혹은 반대인지 차이가 있을 수 있다. ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:1","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"2. 문자 클래스 1개의 문자를 추출하기 위해, 비슷한 부류의 문자들을 종류에 따라 묶어 표현한다. 기호 의미 예시 / 추가 설명 [$keys] $keys에 속하는 모든 문자 /[01234]/ -\u003e ‘0’, ‘1’, ‘2’, ‘3’, ‘4’ 일치 [$a-$b] $a에서 $b 범위에 속하는 모든 문자 /[0-4]/ == /[01234]/ [^$a] $a를 제외한 모든 문자 /[^0-9]/ -\u003e 숫자를 제외한 모든 글자 일치 . 개행 문자를 제외한 모든 문자 예시 / 추가 설명 불필요 \\w 알파벳(대+소), 숫자, _에 해당하는 모든 문자 /\\w/ == /[A-Za-z0-9_]/ \\W 알파벳(대+소), 숫자, _를 제외한 모든 문자 /\\W/ == /[^A-Za-z0-9_]/ \\d 모든 숫자(0~9) 문자 /\\d/ == /[0-9]/ \\D 모든 숫자를 제외한 모든 문자 /\\D/ == /[^0-9]/ \\s 모든 빈칸(스페이스, 탭, 줄바꿈) 문자 /\\s/ == /[ \\t\\r\\n\\v\\f]/ \\S 모든 빈칸(스페이스, 탭, 줄바꿈)을 제외한 문자 /\\S/ == /[^ \\t\\r\\n\\v\\f]/ ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:2","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"3. 수량자 수량자를 통해 패턴의 표현 횟수를 줄이거나, 유연하게 처리하게 할 수 있다. 기호 의미 예시 / 추가 설명 {$t} 앞의 표현식을 $t번 반복하는 부분을 추출 /[\\da-fA-F]{2}/ -\u003e 2자리 16진수 일치 {$t,} 앞의 표현식을 $t번 이상 반복하는 부분을 추출 /\\d{5}/ -\u003e 5자리 이상의 숫자 일치 {$s,$e} 앞의 표현식을 $s번 이상, $e번 이하 반복하는 부분을 추출 /\\d{3,5}/ -\u003e 3~5자리의 숫자 일치 ? 앞의 표현식이 0번 혹은 1번 나타나는 부분을 추출 /https?/ -\u003e http, https 일치 * 앞의 표현식이 0번 이상 나타나는 부분을 추출 /\\w*/ == \\w{0,} + 앞의 표현식이 1번 이상 나타나는 부분을 추출 /\\d+/ == \\d{1,} 수량자에는 추가적으로 게으른 문자(lazy evaluation)라는 개념이 있는데 이는 나중에 따로 다루도록 하겠다. ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:3","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"4. 그룹 조건 수량자를 표현식 단위로 적용하거나, 표현식 여러 개를 묶어 OR 연산을 할 수도 있다. 기호 의미 예시 / 추가 설명 ($exp) 표현식 $exp를 묶어 수량자 연산 등을 가능케 함 /(0x[\\da-fA-F]{2} ?)+/ -\u003e 16진법 배열 일치 ($e1|$e2) 표현식 $e1 이나 $e2 중 해당하는 부분을 추출 (OR) /(Str|string)/ -\u003e Str, string 일치 ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:4","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"5. 위치 지정 문자열 추출시 위치에 대한 조건을 둘 수 있다. 여기에서 $는 변수를 뜻하는 것이 아니라 글자 ‘$‘를 뜻하는 것이다. 여기에서 설명하는 문자열은 일반적으로 \\r 혹은 \\n으로 구분되는 문장을 뜻한다. 단어의 기준은 일반적으로 \\s (스페이스, 탭, 줄바꿈) 사이의 글자들을 말한다. 기호 의미 예시 / 추가 설명 ^ 문자열의 시작 부분 /^An/ -\u003e 문자열의 시작의 An Ancestor 에서 맨 앞의 An만 일치 $ 문자열의 끝 부분 /er$/ -\u003e 문자열의 끝의 better stronger 에서 맨 끝의 er만 일치 \\b 단어의 경계 /\\bor/ -\u003e organ, inventor 는 일치하지만 bored는 일치하지 않음 \\B 단어의 중간 /\\Bor/ -\u003e bored 는 일치하지만 organ, inventor는 일치하지 않음 ","date":"2019-01-21","objectID":"/posts/basic-regex/:1:5","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"},{"categories":["문자열 처리"],"content":"정규표현식 관련 사이트 언어/환경별 정규표현식 표현 비교 표 영문 위키 “Regular Expression” 정규표현식 공부할 수 있는 사이트 regexone : 설명을 보고 아래 예제를 맞추는 방식으로 진행하는 형태 regexcrossword : 가로세로 퍼즐처럼 문제풀이 (확인용) 언어/환경별 정규표현식 실험 사이트 https://regexr.com/ (Javascript, PCRE) http://regexstorm.net/tester (.NET) http://www.regexplanet.com/advanced/java/index.html (Java) 정규표현식 자동 생성 txt2re : 문자열을 입력하면 각 부분마다 표현하기 위한 정규표현식을 자동 생성해줌 ","date":"2019-01-21","objectID":"/posts/basic-regex/:2:0","tags":["정규표현식"],"title":"정규표현식 기초","uri":"/posts/basic-regex/"}]