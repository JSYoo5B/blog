[{"content":"Operating System Concepts 책(이하 공룡책)을 깊이있게 완독하는 스터디를 진행하고 있는데, 이 중 9장 메인 메모리의 계층적 페이징에서 단계적으로 일어나는 계산에 대해 질문이 있었다. 나는 페이지의 비트에 -2 혹은 -3 하는 것이 매우 당연하다 생각했었는데, 막상 설명하려니 단계적으로 정확히 설명할 수 없었다. 이 부분을 좀 더 명확하게 설명할 필요가 있어 글을 작성하기로 했다.\n문제 정의 계층적 페이징을 적용하지 않았을 때는 페이지의 오프셋을 제외한 모든 상위 비트가 페이지 테이블을 표현하는데 사용되어야 한다. 하지만 이를 계층적으로 나눌 수 있는데, 어떤 이유로 각 계층별 비트 수가 결정되는지 알아보자.\n본 글에서는 실제 자주 사용되는 페이징 구조를 기준으로 한다. 먼저 32-bits 환경에서의 계산을 먼저 하고, 숫자 차이인 64-bits 환경에도 적용하면서 일반화 해 보도록 하겠다. 참고로 현재 64-bits 환경의 경우 그림에도 설명했듯 주소 공간을 모두 활용하지 않는다.\n사전 지식 참고로 이 설명에서는 요구 페이징(Demand Paging) 개념을 기반으로 계층적 페이징의 필요성을 설득하고 있으므로, 해당 개념에 대해 먼저 간단하게 설명하겠다. (공룡책의 경우 9장이 아닌 10장에서 상세히 설명하므로 순서대로 읽다 보면 아직 요구 페이징을 잘 모를 수도 있다 가정한다.)\n요구 페이징 책에서는 메모리의 외부 단편화 등의 문제를 해결하기 위한 방법으로 메모리를 일정한 크기로 구분하여 관리하는 페이징 개념을 제안했다. 또한 가상 주소 개념을 적용함으로서 다른 프로세스의 주소 영역 침범 문제 등을 해결하고자 했다.\n이에 따라 각 프로세스는 모두 개별적인 주소 공간을 갖게 되었고, 굳이 프로그램의 크기에 따라 주소 공간의 크기를 가변적으로 할당할 필요도 없게 되었다. 여기에서 더 생각해보면, 각 프로세스는 자신에게 할당받은 주소 공간을 완전히 활용하지 못 할 가능성이 높다. 대표적으로 메모리 영역에서 스택과 힙 영역은 런타임에 크기가 변한다.\n즉, 한 프로세스에게 4GB의 주소 공간을 할당해도 실행 상황에 따라 100MB 이하로 쓸 수도 있고, 3GB를 쓸 수도 있다는 것이다. 이런 점을 고려했을 때, 각 프로세스에게 주소 공간만큼 물리 메모리를 할당할 필요가 없다는 것을 알 수 있다. 게다가 실제 사용해보면 대부분이 주소공간을 완전 활용하지 않는다는 것도 알게되었다.\n이 외에도 여러 이유가 존재할 수 있으나, 요구 페이징을 설명하는 글이 아니므로 생략하도록 하겠다.\n32-bits, 4KiB paging 페이징 개념 자체를 학습하느라 놓쳤을 지 모르겠지만, 페이지 테이블은 일종의 메타데이터다. 그리고 이 메타데이터는 다른 어딘가에 보관되어야 사용할 수 있다. (당연히 메모리 관리를 담당하는 커널에서 보관한다.) 여기에 추가적으로 각 페이지 프레임의 속성을 나타내기 위해 개별적으로 메타데이터를 사용하지 않고, 페이징으로 인해 정렬된 하위 비트들을 활용한다. (실제 사용 시, 이 하위 비트들을 비트 연산자로 제거하고 사용한다.)\n그림에도 나와있듯, 4KiB 페이징의 경우, 상위 20 비트로 각 페이지 프레임을 나타내고 있으며, 한 페이지 프레임을 표현하기 위해 4바이트(32비트)가 필요하므로, 페이지 테이블의 예상 크기는 4MiB다. 당연히 이 페이지 테이블도 페이지 프레임 단위로 보관될 것이다. 현재 페이지 테이블 크기를 각 페이지 프레임 크기로 나눠보면, 페이지 테이블 표현에만 1024개가 필요함을 알 수 있다. 현재 가정하는 상황에서 페이지 프레임을 4개 사용하는 것에 비해 메타데이터의 크기가 과도하게 크다.\n게다가 또 다른 문제가 있다. 페이지 테이블에서는 원하는 주소를 바로 찾기 위해 주소 값들을 저장하고 있는데(이렇게 페이지 프레임을 가리키는 주소를 페이지 테이블 엔트리라 한다.) 이 페이지 테이블을 실제 표현하는 페이지 프레임들은 연속적으로 할당되어야 한다. 1단계 페이징을 적용했을 때, 가상 주소로부터 물리 주소를 구하는 과정을 코드로 표현하면 아래와 같다. (실제 코드는 아니지만 대략 아래와 같은 형식으로 작성된다.)\n가상 주소를 물리 주소로 변환하는 과정  #define ADDR_BITS 32 // 32-bits address space #define PAGE_SHIFT 12 // 4KiB page frame  #define SIZE_ADDR_SPACE (1 \u0026lt;\u0026lt; ADDR_BITS) // address space #define SIZE_PF (1 \u0026lt;\u0026lt; PAGE_SHIFT) // page frame size #define P_ATTR_MASK ((1 \u0026lt;\u0026lt; PAGE_SHIFT) - 1) // page attribute mask  // page entries must be placed in page frame (resource allocation view) struct { void* entry[SIZE_PF / sizeof(void*)]; } pt_frames[SIZE_ADDR_SPACE / SIZE_PF]; // Pointer for page table (abstracted page table view) void* page_tbl = \u0026amp;pt_frames[0].entry[0]; void* get_page_frame_addr(void *virt_addr) { // get index by upper bits of page  int idx = virt_addr \u0026gt;\u0026gt; PAGE_SHIFT; // entry of physical address is page_tbl[idx]  void* phy_entry = page_tbl[idx]; // Unmask page entry\u0026#39;s attribute  return (void*)((int)phy_entry \u0026amp; ~P_ATTR_MASK); } void* get_physical_addr(void* virt_addr) { // get offset address of page  void* offset = (void*)((int)virt_addr \u0026amp; P_ATTR_MASK); // get physical page frame address  void* phy_frame = get_page_frame_addr(virt_addr); return (void*)((int)phy_frame | (int)offset); }     'use strict'; var containerId = JSON.parse(\"\\\"29f7b72fac7db34e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위 코드에서 보듯, 가상주소에서 물리주소로 변환하는(get_physical_addr()), 가상주소를 통해 물리 페이지 프레임의 주소를 얻는(get_page_frame_addr()) 과정은 오프셋 주소 상위 비트를(virt_addr \u0026gt;\u0026gt; PAGE_SHIFT) 배열의 인덱스처럼 사용하여(page_tbl[idx]) 접근한다. 이 페이지 테이블은 모든 프레임이 연속해야만 (pt_frames[]) 정확한 위치에 인덱싱 할 수 있다.\n위에서 설명한 내용을 요약하자면 1단계 페이지 테이블을 그대로 적용한다면 아래와 같은 문제가 있다.\n 페이지 테이블은 실제 물리 주소 공간에 연속적으로 할당되어야 한다. 요구 페이징 시, 실제 사용하는 페이지 프레임에 비해 페이지 테이블의 용량이 너무 크다.  페이지 테이블 용량에 대한 문제는 앞의 산수에서 확인되었지만, 페이지 테이블의 공간 연속 할당 문제로 인해 의미 없는 페이지 엔트리들도 표현해야 한다는 점에서 당위성이 생긴다.\n그렇다면 현재 1단계 페이징을 할 때, 페이지 테이블의 각 프레임의 속성을 확인해보자. 각 엔트리들이 가리키는 가상 주소들은 연속적이므로, 이를 비트 표현 상의 차이로 확인해보면 상위 10 비트는 언제나 동일한 것을 알 수 있다. 한 페이지에 저장 가능한 엔트리의 개수는 1024개이므로 (4KiB / 4B) 가상 주소 엔트리의 하위 10 비트만 바뀌는 것을 알 수 있다. 이 점을 착안하여, 2단계 페이징을 적용하게 된다.\n위 그림과 같이, 상위 10비트의 차이를 나타내는 새로운 페이지 테이블을 생성했다. 이 새로운 페이지 테이블은 가상 주소의 상위 10 비트의 주소에 대한 계산만 하고있다. 이렇게 2단계 페이징을 적용함으로서 아까 있던 문제를 어떻게 해결할 수 있는지 알아보자.\n 페이지 테이블은 실제 물리 주소 공간에 연속적으로 할당되어야 한다.\n페이지 테이블이 할당된 페이지 프레임을 가리키는 새로운 테이블이 생겼다.\n엔트리 계산이 두번 이뤄진다. (최상위 -\u0026gt; 하위 테이블 페이지 프레임, 하위 테이블 -\u0026gt; 실제 페이지 프레임)\n페이지 테이블의 물리 주소 할당이 연속적이지 않아도 된다. 요구 페이징 시, 실제 사용하는 페이지 프레임에 비해 페이지 테이블의 용량이 너무 크다.\n만약 1단계 페이징에서 현재 페이지 테이블의 프레임이 실제 페이지 프레임을 하나도 가리키지 않는다면, 생략할 수 있다.\n즉, 불필요한 페이지 테이블을 생략할 수 있다.  물론 페이지 테이블이 2단계가 됨으로서 변환 연산이 두번 일어나야 한다는 단점은 있지만, 현재 상황에서 필요한 페이지 프레임의 수가 급격하게 줄어들었다. (모든 주소 공간을 사용하게 되면 오히려 필요한 페이지 프레임이 하나 더 추가되었지만, 요구 페이징때 언급했듯 그렇지 않은 경우가 더 많다.)\n위와 같은 2단계 이상 페이징을 할 때, 페이지 테이블을 가리키는 페이지 테이블같은 표현을 사용하기보단, 페이지 디렉토리란 표현을 사용한다.\n64비트 적용, 일반화 이제 이전의 32비트 환경에서 64비트 환경으로 확장해보자. 앞서 문제 정의 과정에서도 언급했듯, 주소 공간을 모두 사용하면 그 크기가 너무 과도하기 때문에, 현실적으로는 48비트 주소공간으로 한정한다. (주소 공간을 48비트로 한정한다는 것이지, CPU는 여전히 64비트를 사용하며, 주소 범위도 64비트로 존재할 수 있다.)\n32비트에서 확인했던 2단계 페이징과 기본적인 원리는 동일하다. 페이지 테이블의 연속 할당 문제, 불필요한 페이지 테이블을 위한 메모리 할당 등의 문제를 해결하기 위해 2단계 이상의 페이징이 필요하다.\n하지만 CPU가 다루는 비트의 개수가 2배가 되면서, 엔트리 표현에 필요한 주소가 2배가 되었다. 현재 페이지 프레임의 크기가 같은데, 주소 표현을 위한 크기가 2배가 됨으로서, 한 페이지 프레임에 표현할 수 있는 엔트리(주소)의 개수가 절반으로 줄어들었다. (32비트에서 1024개 주소를 표현했던 것이 64비트에서 512개가 되었다.)\n가상 주소를 비트 단위로 바라보면, 32비트에서는 10비트의 값만 변경되는데, 64비트에서는 9비트만 변경된다. 즉, 64비트에서는 페이징 단계마다 9비트씩 다루면 된다. 이 규칙을 좀 더 일반화해보자.\n먼저, 한 페이지 프레임에 몇 개의 엔트리를 표현할 수 있는지 계산하려면, 현재 페이지의 크기를 CPU가 표현 가능한 크기로 나누면 된다. (보통 메모리 주소 공간은 바이트로 표기하고, CPU의 단위는 비트로 표기하므로 이를 통일해야한다.) 한 페이지에서 표현 가능한 엔트리 개수만큼 실제 비트로 표현하려면, log2()를 취하면 그 숫자를 표현하기 위해 필요한 비트의 길이가 나온다.\n이 규칙을 응용하면 제일 처음 말했던 -2, -3의 원리를 알 수 있다. 32비트는 4바이트이며, log2(4) == 2다. 64비트는 8바이트이며, log2(8) == 3이다. 페이지의 비트에서 -2, -3은 이것을 의미한다.\n64-bits, 4KiB 가상 주소 공간의 크기가 커졌기 때문에 페이징 단계가 늘어나는 것은 필연적이다. 실제 프로세스의 주소 공간을 가리키는 엔트리는 그대로 두고, 페이지 디렉토리를 각 단계에 따라 다르게 부른다. 위 그림은 아래쪽으로 갈 수록 레벨 숫자를 낮게 잡았는데, 다른 글에서는 반대로 잡기도 한다. 여기서는 5단계 페이징시 추가되는 p4d의 위치를 고려하여 이렇게 순서를 결정했다.\n리눅스 커널에서 Intel같은 x86_64의 아키텍쳐에서 관리되는 방법은 모르겠는데, 내가 분석하고 있는 ARM64의 경우 아키텍쳐에서 유저 레벨과 커널 레벨에 대한 페이지 테이블 레지스터를 개별적으로 제공한다. 이 경우 각각 유저 레벨과 커널 레벨이 가리키는 가상주소는 앞의 주소가 달라진다.\n기타 이야기 위와 같이 2단계 이상 페이지 테이블에서 원하는 주소의 페이지 프레임 주소를 찾는 과정을 page walk라 한다. 위 1단계 예시 코드를 2단계 이상으로 확장한 코드의 예시는 여기를 참고하자.\n페이징 개념을 배울 때는 페이지의 크기를 원하는 대로 설정할 수 있다는 식의 이야기를 하지만, 실무에서는 사용할 수 있는 페이지의 크기 종류는 매우 제한적이다. 그리고 대부분 아키텍쳐에 의존적이다. 리눅스 커널의 설정만 봐도 얼마나 한정적인지 알 수 있을 것이다.\n","description":"","id":0,"section":"posts","tags":["페이징","메모리 관리"],"title":"계층적 페이징 계산 과정","uri":"https://devlog.jsyoo5b.net/ko/posts/osc_10th/ch09/hierarchical-paging-calc/"},{"content":"최근 오픈소스 프로젝트의 경우 git 호스팅 서비스인 github, gitlab, bitbucket 등에서 관리되고 있을 것이다. 해당 사이트들은 웹 브라우저에서 손쉽게 코드 기여를 할 수 있다. (github의 Pull Request, gitlab의 Merge Request, bitbucket의 Pull request 참고) 물론 위 호스팅 서비스 외 다른 서비스도 비슷한 방식으로 관리될 가능성이 높다.\n하지만 리눅스 커널을 비롯한 일부 오픈소스들은 메일을 통해 수정 사항을 보내고 리뷰한다. 이 문서에서는 리눅스 커널 위주로 설명할 예정이다. 리눅스 커널에 기여하기 위해서는 commit 작성 방법부터 여러 단계가 있지만, 이 글에서는 메일로 patch(git commit을 파일 단위로 변환)를 보내는 방법 중 하나인 git send-email의 사용법을 설명하도록 하겠다.\n메일 전송 도구 공식 문서에서는 유명한 이메일 클라이언트 목록과, patch 전송에 필요한 설정법을 설명하고 있다. 문서를 읽어보면 어떤 프로그램은 쓰지 말고 도망쳐 같은 비추천이 있는가 하면, 대부분 프로그램의 경우 조금만 설정하면 잘 쓸수 있다고 하고 있다.\n이 중 아마도 가장 인기있는 것은 mutt와 이번에 알아볼 git send-email일 것이다. 커널 개발 환경이 사실상 CLI라서 유난히 더 인기가 있는지도 모르겠다.\nmutt의 사용법이 궁금하다면 설정 방법과 메일 전송 방법 글을 참고하자. (\u0026quot;디버깅을 통해 배우는 리눅스 커널의 구조와 원리\u0026quot; 저자 분의 블로그며, 이 내용은 해당 책의 부록에도 실려있다.)\nGmail 사용자를 위한 추가 설정 만약 본인이 Gmail 계정으로 patch를 전송하려 하면 메일 전송 과정에서 오류가 발생할 것이다. Google의 보안 강화로 인해 직접 계정 비밀번호를 통해 인증하는 것이 아니라 앱 비밀번호를 이용해 인증해야 하는데, 여기서 미리 준비해두자.\n본인 계정이 영어로 설정되어 한국어 번역이 일치하지 않을 수도 있으나, 주요 페이지에 대한 링크를 걸어놓고, 스크린샷을 첨부했으니 참고하여 따라하면 될 것 같다.\n2단계 인증 사용 먼저 앱 비밀번호를 만들려면 2단계 인증을 사용해야한다.\n구글 계정의 보안 메뉴에서(아래 그림 ①) 2단계 인증을 활성화하자. 아래 그림과 같이 2단계 인증을 사용 중인 상태로 만들면 된다. (아래 그림 ②의 2단계 인증 메뉴를 눌러서 시키는대로 따라 하면 된다.)\n앱 비밀번호 만들기 이전 2단계 인증 메뉴 바로 아래에 앱 비밀번호(위 그림 ③)를 누르면 앱 비밀번호를 관리하는 페이지가 나온다. 앱 종류에서(아래 그림 ①) 메일을 선택하고, 장치 종류에서 **기타 (사용자 지정)**을(아래 그림 ②) 선택하면 기존 선택하던 자리가 이름을 입력하는 칸으로 변경된다. git send-email 등의 이름으로 입력하고 옆의 생성하기(아래 그림 ③) 버튼을 누르자.\n위와 같이 실행했다면 아래와 같은 화면에 16자 글자가 나올 것이다. (아래 스크린샷은 보안을 위해 생성된 비밀번호를 모자이크 처리했다.) 해당 비밀번호를 임시 텍스트 파일 등에 보관해두자. (메일 전송 시 계정 비밀번호 대신 사용하게 된다. 추가 설정을 통해 자동으로 저장되므로 평생 보관할 필요는 없다.)\ngit send-email 설치 및 설정 먼저 git send-email을 설치하자. (git은 이미 설치되어있다 가정한다.)\nUbuntu/Debian Fedora CentOS Arch  $ sudo apt install git-email   $ sudo dnf install git-email   $ sudo yum install git-email   # Arch 계열은 git 패키지 내 git send-email이 포함되어있다. $ sudo pacman -Syu --needed git perl-authen-sasl perl-io-socket-ssl     'use strict'; var containerId = JSON.parse(\"\\\"16364b18f63e0d7c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이후 메일 전송 및 인증과 관련된 Perl script 의존성들을 설치한다. (리눅스 커널을 빌드하려면 간접적으로 Perl을 설치했을 것이다. 아래 cpan 명령어가 실행 가능한지 확인해보고 설치하자.)\n메일 전송 및 인증 관련 패키지 설치  $ cpan Authen::SASL MIME::Base64 Net::SMTP::SSL     'use strict'; var containerId = JSON.parse(\"\\\"e9d4081e93b69a04\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이제 메일 계정과 관련된 정보를 git에 설정해주자. git config --edit 명령으로 설정 파일을 열어서 수정하면 된다. 참고로 git config --edit --global 명령으로 ~/.gitconfig 파일(현재 유저의 전역 설정) 수정이 가능하다. (\u0026quot;\u0026lt;\u0026gt;\u0026ldquo;로 된 부분에는 본인의 설정을 넣으면 된다.)\n다른 참고 링크의 경우 현재 유저의 전역 설정을 변경하라고 하지만, 현재 레포지터리의 설정만 수정해도 문제없다. (나의 경우, 특정 레포에 따라 계정 정보를 다르게 사용한 경험이 있어, 이렇게 처리한다.)\n추가할 git 설정 본인 사용 예시 (gmail)  [user] # commit 작성 시 이미 제대로 설정했을 것이다. name = \u0026lt;이름 (본명 사용)\u0026gt; email = \u0026lt;본인 이메일 주소\u0026gt; [sendemail] smtpServer = \u0026lt;사용할 이메일의 SMTP 주소\u0026gt; smtpServerPort = \u0026lt;사용할 이메일의 SMTP 포트\u0026gt; smtpEncryption = \u0026lt;사용할 이메일의 SMTP 주소\u0026gt; smtpUser = \u0026lt;사용할 이메일 주소\u0026gt; [credential] helper = store   [user] name = JaeSang Yoo email = jsyoo5b@gmail.com [sendemail] smtpServer = smtp.gmail.com smtpServerPort = 587 smtpEncryption = tls smtpUser = jsyoo5b@gmail.com [credential] helper = store     'use strict'; var containerId = JSON.parse(\"\\\"6cd45fb6028b1e56\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  [user] 부분은 이미 설정했을 것이니 설명은 생략하도록 하겠다.\n[sendemail]의 항목들은 SMTP로 메일을 보내기 위한 설정을 하는 것이다.\n[credential]에서 helper = store로 설정하는 것은, 자격증명(비밀번호 등을 통한 계정 인증) 내역을 개별 파일에(기본 경로: ~/.git-credentials) 저장하여 매번 메일 전송에 대한 자격증명을 요구하지 않고 재활용하게 하는 것이다.\n메일 보내기 실제 메일을 전송하기 전에, 메일 전송이 정상적으로 수행되는지 나에게 메일 보내기를 해보자. (일단 아래 명령어 예시에서는 내 메일 주소, 내가 작성했던 patch를 사용했다.) 먼저 --dry-run 인자를 입력하여 메일을 보낼 대상이 잘 설정되는지 확인해보고 실제로 전송해보자. 받을 메일 주소는 --to $메일_주소를, 참조할 메일 주소는 --cc $메일_주소 인자로 넣으면 된다. (상대 이름을 포함해서 메일주소를 전달하고 싶다면 --to \u0026quot;$이름 \u0026lt;$메일_주소\u0026gt;\u0026quot; 형태로 입력하면 된다.)\ndry run으로 메일 전송 목록 확인하기 실제 나에게 메일 전송해보기  $ git send-email --to \u0026#34;JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;\u0026#34; --dry-run 0001-mm-slub-remove-unused-parameter-in-setup_object.patch 0001-mm-slub-remove-unused-parameter-in-setup_object.patch (mbox) Adding cc: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; from line \u0026#39;From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;\u0026#39; (body) Adding cc: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; from line \u0026#39;Signed-off-by: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;\u0026#39; Dry-OK. Log says: Server: smtp.gmail.com MAIL FROM:\u0026lt;jsyoo5b@gmail.com\u0026gt; RCPT TO:\u0026lt;jsyoo5b@gmail.com\u0026gt; From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; To: jsyoo5b@gmail.com Subject: [PATCH] mm/slub: remove unused parameter in setup_object*() Date: Mon, 11 Apr 2022 21:39:56 +0900 Message-Id: \u0026lt;20220411123956.3493712-1-jsyoo5b@gmail.com\u0026gt; X-Mailer: git-send-email 2.25.1 MIME-Version: 1.0 Content-Transfer-Encoding: 8bit Result: OK   $ git send-email --to \u0026#34;JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;\u0026#34; 0001-mm-slub-remove-unused-parameter-in-setup_object.patch 0001-mm-slub-remove-unused-parameter-in-setup_object.patch (mbox) Adding cc: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; from line \u0026#39;From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;\u0026#39; (body) Adding cc: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; from line \u0026#39;Signed-off-by: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;\u0026#39; From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; To: jsyoo5b@gmail.com Subject: [PATCH] mm/slub: remove unused parameter in setup_object*() Date: Mon, 11 Apr 2022 21:44:17 +0900 Message-Id: \u0026lt;20220411124417.3496483-1-jsyoo5b@gmail.com\u0026gt; X-Mailer: git-send-email 2.25.1 MIME-Version: 1.0 Content-Transfer-Encoding: 8bit The Cc list above has been expanded by additional addresses found in the patch commit message. By default send-email prompts before sending whenever this occurs. This behavior is controlled by the sendemail.confirm configuration setting. For additional information, run \u0026#39;git send-email --help\u0026#39;. To retain the current behavior, but squelch this message, run \u0026#39;git config --global sendemail.confirm auto\u0026#39;. Send this email? ([y]es|[n]o|[e]dit|[q]uit|[a]ll): y OK. Log says:\u0026#39;smtp://jsyoo5b@gmail.com@smtp.gmail.com:587\u0026#39;: Server: smtp.gmail.com MAIL FROM:\u0026lt;jsyoo5b@gmail.com\u0026gt; RCPT TO:\u0026lt;jsyoo5b@gmail.com\u0026gt; From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; To: jsyoo5b@gmail.com Subject: [PATCH] mm/slub: remove unused parameter in setup_object*() Date: Mon, 11 Apr 2022 21:44:17 +0900 Message-Id: \u0026lt;20220411124417.3496483-1-jsyoo5b@gmail.com\u0026gt; X-Mailer: git-send-email 2.25.1 MIME-Version: 1.0 Content-Transfer-Encoding: 8bit Result: 250     'use strict'; var containerId = JSON.parse(\"\\\"566e382548a41573\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  dry-run 부분을 보면 기본적으로 나 자신(내 메일 주소)를 참조하는 것을 볼 수 있다. 또한 patch 안에 Signed-off-by:에 내 메일 주소가 있기 때문에 자동으로 참조를 시도한다. 물론 현재 명령어에서 받을 메일 주소로 나 자신을 설정했기 때문에 참조 설정은 자동으로 무시되었다. (인자로 입력하지 않아도 나 자신이 참조되는 부분은 아래에서 다시 보여주도록 하겠다.)\n실제 메일 전송을 시도하면 Send this email? ([y]es|[n]o|[e]dit|[q]uit|[a]ll): 와 같이 보내기 전에 확인한다. y를 입력하면 실제 메일 전송을 시도한다. 만약 처음 메일을 보내려 한다면, 실질적인 자격증명(계정 비밀번호 확인)을 위해 비밀번호 등을 물어본다. 계정의 비밀번호를 입력하면 된다. 이번 자격증명 이후로는 아까 [credential] 설정 덕분에 비밀번호 정보가 저장되므로, 앞으로 메일 보낼 때는 비밀번호를 물어보지 않을 것이다.\n Gmail 사용자는 실제 본인 계정의 비밀번호가 아니라, 이전에 준비한 16자리의 앱 비밀번호를 입력하면 된다.\n 자격증명에 성공했다면 최종적으로 Result: 250과 같이 메일 전송 결과가 나타난다. 본인 메일함에 patch가 잘 들어왔는지 확인해보자.\n실제 patch 전송하기 (리눅스 커널) 메일을 통해 수정 사항을 보내고 리뷰하는 다른 프로젝트라면 위의 메일 보내는 부분까지만 봐도 충분하다. 아래 부분은 리눅스 커널 기여 과정에서 생길 상황을 설명한다.\ncommit을 작성하고, patch로 변환한 내역을 메일로 보내려면 누구한테 메일을 보낼 지 알아내야 한다. 리눅스 커널의 경우 현재 patch에 따라 누구에게 보내야 하는지 확인해주는 스크립트가 제공된다. (현재 작성한 patch가 규정을 만족하는지에 대한 스크립트도 제공되지만, 이 부분에 대한 설명은 생략하도록 하겠다.)\n아래 코드는 slub 코드를 수정했던 패치를 전달하는 경우의 예시다.\n메일 전송 대상 확인하기  $ ./scripts/get_maintainer.pl 000l-mm-slub-remove-unused-parameter-in-setup_object.patch Christoph Lameter \u0026lt;cl@linux.com\u0026gt; (maintainer:SLAB ALLOCATOR) Pekka Enberg \u0026lt;penberg@kernel.org\u0026gt; (maintainer:SLAB ALLOCATOR) David Rientjes \u0026lt;rientjes@google.com\u0026gt; (maintainer:SLAB ALLOCATOR) Joonsoo Kim \u0026lt;iamjoonsoo.kim@lge.com\u0026gt; (maintainer:SLAB ALLOCATOR) Andrew Morton \u0026lt;akpm@linux-foundation.org\u0026gt; (maintainer:SLAB ALLOCATOR) Vlastimil Babka \u0026lt;vbabka@suse.cz\u0026gt; (maintainer:SLAB ALLOCATOR) Roman Gushchin \u0026lt;roman.gushchin@linux.dev\u0026gt; (reviewer:SLAB ALLOCATOR) linux-mm@kvack.org (open list:SLAB ALLOCATOR) linux-kernel@vger.kernel.org (open list)     'use strict'; var containerId = JSON.parse(\"\\\"4774d2f7ca547c4b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이제 이 patch를 위 메일 주소에 모두 전송해야된다. 일반적으로 maintainer나 reviewer의 경우 --to의 대상이며, linux-mm@kvack.org같은 메일링 리스트(open list)는 --cc로 참조하는 것이 일반적인 규정이다. 하지만 이 메일 주소들을 모두 복사해서 인자로 넣기 귀찮을 것이다. git send-email의 경우 이 목록을 좀 더 쉽게 입력할 방법을 제공한다. 아까와 같이 git 설정에 아래 부분을 추가해주자.\ngit 설정에 tocmd, cccmd 설정  [sendemail] # 이전 SMTP 설정 아래에 추가하면 된다. tocmd =\u0026#34;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nol\u0026#34; cccmd =\u0026#34;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nom\u0026#34;     'use strict'; var containerId = JSON.parse(\"\\\"bbbc0d50c4b3203d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이전에 메일 전송 대상을 확인해주던 ./scripts/get_maintainer.pl의 경우 여러 인자를 통해 결과를 변경할 수 있다. --norolestat 인자를 통해 각 메일 주소의 maintainer, reviewer, open list 부분을 제외하고 출력시킬 수 있다. --nogit와 --nogit-fallback 부분은 해당 스크립트의 도움말에서 --git, --git-fallback 설정을 끄는 것이니, 해당 도움말을 참고하기 바란다.\ntocmd와 cccmd가 다른 점은 마지막에 --nol, --nom이 각각 다른데, --nol은 메일링 리스트를 제외할것, --nom은 메인테이너를 제외하라는 명령이다.\n이제 메일 전송 대상은 자동으로 입력될테니 실제 메일을 전송해보자. (물론 먼저 --dry-run으로 잘 되는지 확인부터 하자.)\n실제 patch를 메인테이너들에게 전송하기  $ git send-email 0001-mm-slub-remove-unused-parameter-in-setup_object.patch 0001-mm-slub-remove-unused-parameter-in-setup_object.patch (mbox) Adding cc: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; from line \u0026#39;From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;\u0026#39; (body) Adding cc: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; from line \u0026#39;Signed-off-by: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;\u0026#39; (to-cmd) Adding to: Christoph Lameter \u0026lt;cl@linux.com\u0026gt; from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nol\u0026#39; (to-cmd) Adding to: Pekka Enberg \u0026lt;penberg@kernel.org\u0026gt; from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nol\u0026#39; (to-cmd) Adding to: David Rientjes \u0026lt;rientjes@google.com\u0026gt; from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nol\u0026#39; (to-cmd) Adding to: Joonsoo Kim \u0026lt;iamjoonsoo.kim@lge.com\u0026gt; from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nol\u0026#39; (to-cmd) Adding to: Andrew Morton \u0026lt;akpm@linux-foundation.org\u0026gt; from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nol\u0026#39; (to-cmd) Adding to: Vlastimil Babka \u0026lt;vbabka@suse.cz\u0026gt; from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nol\u0026#39; (to-cmd) Adding to: Roman Gushchin \u0026lt;roman.gushchin@linux.dev\u0026gt; from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nol\u0026#39; (cc-cmd) Adding cc: Roman Gushchin \u0026lt;roman.gushchin@linux.dev\u0026gt; from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nom\u0026#39; (cc-cmd) Adding cc: linux-mm@kvack.org from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nom\u0026#39; (cc-cmd) Adding cc: linux-kernel@vger.kernel.org from: \u0026#39;`pwd`/scripts/get_maintainer.pl --nogit --nogit-fallback --norolestats --nom\u0026#39; From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; To: Christoph Lameter \u0026lt;cl@linux.com\u0026gt;, Pekka Enberg \u0026lt;penberg@kernel.org\u0026gt;, David Rientjes \u0026lt;rientjes@google.com\u0026gt;, Joonsoo Kim \u0026lt;iamjoonsoo.kim@lge.com\u0026gt;, Andrew Morton \u0026lt;akpm@linux-foundation.org\u0026gt;, Vlastimil Babka \u0026lt;vbabka@suse.cz\u0026gt;, Roman Gushchin \u0026lt;roman.gushchin@linux.dev\u0026gt; Cc: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;, linux-mm@kvack.org, linux-kernel@vger.kernel.org Subject: [PATCH] mm/slub: remove unused parameter in setup_object*() Date: Mon, 11 Apr 2022 16:25:34 +0900 Message-Id: \u0026lt;20220411072534.3372768-1-jsyoo5b@gmail.com\u0026gt; X-Mailer: git-send-email 2.25.1 MIME-Version: 1.0 Content-Transfer-Encoding: 8bit The Cc list above has been expanded by additional addresses found in the patch commit message. By default send-email prompts before sending whenever this occurs. This behavior is controlled by the sendemail.confirm configuration setting. For additional information, run \u0026#39;git send-email --help\u0026#39;. To retain the current behavior, but squelch this message, run \u0026#39;git config --global sendemail.confirm auto\u0026#39;. Send this email? ([y]es|[n]o|[e]dit|[q]uit|[a]ll): y OK. Log says: Server: smtp.gmail.com MAIL FROM:\u0026lt;jsyoo5b@gmail.com\u0026gt; RCPT TO:\u0026lt;cl@linux.com\u0026gt; RCPT TO:\u0026lt;penberg@kernel.org\u0026gt; RCPT TO:\u0026lt;rientjes@google.com\u0026gt; RCPT TO:\u0026lt;iamjoonsoo.kim@lge.com\u0026gt; RCPT TO:\u0026lt;akpm@linux-foundation.org\u0026gt; RCPT TO:\u0026lt;vbabka@suse.cz\u0026gt; RCPT TO:\u0026lt;roman.gushchin@linux.dev\u0026gt; RCPT TO:\u0026lt;jsyoo5b@gmail.com\u0026gt; RCPT TO:\u0026lt;linux-mm@kvack.org\u0026gt; RCPT TO:\u0026lt;linux-kernel@vger.kernel.org\u0026gt; From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; To: Christoph Lameter \u0026lt;cl@linux.com\u0026gt;, Pekka Enberg \u0026lt;penberg@kernel.org\u0026gt;, David Rientjes \u0026lt;rientjes@google.com\u0026gt;, Joonsoo Kim \u0026lt;iamjoonsoo.kim@lge.com\u0026gt;, Andrew Morton \u0026lt;akpm@linux-foundation.org\u0026gt;, Vlastimil Babka \u0026lt;vbabka@suse.cz\u0026gt;, Roman Gushchin \u0026lt;roman.gushchin@linux.dev\u0026gt; Cc: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt;, linux-mm@kvack.org, linux-kernel@vger.kernel.org Subject: [PATCH] mm/slub: remove unused parameter in setup_object*() Date: Mon, 11 Apr 2022 16:25:34 +0900 Message-Id: \u0026lt;20220411072534.3372768-1-jsyoo5b@gmail.com\u0026gt; X-Mailer: git-send-email 2.25.1 MIME-Version: 1.0 Content-Transfer-Encoding: 8bit Result: 250     'use strict'; var containerId = JSON.parse(\"\\\"3e3470ec690aa446\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위 결과는 이전에 patch를 보낼때 나온 기록을 재활용했다.\n이전에 tocmd, cccmd를 설정한대로, maintainer들은 To:에, open list들은 Cc:에 추가되었다. 중간에 reviewer는 --nom, --nol에도 필터링 되지 않았기 때문에 (필터링을 하려면 --nor을 인자로 넣어야 한다.) To:와 Cc:에 모두 추가되었지만 중복되므로 To:에만 남아있는 것을 볼 수 있다.\n또한 이전에 나에게 메일 보낼 때 확인했던 것과 같이 자동으로 내 메일 주소를 참조하도록 설정되었다.\n수정 버전 전송하기 전송한 patch가 명백하고 간단하다면 바로 승인되겠지만, 개선사항 등이 존재한다면 리뷰 메일이 올 것이고, 새로 수정한 버전을 전송해야한다. 이전처럼 commit을 다시 작성하고 patch로 만든 다음 해당 patch 파일에 일부 내용을 수정해야한다.\n 제목에 [PATCH]를 [PATCH v2]처럼 개선 횟수마다 버전을 올려야 한다. 이전에 비해 어떤 점이 변경되었는지 설명이 필요하다면 언급해도 된다.  특히 2번의 경우 사소한 이야기나 변경 내역을 commit log에 남게 하지 않으려면 아래처럼 작성하면 된다.\ncommit log에 영향이 가지 않게 주석을 다는 방법  Subject: [PATCH v3] trace: param: fix tp_printk option related with tp_printk_stop_on_boot Kernel param \u0026#34;tp_printk_stop_on_boot\u0026#34; starts with \u0026#34;tp_printk\u0026#34; which is the exact as the other kernel param \u0026#34;tp_printk\u0026#34;. In compile \u0026amp; build process, It may not guaranteed that \u0026#34;tp_printk_stop_on_boot\u0026#34; always checked before \u0026#34;tp_printk\u0026#34;. (By swapping its __setup() macro order, it may not work as expected.) Some kernel params which starts with other kernel params consider this problem. See commit 745a600cf1a6 (\u0026#34;um: console: Ignore console= option\u0026#34;) or init/do_mounts.c:45 (setup function of \u0026#34;ro\u0026#34; kernel param) Kernel param \u0026#34;tp_printk\u0026#34; can be handled with its value(0 or off) or it can be handled without its value. (maybe it won\u0026#39;t effect anything) Fix setup function to ignore when the \u0026#34;tp_printk\u0026#34; becomes prefix of other kernel param. Signed-off-by: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; --- from v2, I thought the changes were obvious that I didn\u0026#39;t even tried to check whether it has obvious typo. Sorry about that. kernel/trace/trace.c | 3 +++ 1 file changed, 3 insertions(+) diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c index c860f582b078..48f34ab29db2 100644 --- a/kernel/trace/trace.c +++ b/kernel/trace/trace.c @@ -252,6 +252,9 @@ __setup(\u0026#34;trace_clock=\u0026#34;, set_trace_boot_clock);  static int __init set_tracepoint_printk(char *str) { +\t/* Ignore the \u0026#34;tp_printk_stop_on_boot\u0026#34; param */ +\tif (*str == \u0026#39;_\u0026#39;) +\treturn 0;  if ((strcmp(str, \u0026#34;=0\u0026#34;) != 0 \u0026amp;\u0026amp; strcmp(str, \u0026#34;=off\u0026#34;) != 0)) tracepoint_printk = 1; return 1; -- 2.25.1     'use strict'; var containerId = JSON.parse(\"\\\"15f147e521381e4c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  참고로 위 patch는 v2에서 너무 신난 나머지 return 0에 ;조차 안 붙여서 혼난 것에 대한 수정 patch다. 물론 v2 리뷰에서 주석도 추가하라고 해서 같이 수정한 상태다.\n보통 commit log와 실제 코드 변경분 사이에 ---으로 구분을 하는데, 이 바로 아래에 patch에 대한 주석을 달아도 된다. 공식 문서에도 해당 부분이 언급되어있다.\n추후 추가사항 아쉽게도 지금까지 패치 내역은 1개의 commit 단위라서 메일을 1개씩만 보냈지만, 작업을 하다보면 commit을 여러 개로 분리하여 한번에 patch set 등으로 보내기도 한다.\n만약 전송할 패치가 3개라면 순서대로 [PATCH 1/3], [PATCH 2/3], [PATCH 3/3]과 같이 여러 patch set임을 제목에서 알려주게 된다. 그리고 해당 patch set에 대한 소개를 [PATCH 0/3]과 같이 제일 앞에 커버 레터처럼 전송하기도 한다. 아쉽게도 이 부분에 대한 경험이 없는데, 추후 경험해본다면 작성해 보도록 하겠다.\n참고 링크 [1] 리눅스에 패치 업로드 하기\n[2] Gmail 사용 시 git send-email 설정 방법\n[3] 메일 전송 대상 자동 추가하는 방법\n","description":"","id":1,"section":"posts","tags":["git","send-email"],"title":"git patch 내역 메일 전송 방법 (git send-email)","uri":"https://devlog.jsyoo5b.net/ko/posts/git/send-email/"},{"content":"본 리뷰는 오브젝트, 객체지향의 사실과 오해 책에 대한 리뷰입니다.\n읽은 계기 클린 코드 책 읽기 스터디가 끝난 뒤, 다음 주제로 오브젝트 책 읽기 스터디를 진행하였다. 기본적으로는 오브젝트를 읽는 것이 주요 목적이었으나, 해당 책의 경우 객체지향의 사실과 오해 책에서 부족한 부분을 채우는 식이라는 이야기도 있었고, 같은 저자의 책인 만큼 같이 읽어보는 것이 도움이 되리라 생각했다.\n객체지향의 사실과 오해(이하 객사오로 표현)는 이전에 반 정도 읽다 말았는데, 이 기회를 통해 완독할 수 있었다.\n객체지향에 대한 새로운 접근법 나는 이 책을 읽으면서, 객체지향이란 개념을 이정도로 쥐어 짜서 활용할 수 있구나 같은 생각을 많이 했던 것 같다.\n책을 읽기 전, 객체지향에 대한 내 생각은 현실적으로 단점도 많긴 하지만, 대체재가 없는 패러다임이라 생각했다. 분명 객체지향은 머리 속에 생각하고 있는 개념을 추상화하여 코드로 작성하는데 있어 효과적인 전략인 것은 맞지만, 이걸 효과적으로 표현하기 위해 사용되는 boilerplate 코드들이 너무 많고, 객체지향적으로 접근하기 위해 생각하고, 표현하고, 검증하는 과정이 너무 피로하다 생각했다. 그럼에도 불구하고 이를 대체할만한 전략이 없기 때문에 여전히 사용되고 있다고 생각했다. (알 사람들은 알겠지만, 함수형 패러다임은 객체지향을 부정하는 것이 아니므로 논외로 친다.)\n특히 책의 내용을 읽으면서, 내가 객체지향이 가진 장점을 100% 활용하지 못하고 있었다는 생각이 들었다. 책에서는 Java를 메인 언어로 설명하고 있다. 나의 경우 객체지향 개념에 대한 이해를 C++로 시작했는데, 알다시피 C++은 객체지향을 시작하기에 그다지 좋은 언어는 아니다. 그래서 책을 읽으면서 새로 깨우친 것 같은 부분을 다른 스터디원들은 당연하게 생각했다는 이야기를 듣기도 했다. 이 분들의 경우 Java, Spring 기반 업무를 맡은 백엔드 개발자분들이라 Java식의 객체지향에 익숙한 부분도 있을 것이고, 기본적으로 Java 자체가 C++에 비해 좀 더 객체지향적인 지원이나 설계가 반영된 언어라서 그런 지도 모르겠다.\n책의 구성 책을 읽는 순서를 굳이 매기자면, 객사오 다음에 오브젝트를 읽어야 한다. 두 책의 관계를 굳이 비유하자면, 이론서(객사오)와 실무예제(오브젝트)라고 볼 수 있다.\n객사오에서는 흔히 전통적으로 취급하는 객체지향의 관점 (은닉화, 다형성, 상속, 추상화)같은 이야기 위주로 객체지향을 푸는 것이 아니라, 역할, 책임, 협력이란 키워드를 기준으로 객체지향이란 개념을 다시 정의하고 있다. 내가 이해하던 객체지향의 경우, 추상화가 핵심이고 은닉화, 다형성, 상속은 이를 보조하는 도구에 불과하다 생각했다. 하지만 객사오에서 주장하는 바에 따르면 추상화조차도 상황에 따라선 객체지향의 핵심이 아닐 수도 있다는 식의 표현을 하고 있었다. (물론 역할, 책임 개념에서 어느정도 추상화에 대한 부분이 녹아있긴 하다.)\n객사오에서 역할, 책임, 협력이라는 주장을 이해했다면, 오브젝트에서는 그 주장을 실제 코드에 적용하는 과정을 보여준다. 객사오는 여러 챕터에 걸쳐 자신의 주장을 펼치지만, 이상한 나라의 앨리스 같은 상황의 예제로 설명하느라, 해당 개념들이 코드에서 어떻게 반영될 지 감이 오지 않을 수 있다. 그에 비해 오브젝트는 이 개념들이 코드로 적용될 때 고려해야할 부분을 상세하게 나눠서 설명한다.\n깊은 자료 조사의 흔적 책을 보다 보면 어떤 사람은 어떤 식의 주장을 했다. 어떤 관점에서 이런 이야기를 했다 식의 의견을 인용하는 부분이 많이 나온다. 아무래도 자신만의 관점으로 처음부터 표현하기 위해 그만큼 많은 자료조사를 했겠지만, 필요 이상으로 자료 조사를 많이 하고, 수 많은 지식을 쌓았음을 느낄 수 있었다. 중간에는 도널드 노먼을 인용하기도 하는데, 이 분은 개발 서적보다는 디자인, UX 등에서 자주 접할 수 있는 이름이다. (확인해보니 노스웨스턴 대학 컴퓨터공학과 교수라고는 하지만, 아무래도 유명한건 디자인, UX쪽이다.)\n전체적인 레퍼런스를 확인해보니, 저자가 주장하는 역할, 책임, 협력이라는 개념은 Object Design: Roles, Responsibilities, and Collaborations 책에서 제일 많은 영향을 받은 것 같다. 물론 내가 이 레퍼런스를 읽어보진 못했지만, 그렇다고 객사오와 오브젝트가 이 책의 번역판 수준일 것이라고 생각하지는 않는다. 내 생각에 현대적이라 생각하는 접근법인 합성을 통한 설계라던가, 덕 타이핑을 언급하는 부분에서 내용 추가에 대한 고민을 했을 것이라 생각한다.\n책의 특징 일단 저자는 본인의 주장을 강력하게 어필한다. 저자의 의견에 동의하지 않는 사람이라면 거부감이 들 수도 있겠지만(나도 초반에는 거부감이 느껴졌다.) 읽다 보면 상당히 근거를 두고 주장을 하기 때문에, 읽다 보면 충분히 빠져들게 될 것이다. 또한 객체지향을 제외한 다른 부분에 대한 언급을 거의 하지 않기 때문에, 객체지향 설계에만 집중하게 되고, 읽으면서 반론이 별로 생각나지 않았다. (이전에 읽은 클린 코드의 경우, 반론 거리가 너무 많아서 매우 공격적으로 독서했던 것에 비해 많이 순응하며 읽었던 것 같다.)\n책을 통해 배운 것 이전까지는 객체지향이야기를 할 때마다 따라오는 디자인 패턴에 대해 공부의 필요성은 느꼈지만, 잘 와닿지 않는 문제가 있어, 패턴 공부를 하다 멈추는 경우가 많았다. 특히 Factory 패턴, Strategy 패턴의 경우, 왜 필요한 지에 대해 이해하지 못했고, 예제를 봐도 너무 단편적인 것 같았다. 하지만 이 책을 보면서 왜 이런 패턴이 필요한지 설득되기에 충분한 내용이었다고 생각한다. 또한 해당 패턴을 적용해서 어떤 점이 좋아지는지를 코드만으로 설명하는 것이 아니라, SOLID 원칙을 지키기 위한 방법으로서 주장한다는 점에서 더 많이 와닿았던 것 같다.\n1회독만으로도 배운 것은 많지만, 좀 더 완벽히 이해하려면 한 번 이상 더 정독할 필요가 있을 것 같다.\n추천 독자 객체지향과 관련된 아니지만 초반에 매우 인상적인 이야기를 하는데, 이론과 실무, 어느 쪽이 먼저일까? 라는 내용으로 이야기를 시작한다. 대충 요약하자면 실무적인 경험을 토대로 이론이 정립된다는 것이다.\n나는 객체지향을 학부 2학년때 배웠는데, 최대한 늦게 배워야 한다고 생각하는 사람이다. 못해도 3학년 2학기, 제일 좋은건 취업 전에 필수 과목으로 강의되었으면 싶다. 물론 추상화를 통한 코드 작성 전략은 먼저 가르쳐도 좋지만, 객체지향을 온 몸으로 느끼기엔 충분한 경험이 필요하다 생각한다.\n그런 의미에서, 이 책은 졸업반 혹은 갓 졸업한 신입이 읽으면 좋을 것이라 생각하지만, 이걸 이해하고 반영할 수 있는 수준이 되려면 실무에서 1~2년정도는 겪어보면서 왜 내 코드에 발전이 없을까? 같은 생각이 들 때 쯤 읽어보면 좋을 것 같다.\n","description":"","id":2,"section":"posts","tags":["객체지향","객체지향의 사실과 오해","오브젝트"],"title":"[책 리뷰] 오브젝트, 객체지향의 사실과 오해","uri":"https://devlog.jsyoo5b.net/ko/posts/review/book-objects-eooo/"},{"content":"리눅스 커널 소스에 두 번째 기여를 한 기념으로 어떻게 기여하게 되었는지 그 과정을 공유한다. 이전에 비해 코드 수정이긴 하지만, 길이나 난이도 면에서는 간단한 편이다. 어쨋든 그 기여를 위해 어떤 판단을 했고, 어떻게 자료 조사를 했는지에 대한 경험을 공유하고자 한다.\n어떻게 기여할 만한 것을 찾았는가? iamroot 커널 스터디에 계속 참여하던 중, 커널에서 부팅 시 전달된 파라미터를 적용하는 과정을 분석하게 되었다. (start_kernel() 내 parse_early_params()~print_unknown_bootoptions() 및 에러 출력 부분)\n여기에서 커널 파라미터를 처리하는 과정에서 예외 처리가 부족한 부분을 확인할 수 있었다.\n커널 파라미터가 처리되는 흐름 bootloader 등을 통해 커널이 메모리로 로딩될 때, 커널에 초기 설정을 위한 인자를 전달할 수 있다. 이를 커널 파라미터라 부르도록 하겠다. (대표적으로 grub의 메뉴 설정을 보면 사용할 커널 이미지 경로 뒤에 ro, quiet, splash, root= 등이 작성되어있는데, 이 부분이 커널 파라미터다.)\n커널 파라미터의 주요 처리는 앞에서 설명했듯 start_kernel()의 parse_early_params()~print_unknown_bootoptions() 부근에서 처리된다. 일부 커널 파라미터는 setup_arch() 내에서 먼저 처리되기도 한다. (대표적으로 ARM64가 setup_arch() 내에서 콘솔 관련 파라미터를 처리한다.) 그리고 이 파라미터가 커널에서 읽을 수 있게 준비되는 과정은(boot_command_line 변수에 저장) 각 아키텍쳐마다 다르겠디만, 아마도 setup_arch() 내에서 처리될 것으로 예상된다.\n참고로 ARM64에서 커널 파라미터를 추출하는 과정은 start_kernel() =\u0026gt; setup_arch() =\u0026gt; setup_machine_fdt() =\u0026gt; early_init_dt_scan() =\u0026gt; early_init_dt_scan_nodes()에서 처리된다. 이 부분은 이번에 기여한 커밋과 직접적인 관계는 없으므로 다음에 설명하려 한다.\n커널 파라미터가 처리되는 과정을 간략하게 요약하면 다음과 같다.\n 커널이 처리할 파라미터 핸들러는 struct kernel_param 혹은 struct obs_kernel_param 형태로 정의된다. 부팅시 전달받은 커널 파라미터를(boot_command_line 변수 등에 저장된 문자열) 스페이스 단위로 분리한다. (토큰화) 각 토큰이 기존 정의된 파라미터로 시작하는지 검사하고, 핸들러 함수를 수행하거나, 다음 파라미터 정의와 비교한다. 핸들러 함수가 정상 처리되었다면 다음 토큰에 대하여 2~3 과정을 반복한다.  커널 파라미터 선언 및 핸들러 등록 앞서 설명했듯, 파라미터 핸들러는 struct kernel_param 혹은 struct obs_kernel_param 형태로 정의된다. 각 구조체의 정의는 아래와 같다.\nstruct kernel_param (/include/linux/moduleparam.h) struct obs_kernel_param (/include/linux/init.h)  struct kernel_param_ops { /* How the ops should behave */ unsigned int flags; /* Returns 0, or -errno. arg is in kp-\u0026gt;arg. */ int (*set)(const char *val, const struct kernel_param *kp); /* Returns length written or -errno. Buffer is 4k (ie. be short!) */ int (*get)(char *buffer, const struct kernel_param *kp); /* Optional function to free kp-\u0026gt;arg when module unloaded. */ void (*free)(void *arg); }; struct kernel_param { const char *name; struct module *mod; const struct kernel_param_ops *ops; const u16 perm; s8 level; u8 flags; union { void *arg; const struct kparam_string *str; const struct kparam_array *arr; }; };   struct obs_kernel_param { const char *str; int (*setup_func)(char *); int early; };     'use strict'; var containerId = JSON.parse(\"\\\"e20d63f2cbe9ab33\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  각 구조체가 정의된 헤더의 파일 이름을 보면 struct kernel_param은 커널 모듈에 전달되는 파라미터를 정의하고, struct obs_kernel_param은 커널의 초기화 과정에서 처리될 파라미터만 정의하는 것으로 보인다. obs_는 obsolete의 약자로, 이 형태의 파라미터 핸들러 정의를 예전부터 사용했는데, 추후 도태시킬 생각인가 의심된다. (혹은 커널 초기화 과정에서만 사용되고 그 이후로는 사용되지 않으니 도태된다고 하는 것일 수도 있겠다.)\n일단 현재 기여 내용과 관련있는 쪽은 struct obs_kernel_param 쪽인데, 이 부분을 좀 더 자세히 보자. 먼저 핸들러를 어떤 방식으로 등록하는지 관련된 코드는 아래와 같다.\n커널 파라미터 핸들러 등록 매크로 (/include/linux/init.h) .init.setup 섹션 정의 (/include/asm-generic/vmlinux.lds.h)  /* * Only for really core code. See moduleparam.h for the normal way. * * Force the alignment so the compiler doesn\u0026#39;t space elements of the * obs_kernel_param \u0026#34;array\u0026#34; too far apart in .init.setup. */ #define __setup_param(str, unique_id, fn, early)\t\\ static const char __setup_str_##unique_id[] __initconst\t\\ __aligned(1) = str; \\ static struct obs_kernel_param __setup_##unique_id\t\\ __used __section(\u0026#34;.init.setup\u0026#34;)\t\\ __aligned(__alignof__(struct obs_kernel_param))\t\\ = { __setup_str_##unique_id, fn, early }  /* * NOTE: __setup functions return values: * @fn returns 1 (or non-zero) if the option argument is \u0026#34;handled\u0026#34; * and returns 0 if the option argument is \u0026#34;not handled\u0026#34;. */ #define __setup(str, fn)\t\\ __setup_param(str, fn, fn, 0)  /* * NOTE: @fn is as per module_param, not __setup! * I.e., @fn returns 0 for no error or non-zero for error * (possibly @fn returns a -errno value, but it does not matter). * Emits warning if @fn returns non-zero. */ #define early_param(str, fn)\t\\ __setup_param(str, fn, fn, 1)   #define INIT_SETUP(initsetup_align)\t\\ . = ALIGN(initsetup_align);\t\\ __setup_start = .;\t\\ KEEP(*(.init.setup))\t\\ __setup_end = .;     'use strict'; var containerId = JSON.parse(\"\\\"b23ec9770e638a12\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  커널 파라미터 핸들러의 등록은 __setup() 혹은 early_param() 매크로를 통해 등록할 수 있다. 해당 매크로를 사용하면 struct obs_kernel_param을 .init.setup 섹션에 배치되게 하며, 파라미터의 이름은 별도의 상수에 선언하고, 멤버변수로 그 상수를 가리키게 설정한다.\n커널 파라미터 핸들러의 등록, 순회 과정 그렇다면 실제 핸들러 함수를 등록하는 부분, 핸들러를 순회하는 과정을 코드로 확인해보자. (핸들러 함수 등록은 아래 예제 말고도 많이 있지만, 단편적인 것들만 다루겠다.)\n핸들러 등록 예시 핸들러 순회 (/init/main.c)  /// usage of __setup() in /init/do_mounts.c  static int __init load_ramdisk(char *str) { pr_warn(\u0026#34;ignoring the deprecated load_ramdisk= option\\n\u0026#34;); return 1; } __setup(\u0026#34;load_ramdisk=\u0026#34;, load_ramdisk); static int __init readonly(char *str) { if (*str) return 0; root_mountflags |= MS_RDONLY; return 1; } static int __init readwrite(char *str) { if (*str) return 0; root_mountflags \u0026amp;= ~MS_RDONLY; return 1; } __setup(\u0026#34;ro\u0026#34;, readonly); __setup(\u0026#34;rw\u0026#34;, readwrite); /// usage of early_param() in /drivers/tty/serial/earlycon.c  /* early_param wrapper for setup_earlycon() */ static int __init param_setup_earlycon(char *buf) { int err; /* Just \u0026#39;earlycon\u0026#39; is a valid param for devicetree and ACPI SPCR. */ if (!buf || !buf[0]) { if (IS_ENABLED(CONFIG_ACPI_SPCR_TABLE)) { earlycon_acpi_spcr_enable = true; return 0; } else if (!buf) { return early_init_dt_scan_chosen_stdout(); } } err = setup_earlycon(buf); if (err == -ENOENT || err == -EALREADY) return 0; return err; } early_param(\u0026#34;earlycon\u0026#34;, param_setup_earlycon);   extern const struct obs_kernel_param __setup_start[], __setup_end[]; static bool __init obsolete_checksetup(char *line) { const struct obs_kernel_param *p; bool had_early_param = false; p = __setup_start; do { int n = strlen(p-\u0026gt;str); if (parameqn(line, p-\u0026gt;str, n)) { if (p-\u0026gt;early) { /* Already done in parse_early_param? * (Needs exact match on param part). * Keep iterating, as we can have early * params and __setups of same names 8( */ if (line[n] == \u0026#39;\\0\u0026#39; || line[n] == \u0026#39;=\u0026#39;) had_early_param = true; } else if (!p-\u0026gt;setup_func) { pr_warn(\u0026#34;Parameter %s is obsolete, ignored\\n\u0026#34;, p-\u0026gt;str); return true; } else if (p-\u0026gt;setup_func(line + n)) return true; } p++; } while (p \u0026lt; __setup_end); return had_early_param; }     'use strict'; var containerId = JSON.parse(\"\\\"998e013071dd5335\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  등록 과정의 예시를 보면, 매크로의 시작 부분에는 어떤 문자열로 시작하는 파라미터인지, (ex. \u0026quot;root=\u0026quot;, \u0026quot;rootwait\u0026quot;, \u0026quot;earlycon\u0026quot;) 해당 파라미터를 받았을때 어떤 식으로 처리할지에 대한 함수를 정의하고 그 함수를 연결하고 있다.\n순회하는 함수의 경우, 이전 .init.setup 섹션 부분의 시작과 끝 주소를 __setup_start, __setup_end에 할당한 것을 확인할 수 있다. 그리고 .init.setup의 시작 주소부터, 포인터로 하나씩 옮겨가며 반복문으로 기존 등록된 struct obs_kernel_param 구조체들을 순회한다. 먼저 parameqn()으로 현재 입력받은 커널 파라미터를 (정확히는 스페이스 단위로 분리한 토큰) 현재 순회하는 파라미터 핸들러와 비교해서 일치한다면, 핸들러 함수에 남은 문자열 부분을 전달한다.\n호출된 핸들러 함수에서는 자체적으로 처리가 완료되면 1을, 자체적으로 처리가 안되면 0을 반환한다.\n여기까지 분석한 부분이 iamroot 스터디를 진행하면서 알게 된 부분이자, 내가 기여한 부분을 이해하기 위한 기초 지식이다.\n예외 처리가 필요한 커널 파라미터 핸들러  호출된 핸들러 함수에서는 자체적으로 처리가 완료되면 1을, 자체적으로 처리가 안되면 0을 반환한다.\n 이 문장이 기여한 부분의 핵심이다. 대표적으로 이런 상황을 일으키는 커널 파라미터 설명과 함께 확인해보자.\n일반적으로 사용하는 커널 파라미터 중 ro, root=, rootwait가 있는데, 각각에 대한 커널 파라미터의 설명은 아래와 같다.\n  ro [KNL] Mount root device read-only on boot root= [KNL] Root filesystem See name_to_dev_t comment in init/do_mounts.c. rootwait [KNL] Wait (indefinitely) for root device to show up. Useful for devices that are detected asynchronously (e.g. USB and MMC devices).   커널이 초기화를 끝내고, init 프로세스를 시작하기 전에 initramfs, initrd등을 사용하여 실제 파일 시스템 이전의 램 디스크를 사용하고, init에서 실질적으로 사용할 rootfs의 디스크로 교체하는 것으로 알고 있는데, 이 과정에 관련된 부분을 설정하는 커널 파라미터들이라고 볼 수 있다.\n특히 해당 파라미터들을 예시로 드는 이유는, 모두 ro로 시작한다는 점이다. 순회하는 함수 obsolete_checksetup()의 내용을 보면, 각 등록된 커널 파라미터의 시작부분과 동일하다면(parameqn() 함수는 내부적으로 strncmp()나 memcmp()와 비슷하게 동작한다.) 핸들러 함수를 호출한다.\n앞에서 핸들러를 등록하기 위해선 __setup() 매크로를 사용했는데, 해당 매크로는 struct obs_kernel_param이 지정된 섹션에(.init.setup) 위치하도록 할 뿐, 각각의 순서를 정하지는 못한다. 해당 매크로 선언 순서나, 오브젝트 파일들을 링킹하는 순서에 따라 반영될 뿐, 각 핸들러의 등록 순서를 강제할 수 있는 부분은 없다.\n위 예시로 다루고 있는 ro, root=, rootwait의 핸들러 함수들을 다시 확인해보자.\nro 핸들러 함수 root= 핸들러 함수 rootwait 핸들러 함수  static int __init readonly(char *str) { if (*str) return 0; root_mountflags |= MS_RDONLY; return 1; }   static int __init root_dev_setup(char *line) { strlcpy(saved_root_name, line, sizeof(saved_root_name)); return 1; }   static int __init rootwait_setup(char *str) { if (*str) return 0; root_wait = 1; return 1; }     'use strict'; var containerId = JSON.parse(\"\\\"8b9f8ae644266e0d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  root=의 경우는 다른 커널 파라미터와 시작 부분이 겹치는 부분이 없어서 바로 1을 반환하지만, ro나 rootwait는 해당 파라미터 뒤에 어떤 글자라도 전달받았다면 해당 파라미터는 ro나 rootwait와 완전히 일치하지 않는 토큰을 전달받았다는 뜻이고, 아직 적절한 핸들러가 호출되지 않았을 수도 있으므로, 다른 핸들러를 돌려봐야 하므로 0을 반환한다.\n모든 커널 파라미터 핸들러 검사 모든 핸들러들이 이런 식으로 파라미터 시작 부분이 겹칠 때, 예외처리를 잘 하는지 모든 __setup()을 검색해서, 겹치는 부분을 확인해봤다.\n커널의 trace 기능에 tp_printk와 tp_printk_stop_on_boot 파라미터가 있는데, 아까 말한 예외 상황을 잘 잡지 못하는 것이 확인되었다.\n/kernel/trace/trace.c  static int __init set_tracepoint_printk(char *str) { if ((strcmp(str, \u0026#34;=0\u0026#34;) != 0 \u0026amp;\u0026amp; strcmp(str, \u0026#34;=off\u0026#34;) != 0)) tracepoint_printk = 1; return 1; } __setup(\u0026#34;tp_printk\u0026#34;, set_tracepoint_printk); static int __init set_tracepoint_printk_stop(char *str) { tracepoint_printk_stop_on_boot = true; return 1; } __setup(\u0026#34;tp_printk_stop_on_boot\u0026#34;, set_tracepoint_printk_stop);     'use strict'; var containerId = JSON.parse(\"\\\"227274e5b48c468a\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  보면 tp_printk는 tp_printk_stop_on_boot의 시작부분과 일치한다. 하지만 tp_printk_stop_on_boot의 경우에 대한 예외 처리를 하고 있지 않다. 직접 해당 파라미터를 넣어 실행시켜 본 결과, tp_printk_stop_on_boot의 핸들러가 먼저 수행되어 버그를 확인할 수 없던 것으로 보인다. (현재 빌드 과정에서는 뒤에 선언된 부분이 먼저 할당되는 상황으로 보인다.) 해당 핸들러의 선언 순서만 바꿔줘도 예상대로 tp_printk_stop_on_boot가 tp_printk 안에서 처리가 완료되어 정상적으로 옵션이 처리되지 않는 것을 확인할 수 있었다.\n패치 작성 아래와 같이 1차 패치를 작성했다.\n최초 전송한 패치 리뷰 내역  trace: param: fix tp_printk option related with tp_printk_stop_on_boot Kernel param \u0026#34;tp_printk_stop_on_boot\u0026#34; starts with \u0026#34;tp_printk\u0026#34; which is the exact as the other kernel param \u0026#34;tp_printk\u0026#34;. In compile \u0026amp; build process, It may not guaranteed that \u0026#34;tp_printk_stop_on_boot\u0026#34; always checked before \u0026#34;tp_printk\u0026#34;. (By swapping its __setup() macro order, it may not work as expected.) Some kernel params which starts with other kernel params consider this problem. See commit 745a600cf1a6 (\u0026#34;um: console: Ignore console= option\u0026#34;) or init/do_mounts.c:45 (setup function of \u0026#34;ro\u0026#34; kernel param) Kernel param \u0026#34;tp_printk\u0026#34; can be handled with its value(0 or off) or it can be handled without its value. (maybe it won\u0026#39;t effect anything) Fix setup function to ignore when the \u0026#34;tp_printk\u0026#34; becomes prefix of other kernel param. Signed-off-by: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; ---  kernel/trace/trace.c | 2 ++ 1 file changed, 2 insertions(+) diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c index c860f582b078..8611c1842a02 100644 --- a/kernel/trace/trace.c +++ b/kernel/trace/trace.c @@ -254,6 +254,8 @@ static int __init set_tracepoint_printk(char *str)  { if ((strcmp(str, \u0026#34;=0\u0026#34;) != 0 \u0026amp;\u0026amp; strcmp(str, \u0026#34;=off\u0026#34;) != 0)) tracepoint_printk = 1; + if (tracepoint_printk || *str) + return 0;  return 1; } __setup(\u0026#34;tp_printk\u0026#34;, set_tracepoint_printk); --   So, \u0026#34;tp_printk=1\u0026#34; will return 0. That is not correct. You want this to explicitly ignore the other parameter. if (*str == \u0026#39;_\u0026#39;) return 0; And it probably should be the first thing in the list. As we do not want to enable tp_printk just because tp_printk_stop_on_boot is set. It requires both: tp_printk tp_printk_stop_on_boot. So the above check needs to be the first thing the function does.     'use strict'; var containerId = JSON.parse(\"\\\"f271746df8be6871\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  내용을 확인해보면, tp_printk가 예외처리를 제대로 하지 않고 있으며, 이 부분을 ro 커널 파라미터 처리 방식이나 745a600cf1a6 패치처럼 예외처리를 해줘야 한다고 설명하고 아래와 같이 코드를 작성했다.\n리뷰에서는 지금 나의 패치 방식으로는 tp_printk=1 같은 실제 설정이 변경되지는 않지만, 적절한 파라미터가 들어옴에도 0을 반환하는 방식이 되므로, 차라리 tp_printk 뒤에 _ 등이 들어온다면 다른 파라미터 핸들러일 수도 있으니 그 경우에만 0을 반환하도록 수정할 것을 권고받았다.\n커밋 로그는 그대로 두고, 코드 수정사항만 추천대로 수정하고 보낸다는 것이, 너무 간단하고 신난 나머지 return 0에 세미콜론도 찍지 않고, 빌드로 확인도 안 해보고 바로 전송해버렸다. 제대로 테스트는 해봤냐고 혼나고, 이 예외 처리 코드에 대한 주석을 달 것을 추천받았다. 이번에는 빌드까지 제대로 확인해서 다시 패치를 전송했다.\n최종적으로 패치가 적용되기 전에 리뷰어가 커밋 로그를 좀 더 정돈했고, mainline에 반영되었다.\n최종 적용된 패치  tracing: Fix tp_printk option related with tp_printk_stop_on_boot The kernel parameter \u0026#34;tp_printk_stop_on_boot\u0026#34; starts with \u0026#34;tp_printk\u0026#34; which is the same as another kernel parameter \u0026#34;tp_printk\u0026#34;. If \u0026#34;tp_printk\u0026#34; setup is called before the \u0026#34;tp_printk_stop_on_boot\u0026#34;, it will override the latter and keep it from being set. This is similar to other kernel parameter issues, such as: Commit 745a600cf1a6 (\u0026#34;um: console: Ignore console= option\u0026#34;) or init/do_mounts.c:45 (setup function of \u0026#34;ro\u0026#34; kernel param) Fix it by checking for a \u0026#34;_\u0026#34; right after the \u0026#34;tp_printk\u0026#34; and if that exists do not process the parameter. Link: https://lkml.kernel.org/r/20220208195421.969326-1-jsyoo5b@gmail.com Signed-off-by: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; [ Fixed up change log and added space after if condition ] Signed-off-by: Steven Rostedt (Google) \u0026lt;rostedt@goodmis.org\u0026gt; ---  kernel/trace/trace.c | 4 ++++ 1 file changed, 4 insertions(+) diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c index c860f582b078..7c2578efde26 100644 --- a/kernel/trace/trace.c +++ b/kernel/trace/trace.c @@ -252,6 +252,10 @@ __setup(\u0026#34;trace_clock=\u0026#34;, set_trace_boot_clock);  static int __init set_tracepoint_printk(char *str) { + /* Ignore the \u0026#34;tp_printk_stop_on_boot\u0026#34; param */ + if (*str == \u0026#39;_\u0026#39;) + return 0; +  if ((strcmp(str, \u0026#34;=0\u0026#34;) != 0 \u0026amp;\u0026amp; strcmp(str, \u0026#34;=off\u0026#34;) != 0)) tracepoint_printk = 1; return 1; --     'use strict'; var containerId = JSON.parse(\"\\\"2ed56f33af56a8b9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  stable에도 적용되다 이전 패치는 문서화 도구에 불과해서인지 mainline에만 적용되었는데, 이번 패치의 경우 버그 수정이라 그런지, 혹시 내 패치가 stable에도 적용되지 않을까? 하는 기대가 있었다.\n다른 분을 통해 물어보니, stable의 경우 일반적인 패치의 경우 (특정 버전의 버그 수정이 아닌, mainline에 수정한 패치) 특별히 패치 반영을 요청할 필요 없이, 자체적으로 주요 패치를 반영한다고 한다.\n이후 아래와 같이 여러 개의 메일을 받았다. 내용은 나의 패치가 현재 관리되고 있는 stable 버전들에도 적용된다는 것이다. (longterm으로 알려진 4.4, 4.9, 4.14, 4.19 등과, 가장 마지막 stable 버전인 5.16까지)\n메일의 앞 부분 내용  This is a note to let you know that I\u0026#39;ve just added the patch titled tracing: Fix tp_printk option related with tp_printk_stop_on_boot to the 4.14-stable tree which can be found at: http://www.kernel.org/git/?p=linux/kernel/git/stable/stable-queue.git;a=summary The filename of the patch is: tracing-fix-tp_printk-option-related-with-tp_printk_.patch and it can be found in the queue-4.14 subdirectory. If you, or anyone else, feels it should not be added to the stable tree, please let \u0026lt;stable@vger.kernel.org\u0026gt; know about it.     'use strict'; var containerId = JSON.parse(\"\\\"bdc3a787be90f734\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  해당 메일 이전에도 [PATCH AUTOSEL ...] 같은 형태로 여러 메일이 왔었는데, 아마 CI 등을 통해 커밋 제목에 fix 등이 들어있다면 버그 수정으로 판단하여, 자동으로 stable에 반영되는 것 같다. 이 메일의 내용을 보면 알겠지만, 해당 패치가 stable에 적용되면 안되는 패치인 경우, 개별적으로 알려달라고 한다.\n","description":"","id":3,"section":"posts","tags":["커널","파라미터","trace"],"title":"내 두 번째 리눅스 커널 기여","uri":"https://devlog.jsyoo5b.net/ko/posts/linux-kernel/my-second-commit/"},{"content":" 본 글은 GoogleTest의 공식 문서를 번역한 것입니다. 원문은 여기서 확인하실 수 있습니다.\n현재 글은 2021년 6월 3일 형상을 기준으로 번역하였으므로 시간이 지남에 따라 원문과 차이가 있을 수 있습니다.\nThis post is translated version of GoogleTest User\u0026rsquo;s Guide webpage. You can check original post by link.\nCurrent translation is based on the version of June 3, 2021. So the contents may differ when time goes by.\n 본 문서에서는 GoogleTest에서 코드의 행동을 검증하기 위해 제공되는 단언문의 목록을 설명합니다. 아래 단언문들을 사용하려면 gtest/gtest.h헤더를 포함하면 됩니다.\n앞으로 설명할 대부분의 매크로는 EXPECT_나 ASSERT_의 형태로 제공됩니다. 단언문의 조건이 실패했을 때, EXPECT_ 계열의 매크로는 심각하지 않은 실패를 발생시키고, 현재 함수가 계속 실행되게 합니다. 반면 ASSERT_ 매크로는 심각한 실패를 발생시켜 현재 함수를 강제로 중지시킵니다.\n모든 단언문 매크로에 \u0026lt;\u0026lt; 연산자로 스트림하여 사용자 정의 실패 메시지를 추가할 수 있습니다. 아래 예시처럼 사용할 수 있습니다.\nEXPECT_TRUE(my_condition) \u0026lt;\u0026lt; \u0026#34;My condition is not true\u0026#34;; C 문자열과 string 객체를 포함하여 ostream으로 스트림할 수 있는 것들은 모두 단언문 매크로에 스트림 할 수 있습니다. 확장 문자열(wide string, Windows에서 UNICODE 환경이라면 wchar_t*, TCHAR*, std::wstring)를 매크로에 스트림한다면, 출력될 때 UTF-8로 변환되어 출력됩니다.\n명시적인 성공과 실패 본 문단에서 설명하는 단언문들은 값이나 표현식의 검사를 하지 않고 직접적으로 성공이나 실패를 발생시킵니다. 부울 논리식(Boolean expression) 대신 코드의 제어 흐름에 따라 테스트의 성공과 실패가 결정되는 상황에 사용하면 좋습니다. 예시는 아래와 같습니다.\nswitch(expression) { case 1: ... some checks ... case 2: ... some other checks ... default: FAIL() \u0026lt;\u0026lt; \u0026#34;We shouldn\u0026#39;t get here.\u0026#34;; } SUCCEED SUCCEED()\n위 매크로를 사용하여 성공을 발생시킵니다. 이 매크로를 사용한다고 해서 전체 테스트를 성공시키는 것이 아닙니다. 각 테스트가 실행되는 동안 단언문에서 실패가 발생하지 않아야 해당 테스트가 성공했다고 합니다.\n현재 SUCCEED 단언문은 사용자가 볼 수 있는 출력을 생성하지 않으며, 문서상으로만 존재하는 수준입니다. 하지만 우리는 추후 SUCCEED 단언문에 GoogleTest 출력 메시지를 추가할 예정입니다.\nFAIL FAIL()\n위 매크로를 사용하여 심각한 실패를 발생시킵니다. 현재 함수에서 즉각 반환하게 합니다.\n해당 단언문은 void로 반환하는 함수 안에서만 사용할 수 있습니다. 더 알고싶다면 단언문 배치하기를 참고하기 바랍니다.\nADD_FAILURE ADD_FAILURE()\n위 매크로를 사용하여 심각하지 않은 실패를 발생시킵니다. 실패 이후에도 현재 함수가 계속 동작할 수 있게 합니다.\nADD_FAILURE_AT ADD_FAILURE_AT(file_path, line_number)\n위 매크로를 사용하여 심각하지 않은 실패를 발생시킵니다. 실패 메시지에 파일 경로, 몇번째 줄 정보를 추가할 수 있습니다.\n일반화된 단언문 아래 단언문들은 일치자(matchers)를 통해 값을 검증할 수 있게 해줍니다.\nEXPECT_THAT EXPECT_THAT(value, matcher) ASSERT_THAT(value, matcher)\n위 단언문은 value가 일치자 matcher의 조건을 만족하는지 검증해줍니다.\n아래 예시를 보면, 문자열 value1이 \u0026quot;Hello\u0026quot;로 시작하는지 검증하고, value2가 정규표현식을 만족하는지, value3의 값이 5와 10 사이의 값인지 검증합니다.\n#include \u0026#34;gmock/gmock.h\u0026#34; using ::testing::AllOf; using ::testing::Gt; using ::testing::Lt; using ::testing::MatchesRegex; using ::testing::StartsWith; ... EXPECT_THAT(value1, StartsWith(\u0026#34;Hello\u0026#34;)); EXPECT_THAT(value2, MatchesRegex(\u0026#34;Line \\\\d+\u0026#34;)); ASSERT_THAT(value3, AllOf(Gt(5), Lt(10))); 위의 형식처럼 단언문에서 일치자를 활용하면, 마치 영어로 된 문장을 읽듯이 자연스럽게 테스트 코드를 작성할 수 있게 하며, 테스트 실패에 대해 자세한 정보를 알 수 있는 메시지를 생성합니다. 예를 들어, 위의 value1의 검증이 실패했다면, 아래와 유사한 실패 메시지가 나타날 것입니다.\nValue of: value1 Actual: \u0026#34;Hi, world!\u0026#34; Expected: starts with \u0026#34;Hello\u0026#34; GoogleTest는 일치자에 관련된 내부 라이브러리를 제공합니다. 심지어 여러분이 일치자를 직접 작성할 수도 있습니다. 일치자를 사용하여 EXPECT_THAT 단언문을 강력하게, 확장하여 사용할 수 있습니다.\nGoogleTest의 일치자 관련된 세부 사항은 일치자 참고 문서를 보길 바랍니다. 만약 일치자를 직접 작성하고자 한다면, 빠르게 일치자 작성하기 문단을 보길 바랍니다.\n이 단언문에 대한 아이디어는 Joe Walnes의 Hamcrest 프로젝트에서 JUnit 내부에 assertThat()을 추가한 것을 차용했습니다.\n부울 조건식(Boolean conditions) 아래 단언문들은 부울 조건식을 검사합니다.\nEXPECT_TRUE EXPECT_TRUE(condition) ASSERT_TRUE(condition)\n위 단언문은 논리 조건 condition이 참인지 검증합니다.\nEXPECT_FALSE EXPECT_FALSE(condition) ASSERT_FALSE(condition)\n위 단언문은 논리조건 condition이 거짓인지 검증합니다.\n값 비교 앞으로 다룰 단언문들은 두 값을 비교합니다. 단언문에 전달할 인자들은 단언문에서 하려는 비교가 가능한 객체여야 합니다. 만약 비교가 불가능한 객체라면 컴파일 오류가 발생할 것입니다.\n만약 전달 인자가 \u0026lt;\u0026lt; 연산자를 지원한다면, 각 단언문이 실패할 경우 해당 인자를 출력하기 위해 해당 연산자를 호출할 것입니다. 만약 연산자를 통한 출력이 지원되지 않는다면, GoogleTest는 각 전달 인자를 출력하기에 가장 좋은 방법을 찾습니다. 자세한 내용은 GoogleTest에게 값을 출력하는 방법을 가르쳐주기 문단을 보기 바랍니다.\n전달 인자들은 단 한번 평가(evaluate)됩니다. 그러므로 각 인자에 부수 효과가 발생해도 괜찮습니다. 하지만 평가 순서(evaluation order)는 정의되지 않았으므로 코드를 작성할 때 각 인자의 평가 순서에 종속되지 않게 코드를 작성해야 합니다.\n값 비교는 일반 문자열과 확장문자열 모두 적용 가능합니다. (string과 wstring)\n부동 소수점 숫자 비교 방법이나 반올림, 근사값 처리(rounding)로 인한 문제를 피하려면 부동 소수점 비교 단언문 문단을 참고하시기 바랍니다.\nEXPECT_EQ EXPECT_EQ(val1, val2) ASSERT_EQ(val1, val2)\n위 단언문은 val1==val2임을 검사합니다.\n포인터 일치 검사도 지원합니다. 만약 2개의 C 문자열을 비교한다면, 위 단언문은 두 변수가 같은 메모리 위치를 가지고 있는지 검증할 뿐, 해당 문자열의 내용이 같은지 검증하는 것이 아닙니다. C 문자열(const char* 등의 자료형)의 비교에는 EXPECT_STREQ를 사용하십시오.\n포인터의 값이 NULL인지 비교하려면, EXPECT_EQ(ptr, NULL) 대신 EXPECT_EQ(ptr, nullptr)를 사용해야 합니다.\nEXPECT_NE EXPECT_NE(val1, val2) ASSERT_NE(val1, val2)\n위 단언문은 val1!=val2 임을 검사합니다.\n포인터 일치 검사도 지원합니다. 만약 2개의 C 문자열을 비교한다면, 위 단언문은 두 변수가 서로 다른 메모리 위치를 가지고 있는지 검증할 뿐, 해당 문자열의 내용이 다른지 검증하는 것이 아닙니다. C 문자열(const char* 등의 자료형)의 비교에는 EXPECT_STRNE를 사용하십시오.\n포인터의 값이 NULL이 아닌지 비교하려면, EXPECT_NE(ptr, NULL) 대신 EXPECT_NE(ptr, nullptr)를 사용해야 합니다.\nEXPECT_LT EXPECT_LT(val1, val2) ASSERT_LT(val1, val2)\n위 단언문은 val1\u0026lt;val2 임을 검사합니다.\nEXPECT_LE EXPECT_LE(val1, val2) ASSERT_LE(val1, val2)\n위 단언문은 val1\u0026lt;=val2 임을 검사합니다.\nEXPECT_GT EXPECT_GT(val1, val2) ASSERT_GT(val1, val2)\n위 단언문은 val1\u0026gt;val2 임을 검사합니다.\nEXPECT_GE EXPECT_GE(val1, val2) ASSERT_GE(val1, val2)\n위 단언문은 val1\u0026gt;=val2 임을 검사합니다.\n문자열 비교 (C 문자열) 아래 단언문들은 두 C 문자열을 비교할 때 사용합니다. 만약 두 string 객체를 비교하고자 한다면, EXPECT_EQ나 EXPECT_NE를 샤용해야 합니다.\n이 단언문들은 확장 C 문자열(wchar_t*)도 지원합니다. 만약 두 확장 문자열의 비교가 실패한다면, 해당 값이 출력될 때는 UTF-8 문자열로 출력됩니다.\nC 문자열이 NULL인지 비교하고싶다면, EXPECT_EQ(c_string, nullptr) 나 EXPECT_NE(c_string, nullptr)를 사용해야 합니다.\nEXPECT_STREQ EXPECT_STREQ(str1, str2) ASSERT_STREQ(str1, str2)\n위 단언문은 두 C 문자열 str1과 str2의 내용이 같은지 검사합니다.\nEXPECT_STRNE EXPECT_STRNE(str1, str2) ASSERT_STRNE(str1, str2)\n위 단언문은 두 C 문자열 str1과 str2의 내용이 다른지 검사합니다.\nEXPECT_STRCASEEQ EXPECT_STRCASEEQ(str1, str2) ASSERT_STRCASEEQ(str1, str2)\n위 단언문은 두 C 문자열 str1과 str2의 내용이 같은지 검사합니다. (대소문자 무시)\nEXPECT_STRCASENE EXPECT_STRCASENE(str1, str2) ASSERT_STRCASENE(str1, str2)\n위 단언문은 두 C 문자열 str1과 str2의 내용이 다른지 검사합니다. (대소문자 무시)\n부동소수점 비교 아래 단언문들은 두 부동소수점 값을 비교합니다.\n반올림, 근사값 오류로 인해 두 부동소수점 값이 정확하게 일치하는 경우는 드물기 때문에 EXPECT_EQ는 사용하기 적합하지 않습니다. 일반적으로 부동소수점 비교 시 적절한 오차 범위에 대한 처리가 필요합니다.\nGoogleTest는 마지막 자리의 단위(ULPs, Units in the Last Place)를 이용한 기본적인 오차 범위를 지원하는 단언문을 지원합니다. 마지막 자리의 단위를 이용한 비교법을 자세히 알고 싶다면 부동소수점 숫자를 비교하는 방법 글을 읽어 보시기 바랍니다.\nEXPECT_FLOAT_EQ EXPECT_FLOAT_EQ(val1, val2) ASSERT_FLOAT_EQ(val1, val2)\n위 단언문은 두 float값 val1과 val2가 근사하게 같은지 비교합니다. (마지막 자리의 단위 4개 이하의 오차를 기준으로 판정)\nEXPECT_DOUBLE_EQ EXPECT_DOUBLE_EQ(val1, val2) ASSERT_DOUBLE_EQ(val1, val2)\n위 단언문은 두 double값 val1과 val2가 근사하게 같은지 비교합니다. (마지막 자리의 단위 4개 이하의 오차를 기준으로 판정)\nEXPECT_NEAR EXPECT_NEAR(val1, val2, abs_error) ASSERT_NEAR(val1, val2, abs_error)\n위 단언문은 부동소수점 값 val1과 val2의 차이가 절대값 abs_error이하인지를 확인합니다.\n예외 처리 단언문 아래 단언문들은 주어진 코드 조각이 예외를 발생시키는지, 발생시키지 않는지 검증합니다. 이 기능을 사용하려면 빌드 환경에서 예외 처리를 활성화 해야 합니다.\n아래 설명에서 테스트 인자로 전달되는 코드 조각은 여러 구문의 혼합(compound statement)일 수 있습니다. 아래 예시를 참고하시기 바랍니다.\nEXPECT_NO_THROW({ int n = 5; DoSomething(\u0026amp;n); }); EXPECT_THROW EXPECT_THROW(statement, exception_type) ASSERT_THROW(statement, exception_type)\n위 단언문은 코드 구문 statement에서 exception_type 자료형의 예외가 발생하는지 검증합니다.\nEXPECT_ANY_THROW EXPECT_ANY_THROW(statement) ASSERT_ANY_THROW(statement)\n위 단언문은 코드 구문 statement에서 자료형에 관계없이 예외가 발생하는지 검증합니다.\nEXPECT_NO_THROW EXPECT_NO_THROW(statement) ASSERT_NO_THROW(statement)\n위 단언문은 코드 구문 statement에서 예외가 발생하지 않는지 검증합니다.\n서술부 단언문 아래 단언문들은 복잡한 서술부에 대한 검증을 지원합니다. 기존 EXPECT_TRUE만 단독으로 사용했을 때와 달리 좀 더 명확한 실패 메시지를 출력할 수 있습니다.\nEXPECT_PRED* EXPECT_PRED1(pred, val1) EXPECT_PRED2(pred, val1, val2) EXPECT_PRED3(pred, val1, val2, val3) EXPECT_PRED4(pred, val1, val2, val3, val4) EXPECT_PRED5(pred, val1, val2, val3, val4, val5)\nASSERT_PRED1(pred, val1) ASSERT_PRED2(pred, val1, val2) ASSERT_PRED3(pred, val1, val2, val3) ASSERT_PRED4(pred, val1, val2, val3, val4) ASSERT_PRED5(pred, val1, val2, val3, val4, val5)\n위 단언문은 서술부 pred가 뒤이어 주어진 값들을 인자로 받았을 때 참인지 (true를 반환하는지) 검증합니다.\n전달 인자인 pred는 함수 혹은 함수자로서 그 인자의 개수가 각 매크로의 인자 개수와 같아야 합니다. 만약 해당 pred가 주어진 인자에 대해 true를 반환한다면 그 단언문이 성공한 것이며, 아닐 경우 실패로 취급합니다.\n만약 단언문이 실패한다면, 각 전달 인자의 값을 출력합니다. 모든 인자들은 언제나 각각 한번씩 평가됩니다.\n예시로 아래 코드를 보기 바랍니다.\n// Returns true if m and n have no common divisors except 1. bool MutuallyPrime(int m, int n) { ... } ... const int a = 3; const int b = 4; const int c = 10; ... EXPECT_PRED2(MutuallyPrime, a, b); // Succeeds EXPECT_PRED2(MutuallyPrime, b, c); // Fails 위 예시를 실행하면 첫 번째 단언문은 성공하고, 두 번째 단언문은 실패하며 아래와 같은 메시지를 남깁니다.\nMutuallyPrime(b, c) is false, where b is 4 c is 10 만약 주어진 서술부가 오버로딩 된 함수거나 템플릿 함수인 경우, 단언문 매크로는 그 중 어떤 함수를 사용해야 할 지 결정하지 못할 수도 있습니다. 이런 경우 어떤 함수를 사용할 지 알려주기 위해 명시적으로 함수의 자료형을 표현해야 합니다. 예를 들어 1개의 인자를 받는 부울 함수 IsPositive() 가 인자의 자료형이 int와 double에 대해 오버로딩 되었다면 아래와 같이 작성해야 합니다.\nEXPECT_PRED1(static_cast\u0026lt;bool (*)(int)\u0026gt;(IsPositive), 5); EXPECT_PRED1(static_cast\u0026lt;bool (*)(double)\u0026gt;(IsPositive), 3.14); 단순하게 EXPECT_PRED1(IsPositive, 5);와 같이 작성하면 컴파일 오류가 발생할 수 있습니다. 위와 비슷하게 템플릿 함수의 경우, 아래와 같이 템플릿의 자료형을 명시해야 합니다.\ntemplate \u0026lt;typename T\u0026gt; bool IsNegative(T x) { return x \u0026lt; 0; } ... EXPECT_PRED1(IsNegative\u0026lt;int\u0026gt;, -5); // Must specify type for IsNegative 만약 여러 인자를 사용하는 템플릿 함수의 경우, 해당 서술부를 괄호로 감싸서 매크로가 정확히 해석할 수 있도록 해야합니다.\nASSERT_PRED2((MyPredicate\u0026lt;int, int\u0026gt;), 5, 0); EXPECT_PRED_FORMAT* EXPECT_PRED_FORMAT1(pred_formatter, val1) EXPECT_PRED_FORMAT2(pred_formatter, val1, val2) EXPECT_PRED_FORMAT3(pred_formatter, val1, val2, val3) EXPECT_PRED_FORMAT4(pred_formatter, val1, val2, val3, val4) EXPECT_PRED_FORMAT5(pred_formatter, val1, val2, val3, val4, val5)\nASSERT_PRED_FORMAT1(pred_formatter, val1) ASSERT_PRED_FORMAT2(pred_formatter, val1, val2) ASSERT_PRED_FORMAT3(pred_formatter, val1, val2, val3) ASSERT_PRED_FORMAT4(pred_formatter, val1, val2, val3, val4) ASSERT_PRED_FORMAT5(pred_formatter, val1, val2, val3, val4, val5)\n위 단언문은 서술부 pred_formatter가 뒤이어 주어진 값들을 인자로 받았을 때 참인지 (true를 반환하는지) 검증합니다.\n전달 인자인 pred_formatter는 아래와 같은 함수 형식을 가진 서술부 형식 출력화기 (predicate-formatter) 입니다.\ntesting::AssertionResult PredicateFormatter(const char* expr1, const char* expr2, ... const char* exprn, T1 val1, T2 val2, ... Tn valn); 여기서 val1, val2, \u0026hellip;, valn은 서술부의 인자로 전달되는 값을 뜻하며, expr1, expr2, \u0026hellip;, exprn는 각 인자들이 소스 코드에 작성된 표현식을 나타냅니다. 각 자료형인 T1, T2, \u0026hellip;, Tn는 일반 값 자료형 뿐만 아니라 레퍼런스 자료형이 될 수도 있습니다. 만약 전달 인자의 자료형이 T 일때, 해당 자료형을 적합한 상황에 따라 T 혹은 const T\u0026amp;로 선언할 수 있습니다. 반환 자료형인 testing::AssertionResult에 대해 더 알고싶다면 AssertionResult를 반환하는 함수 활용하기 문단을 참고하시기 바랍니다.\n예시로 아래 코드를 보기 바랍니다.\n// Returns the smallest prime common divisor of m and n, // or 1 when m and n are mutually prime. int SmallestPrimeCommonDivisor(int m, int n) { ... } // Returns true if m and n have no common divisors except 1. bool MutuallyPrime(int m, int n) { ... } // A predicate-formatter for asserting that two integers are mutually prime. testing::AssertionResult AssertMutuallyPrime(const char* m_expr, const char* n_expr, int m, int n) { if (MutuallyPrime(m, n)) return testing::AssertionSuccess(); return testing::AssertionFailure() \u0026lt;\u0026lt; m_expr \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; n_expr \u0026lt;\u0026lt; \u0026#34; (\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;) are not mutually prime, \u0026#34; \u0026lt;\u0026lt; \u0026#34;as they have a common divisor \u0026#34; \u0026lt;\u0026lt; SmallestPrimeCommonDivisor(m, n); } ... const int a = 3; const int b = 4; const int c = 10; ... EXPECT_PRED_FORMAT2(AssertMutuallyPrime, a, b); // Succeeds EXPECT_PRED_FORMAT2(AssertMutuallyPrime, b, c); // Fails 위의 예시에서, 마지막 단언문은 실패할것이며, 서술부 형식 출력기가 아래와 같은 메시지를 남깁니다.\nb and c (4 and 10) are not mutually prime, as they have a common divisor 2 Windows HRESULT 단언문 아래 단언문들은 HRESULT의 성공 혹은 실패 여부를 검증합니다. 아래 예시를 참고하기 바랍니다.\nCComPtr\u0026lt;IShellDispatch2\u0026gt; shell; ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L\u0026#34;Shell.Application\u0026#34;)); CComVariant empty; ASSERT_HRESULT_SUCCEEDED(shell-\u0026gt;ShellExecute(CComBSTR(url), empty, empty, empty, empty)); 위 단언문은 HRESULT 반환 값의 의미에 따라 사람이 쉽게 읽을 수 있는 오류 메시지를 출력합니다.\nEXPECT_HRESULT_SUCCEEDED EXPECT_HRESULT_SUCCEEDED(expression) ASSERT_HRESULT_SUCCEEDED(expression)\n위 단언문은 expression이 성공한 HRESULT를 반환하는지 검증합니다.\nEXPECT_HRESULT_FAILED EXPECT_HRESULT_FAILED(expression) EXPECT_HRESULT_FAILED(expression)\n위 단언문은 expression이 실패한 HRESULT를 반환하는지 검증합니다.\n종료 단언문 아래 단언문들은 주어진 코드 조각이 프로세스를 종료시키는지 검증합니다. 이 테스트에 대한 자세한 내용은 종료 테스트 문단을 참고하시기 바랍니다.\n이 단언문들은 테스트 시 새로운 프로세스를 생성하여 주어진 코드를 실행합니다. 종료테스트의 동작 원리는 동작 플랫폼의 종류에 따라 결정됩니다. 명령행 인자 --gtest_death_test_style로 전달한 설정 ::testing::GTEST_FLAG(death_test_style) 변수 값도 동작 방식에 영향을 줍니다.\n POSIX 시스템에서 fork() (혹은 Linux에서 clone()) 으로 자식을 생성합니다.  만약 ::testing::GTEST_FLAG(death_test_style)의 값이 \u0026quot;fast\u0026quot;인 경우, 종료 테스트 구문은 즉시 실행됩니다. 만약 ::testing::GTEST_FLAG(death_test_style)의 값이 \u0026quot;threadsafe\u0026quot;인 경우, 자식 프로세스는 현재 단위 테스트 실행파일이 실행된 방식과 동일하게 다시 실행합니다. 이 때 일부 설정을 추가하여 종료 테스트가 동시에 하나만 실행될 수 있도록 합니다.   Windows에서는 CreateProcess() API를 통해 자식 프로세스가 생성됩니다. POSIX 시스템에서 \u0026quot;threadsafe\u0026quot; 모드로 실행한 것과 같이 동작합니다. (현재 실행파일을 다시 실행하여 종료 테스트가 동시에 하나만 실행될 수 있도록)  ::testing::GTEST_FLAG(death_test_style)의 기본 값은 \u0026quot;fast\u0026quot;이며, 위에서 설명하지 않은 값으로 설정될 경우, 종료 테스트를 실패하게 합니다.\n만약 종료 테스트 구문이 종료되지 않고 정상적으로 실행되더라도, 자식 프로세스는 결국에는 종료될 것이며 해당 단언문은 실패한 것으로 간주됩니다.\n아래 설명에서 테스트 인자로 전달되는 코드 조각은 여러 구문의 혼합(compound statement)일 수 있습니다. 아래 예시를 참고하시기 바랍니다.\nEXPECT_DEATH({ int n = 5; DoSomething(\u0026amp;n); }, \u0026#34;Error on line .* of DoSomething()\u0026#34;); EXPECT_DEATH EXPECT_DEATH(statement, matcher) ASSERT_DEATH(statement, matcher)\n위 단언문은 구문 statement가 프로세스를 0이 아닌 종료상태로 종료시키는지, 그리고 stderr로 출력하는 결과가 일치자 matcher의 조건을 만족하는지 검증합니다.\n전달 인자인 matcher는 const std::string\u0026amp;에 대한 일치자 혹은 정규표현식이어야 합니다. (정규표현식 문법 참고) 그냥 문자열 s(일치자 없이)는 Eq(s)가 아니라 ContainsRegex(s)로 취급됩니다.\n예를 들어 아래 코드는 DoSomething(42)를 호출하면 프로세를 종료시키면서, My error라는 문구를 포함한 오류 메시지를 출력하는지 검증합니다.\nEXPECT_DEATH(DoSomething(42), \u0026#34;My error\u0026#34;); EXPECT_DEATH_IF_SUPPORTED EXPECT_DEATH_IF_SUPPORTED(statement, matcher) ASSERT_DEATH_IF_SUPPORTED(statement, matcher)\n위 단언문은 종료 테스트가 지원되는 경우 EXPECT_DEATH와 동일한 역할을 합니다. 종료 테스트가 지원되지 않는다면 아무 일도 일어나지 않습니다.\nEXPECT_DEBUG_DEATH EXPECT_DEBUG_DEATH(statement, matcher) ASSERT_DEBUG_DEATH(statement, matcher)\n위 단언문은 디버그 모드에서 EXPECT_DEATH와 동일한 역할을 합니다. 만약 디버그 모드가 아니라면 (예를 들어 NDEBUG가 정의됨) 구문 statement만 그냥 실행함.\nEXPECT_EXIT EXPECT_EXIT(statement, predicate, matcher) ASSERT_EXIT(statement, predicate, matcher)\n위 단언문은 구문 statement가 predicate의 조건을 만족하는 종료 상태로 종료시키는지, 그리고 stderr로 출력하는 결과가 일치자 matcher의 조건을 만족하는지 검증합니다.\n전달 인자 predicate는 int 종료 상태를 인자로 입력받아 bool을 반환하는 함수 혹은 함수자입니다. GoogleTest에서는 일반적인 경우에 사용할 만한 두가지 서술부를 제공합니다.\n// Returns true if the program exited normally with the given exit status code. ::testing::ExitedWithCode(exit_code); // Returns true if the program was killed by the given signal. // Not available on Windows. ::testing::KilledBySignal(signal_number); 전달 인자인 matcher는 const std::string\u0026amp;에 대한 일치자 혹은 정규표현식이어야 합니다. (정규표현식 문법 참고) 그냥 문자열 s(일치자 없이)는 Eq(s)가 아니라 ContainsRegex(s)로 취급됩니다.\n예를 들어 아래 코드는 NormalExit()을 호출하면 stderr에 Success가 포함된 메시지를 출력하면서, 종료상태 0으로 프로세스를 종료시키는지 검증합니다.\nEXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), \u0026#34;Success\u0026#34;); 번역 관련 주석 (원문에 존재하지 않음) 원문과 번역한 단어의 목록은 다음과 같습니다. (그대로 음차한 번역은 생략합니다.) 익숙하지 않은 표현이거나, 오해의 가능성이 있는 번역의 경우, 처음 해당 표현이 나온 부분에 원문을 추가로 작성했습니다.\n   원문 번역 비고     Assertion 단언문 Wiki에서는 표명으로 번역됨, 단언문이 더 직관적이라 생각하여 번역함   Binary comparison 값 비교 직역하면 이진 비교지만, 해당 단어가 나온 문단에서는 이진수로 표현 가능한 값(정수, 문자, 문자열)에 대한 비교이므로 값 비교로 의역함   Death 종료 Death test의 목적이 코드를 실행했을 때, 해당 프로세스가 종료되는지 검사하는 것이므로, 종료로 의역함   Error 오류/오차 컴파일 등의 상황에서는 오류로 번역하였으나, 부동소수점 비교의 경우 오차를 의미하므로 각 의도에 맞게 번역함   Evaluation 평가 프로그래밍 언어론에서 말하는 Evaluation order의 일부로, 다른 공식 문서에는 평가 순서 등으로 번역된 것을 차용함   Fatal 심각한 치명적인으로 번역했으나, 문맥상 심각한이 더 자연스러운 것으로 판단하여 이와 같이 번역함   Functor 함수자 괄호 연산자 (operator())를 오버로딩한 클래스의 객체를 뜻함. 함수형 프로그래밍이나 STL의 일반적인 번역인 함수자를 차용함   Matcher 일치자 원문의 내용으로 보아 String Pattern Matcher 를 줄인 것으로 보임. 문자열 일치라는 표현이 Match의 번역임을 고려하여 번역함   Predicate 서술부 사전에 따라 단정하다를 고려했으나, Assertion의 번역인 단언과 유사한데다, 표현의 의도가 복잡한 논리식이므로 서술부로 번역함   Statement 구문 프로그래밍 언어론에서 말하는 문장, 문을 의미하며, 번역 문맥상의 이해를 돕기 위해 구문으로 번역함   Test fixture 테스트 고정부 소프트웨어 개발자 테스팅의 번역을 인용함   Test suite 테스트 모음 같은 설계를 가지면서 값을 공유할 수 있는 프로그램의 집합의 의미에서 모음으로 번역함   Unit in the Last Place 마지막 자리의 단위 부동소수점 값을 정수형처럼 읽었을 때 최소 비트의 차이를 뜻함. 해커의 기쁨의 번역을 인용함   Wide string 확장 문자열 Wiki의 확장 문자문서를 참고하여 번역함    ","description":"","id":4,"section":"posts","tags":["GoogleTest"],"title":"GoogleTest User's Guide: 단언문 참고","uri":"https://devlog.jsyoo5b.net/ko/posts/googletest/userguide-translate/reference/assertions/"},{"content":" 본 글은 GoogleTest의 공식 문서를 번역한 것입니다. 원문은 여기서 확인하실 수 있습니다.\n현재 글은 2021년 8월 4일 형상을 기준으로 번역하였으므로 시간이 지남에 따라 원문과 차이가 있을 수 있습니다.\nThis post is translated version of GoogleTest User\u0026rsquo;s Guide webpage. You can check original post by link.\nCurrent translation is based on the version of August 4, 2021. So the contents may differ when time goes by.\n 서론: 왜 GoogleTest인가? GoogleTest 를 통해 더 나은 C++ 테스트를 작성할 수 있습니다.\nGoogleTest는 Testing Technology 팀에서 개발한 테스트 프레임워크로서, 구글의 특정한 요구사항과 제약 조건을 염두하여 개발된 프레임워크입니다. 여러분이 C++로 코드 작성을 하고 있다면, (환경이 Linux던, Windows나 Mac이던 관계 없이) GoogleTest가 도움을 줄 수 있습니다. 또한 GoogleTest는 단위 테스트 뿐만 아니라 모든 종류의 테스트를 지원합니다.\n그렇다면 무엇이 좋은 테스트고, GoogleTest는 어떻게 이걸 가능케 할까요? 우리는 이렇게 생각했습니다.\n 테스트는 독립적 이고 반복적 일수 있어야 합니다.\n다른 테스트의 결과에 영향을 받아서 성공 혹은 실패하는 테스트를 디버깅하기란 어렵습니다.\nGoogleTest는 각 테스트를 다른 객체에 격리하여 실행합니다.\n만약 어떤 테스트가 실패하더라도, GoogleTest는 해당 테스트만 독립적으로 실행하여 디버깅을 빨리 할 수 있게 해줍니다. 테스트는 테스트 대상이 될 코드의 구조를 반영하고, 잘 구성되어야 합니다.\nGoogleTest는 관련된 테스트들을 test suite로 묶어서 데이터와 서브루틴을 공유할 수 있습니다.\n이러한 일반적인 패턴은 테스트를 쉽게 이해하고, 테스트의 관리를 쉽게 합니다.\n일관성은 특히 사람들이 프로젝트를 변경하여 새로운 코드 기반에서 일할 때 도움을 줍니다. 테스트는 이식성 이 있어야 하며, 재사용 가능해야합니다.\n구글은 플랫폼 중립적인 코드를 많이 가지고 있습니다. 그리고 이 코드들의 테스트 또한 플랫폼 중립적이어야 합니다.\nGoogleTest는 다른 운영체제, 다른 컴파일러, 예외 처리의 지원 여부와 관계 없이 동작합니다.\n즉, GoogleTest를 통해 다양한 환경(구성)에서 테스트를 할 수 있습니다. 만약 테스트가 실패한다면, 해당 문제에 대해 가능한 많은 정보 를 제공해야 합니다.\nGoogleTest는 첫 테스크가 실패했다고 멈추지 않습니다. 대신 현재 테스트만 멈추고, 다음 테스트를 계속 진행합니다.\n또한 각 테스트에서 심각하지 않은 실패의 경우, 해당 실패 여부만 기록하고 테스트를 계속 진행할 수도 있습니다.\n결론적으로 여러분은 한번의 실행-수정-컴파일 순환만으로도 여러 버그를 찾고 수정할 수 있습니다. 테스팅 프레임워크는 테스트 작성자들이 잡무로부터 해방되고, 테스트의 내용 에 집중할 수 있게 해야 합니다.\n구글 테스트는 모든 정의된 테스트 목록을 추적하며, 사용자가 각 테스트들을 실행하기 위해 직접 나열하지 않아도 되게 도와줍니다. 테스트는 빠르게 진행되어야 합니다.\n여러분은 구글 테스트를 통해 set-up/tear-down(테스트를 위한 자원 설정 및 해제) 한번으로 테스트 간의 자원을 재사용 및 공유할 수 있습니다.\n(물론 테스트 간의 의존성을 만들지 않습니다.)  GoogleTest는 인기있는 xUnit 구조를 기반으로 만들어졌기 때문에, 여러분이 JUnit이나 PyUnit을 이전에 사용해봤다면 익숙하실 것입니다. 만약 익숙하지 않더라도 10분정도면 기초를 배우고 새로 시작하는데 충분할 것입니다. 시작해봅시다!\n명명법에 대한 주의사항  테스트(Test), 테스트 케이스(Test Case), 테스트 모음(Test Suite) 의 정의가 달라 혼란스러울 수 있으니 주의 바랍니다.\n 이전부터 GoogleTest는 관련된 테스트들을 묶은 것을 테스트 케이스 라고 정의했습니다. 반면 ISTQB(International Software Testing Qualifications Board)의 자료 등의 문서나, 소프트웨어 품질 관련 다양한 책에서는 이 개념을 테스트 모음 으로 정의합니다.\n위와 관련된 단어로, GoogleTest에서 테스트 라 부르는 용어는 ISTQB 등에서는 테스트 케이스 로 정의합니다.\n테스트 란 용어는 일반적으로 ISTQB에서 정의한 테스트 케이스 를 포함하여 충분히 넓은 의미를 가진 단어이므로 크게 문제되지 않습니다. 하지만 GoogleTest에서 사용되었던 테스트 케이스 는 모순된 의미로 혼동을 줄 수 있습니다.\n최근 GoogleTest에서도 테스트 케이스 란 용어를 테스트 모음 으로 변경하고 있습니다. 이전의 TestCase API는 천천히 사장되거나 TestSuite API로 리팩토링되고 있습니다.\n그러므로 아래 용어의 정의에 대해 주의하시기 바랍니다.\n   의미 GoogleTest 용어 ISTQB 용어     특정 프로그램을 지정된 입력값으로 실행하여 결과를 검증 TEST() Test Case    기본 개념 GoogleTest를 사용한다면, 주어진 조건이 참인지 확인하기 위해 단언문(assertion) 을 작성하는 것으로 시작하게 될 것입니다. 단언문의 결과는 성공(success), 심각하지 않은 실패(nonfatal failure) 혹은 심각한 실패(fatal failure) 중 하나입니다. 만약 심각한 실패가 발생한다면 현재 함수를 중지시킵니다. 이를 제외한 나머지는 프로그램을 정상적으로 계속 실행합니다.\n테스트 는 단언문을 통해 테스트 할 코드의 행동을 검증합니다. 만약 테스트 중 충돌이 발생하거나 실패한 단언문이 있다면 해당 테스트는 실패 한 것입니다. 만약 그런 문제가 없었다면 해당 테스트는 성공 한 것입니다.\n테스트 모음 은 한개 혹은 그 이상의 테스트를 갖고 있습니다. 테스트 할 코드의 구조를 반영하여 테스트들을 적절한 테스트 모음으로 묶는 것이 좋습니다. 만약 테스트 모음에 속한 여러 테스트들이 공통적인 객체나 서브루틴(함수)를 사용해야 한다면, 공통된 부분을 테스트 고정부(Test Fixture) 클래스에 넣을 수 있습니다.\n테스트 프로그램 은 여러 테스트 모음을 가질 수 있습니다.\n이제 테스트 프로그램을 작성하는 방법을 알려드릴 것입니다. 개별적인 단언문 수준부터 시작하여, 테스트와 테스트 모음을 만드는 법 까지 다룰 것입니다.\n단언문 GoogleTest의 단언문은 함수 호출을 닮은 매크로입니다. 클래스나 함수의 동작에 대한 단언문을 작성하여 테스트를 할 수 있습니다. 만약 단언문을 통과하지 못하면 GoogleTest에서 해당 단언문의 소스 파일 이름, 몇 번째 줄에 있는 단언문인지, 실패에 대한 추가 정보를 가진 메시지를 출력합니다. GoogleTest의 실패 정보 출력에 덧붙여 나올 사용자 정의 메시지를 직접 작성할 수도 있습니다.\n단언문은 같은 테스트를 하지만 결과가 달라지는 두가지 형태가 제공됩니다. ASSERT_*() 방식은 실패시 심각한 실패를 발생시키고, 현재 함수를 중지합니다. EXPECT_*() 방식은 심각하지 않은 실패를 발생시키며, 현재 함수를 중지시키지 않습니다. 테스트에서 한개 이상의 실패를 보고받을수 있기 때문에 대부분 EXPECT_*()를 선호하는 편입니다. 하지만 단언문의 실패 이후에 동작이 유지되는 것이 부적절하다면, ASSERT_*()를 사용해야 합니다.\nASSERT_*()에서 실패하면 현재 함수에서 즉시 반환하므로 해당 단언문 이후에 처리되는 정리 코드들이 생략될 수 있으며, 공간 낭비(메모리 누수)를 일으킬 수도 있습니다. 해당 공간 낭비의 특성에 따라 수정이 필요할 수도 있지만, 수정할 만한 가치가 없을 수도 있습니다. 혹시나 힙 영역의 누수를 확인하는 도구를 사용할 때, 이런 실패 과정에서 누수가 발생하는 것이 감지될 수도 있으므로 해당 부분을 항상 생각하는 것이 좋습니다.\n단언문에 실패에 대한 사용자 정의 메시지를 추가하려면, 단언문 매크로에 \u0026lt;\u0026lt; 연산자를 통해 스트림을 전달하면 됩니다. (해당 연산자를 여러번 사용하여 여러 번의 스트림 전달도 가능합니다.) 아래 예시를 보면 ASSERT_EQ()과 EXPECT_EQ() 매크로를 사용하여 값의 일치 여부를 검증하고 있습니다.\nASSERT_EQ(x.size(), y.size()) \u0026lt;\u0026lt; \u0026#34;Vectors x and y are of unequal length\u0026#34;; for (int i = 0; i \u0026lt; x.size(); ++i) { EXPECT_EQ(x[i], y[i]) \u0026lt;\u0026lt; \u0026#34;Vectors x and y differ at index \u0026#34; \u0026lt;\u0026lt; i; } C 문자열과 string 객체를 포함하여 ostream으로 스트림할 수 있는 것들은 모두 단언문 매크로에 스트림 할 수 있습니다. 확장 문자열(wide string, Windows에서 UNICODE 환경이라면 wchar_t*, TCHAR*, std::wstring)를 매크로에 스트림한다면, 출력될 때 UTF-8로 변환되어 출력됩니다.\nGoogleTest는 여러 방법으로 여러분의 코드를 검증하게 해 줄 단언문들을 제공합니다. 부울 논리 조건(Boolean conditions), 비교 연산자를 통한 값 비교, 문자열 검증, 부동소수점 값 비교 등을 할 수 있습니다. 심지어 사용자 지정 서술부(predicate)를 사용하여 더 복잡한 상태를 검증하는 것도 가능하게 합니다. GoogleTest가 제공하는 모든 단언문의 목록을 보려면 단언문 참고를 참고하길 바랍니다.\n간단한 테스트 테스트를 작성하는 법은 아래와 같습니다.\n TEST() 매크로를 통해 테스트 함수를 정의하고 이름을 붙입니다. 테스트 함수는 값을 반환하지 않는 일반적인 C++ 함수입니다. 테스트 함수 내에서, 유효한 C++ 구문을 모두 사용할 수 있으며, 다양한 GoogleTest 단언문을 통해 값을 확인할 수 있습니다. 테스트의 결과는 단언문에 의해 결정됩니다. 만약 함수 내 단언문 중 하나라도 실패하거나(심각성 여부와 관계 없이), 테스트 실행 중 충돌이 발생한다면 해당 태스트는 실패합니다. 실패가 발생하지 않았다면 해당 테스트는 성공입니다.  TEST(TestSuiteName, TestName) { ... test body ... } TEST()의 인자는 일반화에서 구체화 방식으로 입력합니다. 첫 번째 인자에는 테스트 모음의 이름을, 두 번째 인자에는 테스트 모음 내 해당 테스트의 이름을 작성합니다. 두 이름 모두(TEST()의 인자) 언더바(_)를 포함하지 않으면서 유효한 C++ 식별자여야 합니다. 한 테스트의 정식 명칭은 테스트 모음의 이름과 개별적인 이름의 조합으로 이루어집니다. 개별적인 이름은 테스트 모음이 다르다면 똑같은 이름이 존재할 수도 있습니다.\n예를 들어, 아래와 같이 간단한 정수 함수가 있다고 했을 때,\nint Factorial(int n); // Returns the factorial of n 해당 함수를 위한 테스트 모음은 이렇게 작성될 수 있습니다.\n// Tests factorial of 0. TEST(FactorialTest, HandlesZeroInput) { EXPECT_EQ(Factorial(0), 1); } // Tests factorial of positive numbers. TEST(FactorialTest, HandlesPositiveInput) { EXPECT_EQ(Factorial(1), 1); EXPECT_EQ(Factorial(2), 2); EXPECT_EQ(Factorial(3), 6); EXPECT_EQ(Factorial(8), 40320); } GoogleTest는 테스트 모음 단위로 테스트 결과를 묶습니다. 그러므로 논리적으로 서로 관계 있는 테스트들은 하나의 테스트 모음에 같이 담겨 있어야 합니다. 즉, TEST()의 첫 번째 인자는 같아야 합니다. 위의 예시를 보면, HandleZeroInput과 HandlePositiveInput 두 개의 테스트는 FactorialTest 테스트 모음에 속해있는 것을 볼 수 있습니다.\n테스트 모음과 테스트 이름을 지을때, 함수와 클래스의 작명법 규정을 따르는 것이 좋습니다.\n사용 가능 환경: Linux, Windows, Mac.\n테스트 고정부: 여러 테스트에 같은 설정 사용하기 만약 테스트를 작성하던 중 둘 이상의 테스트가 비슷한 값으로 테스트를 한다면, 테스트 고정부 를 활용할 수 있습니다. 테스트 고정부를 통해 동일한 객체의 설정을 서로 다른 테스트에서 재사용할 수 있습니다.\n고정부를 만드는 방법은 아래와 같습니다.\n ::testing::Test 클래스로부터 상속을 받습니다. 클래스 내부는 protected:로 시작하여, 자식 클래스가 고정부 클래스의 멤버를 접근할수 있게 합니다. 클래스 내부에 본인이 사용하고자 하는 객체를 선언합니다. 필요하다면, 기본 생성자 혹은 SetUp() 함수를 작성하여 각 테스트를 위한 객체의 상태를 준비할 수 있습니다.\n자주 하는 실수 중, SetUp() 함수 정의에서 대소문자 구분을 확실히 하지 못하는 경우가 있습니다.\n만약 C++11이라면 override 키워드를 사용하면 오타 여부를 확실히 알 수 있습니다. 필요하다면, 소멸자나 TearDown() 함수를 작성하여 이전 SetUp() 함수에서 할당했던 자원들을 해제할 수 있습니다.\n어떤 경우에 생성자/소멸자를 사용해야 하는지, 혹은 SetUp()/TearDown() 함수를 사용해야 하는지 궁금하다면, FAQ를 읽어보길 바랍니다. 필요하다면, 테스트 내에서 공유될 서브루틴을 정의할 수 있습니다.  테스트 고정부를 사용한다면, 기존 테스트 작성에 사용하던 매크로인 TEST() 대신 TEST_F()를 사용해야 고정부 내부에 정의된 객체와 서브루틴을 사용할 수 있습니다.\nTEST_F(TestFixtureName, TestName) { ... test body ... } TEST() 매크로를 사용할 때 처럼, 첫 번째 인자는 테스트 모음의 이름을 나타냅니다. 다만 TEST_F()에 넣는 테스트 모음 이름은 테스트 고정부 클래스의 이름과 같아야 합니다. 예상했겠지만, 매크로에 추가된 _F라는 표현은 고정부를 뜻합니다.\n안타깝게도 C++의 매크로에서는 단일 매크로를 이용해 두 종류의 테스트를 알아서 생성할 수 없습니다. (기존 TEST()를 사용하는 테스트와, TEST_F()를 사용하는 테스트) 매크로를 잘못 사용한다면 컴파일 에러가 발생할 수 있습니다.\n코드 작성에 있어 테스트 고정부 클래스의 정의가 끝난 뒤 TEST_F() 매크로에서 테스트 고정부 클래스를 사용해야 합니다. 만약 이 순서를 지키지 않는다면 \u0026ldquo;virtual outside class declaration\u0026ldquo;와 같은 컴파일 오류를 보게 될 것입니다.\nTEST_F()를 통해 테스트가 정의되었다면, GoogleTest에서 새로운 테스트 고정부를 런타임에 생성하고, SetUp()을 통해 즉시 초기화하고, 테스트를 수행한 뒤, TearDown()을 통해 정리하고 해당 테스트 고정부 객체를 삭제할 것입니다. 한 테스트 모음에 있는 다른 테스트들은 개별적인 테스트 고정부 객체를 갖게 됩니다. GoogleTest는 언제나 기존 테스트 고정부 객체를 삭제하고 나서야 새로운 테스트 고정부 객체를 생성합니다. 또한 테스트 고정부 객체는 여러 테스트에서 재활용되지 않습니다. 특정 테스트에서 테스트 고정부에 일으킨 변화는 다른 테스트에 영향을 주지 않도록 되어있습니다.\n이제 예시로 Queue라는 선입선출 큐 클래스에 대한 테스트를 작성하는 경우를 보겠습니다. 해당 클래스의 인터페이스는 아래와 같습니다.\ntemplate \u0026lt;typename E\u0026gt; // E is the element type. class Queue { public: Queue(); void Enqueue(const E\u0026amp; element); E* Dequeue(); // Returns NULL if the queue is empty.  size_t size() const; ... }; 먼저 고정부 클래스를 정의하겠습니다. 일반적으로 Foo라는 클래스를 테스트한다면, 고정부 클래스의 이름은 FooTest로 짓습니다.\nclass QueueTest : public ::testing::Test { protected: void SetUp() override { q1_.Enqueue(1); q2_.Enqueue(2); q2_.Enqueue(3); } // void TearDown() override {}  Queue\u0026lt;int\u0026gt; q0_; Queue\u0026lt;int\u0026gt; q1_; Queue\u0026lt;int\u0026gt; q2_; }; 위의 예시에서 각 테스트가 끝날 때 마다 굳이 정리해야 할 필요가 없기 때문에(소멸자를 통해 알아서 처리되기 때문에) TearDown()은 정의하지 않았습니다. 이제 TEST_F()를 통해 이 고정부를 사용하는 테스트를 작성하겠습니다.\nTEST_F(QueueTest, IsEmptyInitially) { EXPECT_EQ(q0_.size(), 0); } TEST_F(QueueTest, DequeueWorks) { int* n = q0_.Dequeue(); EXPECT_EQ(n, nullptr); n = q1_.Dequeue(); ASSERT_NE(n, nullptr); EXPECT_EQ(*n, 1); EXPECT_EQ(q1_.size(), 0); delete n; n = q2_.Dequeue(); ASSERT_NE(n, nullptr); EXPECT_EQ(*n, 2); EXPECT_EQ(q2_.size(), 1); delete n; } 위의 예시의 경우 ASSERT_*()와 EXPECT_*() 단언문을 함께 사용하는 것을 볼 수 있습니다. 경험적으로 EXPECT_*()는 단언문 실패 이후에도 테스트를 계속 진행하며 추가적인 오류를 더 드러내고자 할 때 사용합니다. ASSERT_*()는 해당 단언문이 실패한 뒤의 코드를 진행하는것은 무의미하다고 생각할 때 사용합니다. 예를 들어 Dequeue 관련 테스트에서 두 번째 단언문에 사용된 ASSERT_NE(n, nullptr)를 보자. 해당 단언문 이후의 코드에서는 포인터 변수 n에 대한 간접 접근(dereference)이 수행되어야 하는데, n이 NULL이면 segfault가 발생할 수 있으므로 이와 같이 사용한 것을 볼 수 있습니다.\n위와 같은 고정부 기반의 테스트를 수행하면 아래와 같은 순서로 동작합니다.\n GoogleTest가 QueueTest 객체를 생성합니다. (이 객체를 t1이라 부르겠습니다.) t1.SetUp()으로 t1 객체가 초기화됩니다. 첫 테스트(IsEmptyInitially)가 t1에서 수행됩니다. 해당 테스트가 끝나고 난 뒤, t1.TearDown()을 통해 내부가 정리됩니다. t1 객체가 소멸되었습니다. 위와 같은 과정이 또 다른 QueueTest 객체에서 수행된다. 이번에는 DequeueWorks 테스트를 수행합니다.  사용 가능 환경: Linux, Windows, Mac.\n테스트 실행 방법 TEST()나 TEST_F() 매크로를 사용하면 GoogleTest의 테스트 목록에 암묵적으로 등록이 됩니다. 다른 C++ 테스팅 프레임워크에서는 각 테스트를 정의하고, 그 테스트들을 실행시키기 위해 다시 그 목록을 나열했어야 했겠지만, GoogleTest에서는 그럴 필요가 없습니다.\n테스트들을 정의하고 나서, RUN_ALL_TESTS()를 통해 직접 테스트를 수행할 수 있습니다. 모든 테스트가 성공했다면 해당 매크로는 0을 반환할 것이고, 하나라도 실패했다면 1을 반환할 것입니다. 참고로 RUN_ALL_TESTS()는 링크된 수준에서 접근할 수 있는 모든 테스트 를 수행합니다. 즉, 현재 테스트 모음과 다를 수 있으며, 심지어 다른 소스파일에 있는 테스트들도 수행될 수 있습니다.\nRUN_ALL_TESTS() 매크로가 실행되면 아래와 같은 단계가 수행됩니다.\n 현재 GoogleTest의 설정(flags)을 저장 첫 테스트를 위한 테스트 고정부 객체 생성 SetUp()을 통해 초기화 테스트 고정부 객체에서 테스트 수행 TearDown()을 통해 고정부 정리 테스트 고정부 객체 제거 저장되었던 GoogleTest의 설정으로 복원 위의 과정을 다음 테스트에서도 반복, 모든 테스트를 수행할때까지 반복  위 과정에서 심각한 실패가 발생한다면, 아래 과정은 생략될 수도 있습니다.\n 중요\nRUN_ALL_TESTS()의 반환 값을 무시하면 안됩니다. 해당 값을 무시할 경우 컴파일 에러가 발생할 수 있습니다.\n자동화 테스팅 서비스에서는 stdout/stderr 출력이 아니라, 종료 코드로 전체 테스트의 성공/실패 여부를 결정하기 때문에 이렇게 설계되었습니다.\n그러므로, main() 함수의 반환 값은 RUN_ALL_TESTS()의 반환 값이어야 합니다.\n또한, RUN_ALL_TESTS()는 단 한번 호출되어야 합니다. 만약 두 번 이상 호출할 경우, GoogleTest의 일부 고급 기능과 충돌이 발생할 수 있습니다. (예를 들어 thread-safe 종료 테스트)\n 사용 가능 환경: Linux, Windows, Mac.\nmain() 함수 작성하기 대부분의 경우 굳이 main() 함수를 직접 작성할 필요가 없습니다. 대신 적절한 진입점을 정의하는 gtest_main()에 연결됩니다. 더 자세한 내용은 이 문단의 끝 부분을 읽으시면 됩니다. 이 문단의 나머지 부분은 테스트가 수행되기 전에 무언가 사용자 지정 작업이 필요하거나, 테스트 모음 혹은 테스트 고정부로 표현할수 없는 부분이 있는 경우에만 적용하십시오.\n만약 main() 함수를 직접 정의한다면, 해당 함수는 RUN_ALL_TESTS()의 결과 값을 반환해야 합니다.\n아래 상용구 코드를 참고하여 작성하시면 됩니다.\n#include \u0026#34;this/package/foo.h\u0026#34; #include \u0026#34;gtest/gtest.h\u0026#34; namespace my { namespace project { namespace { // The fixture for testing class Foo. class FooTest : public ::testing::Test { protected: // You can remove any or all of the following functions if their bodies would  // be empty.  FooTest() { // You can do set-up work for each test here.  } ~FooTest() override { // You can do clean-up work that doesn\u0026#39;t throw exceptions here.  } // If the constructor and destructor are not enough for setting up  // and cleaning up each test, you can define the following methods:  void SetUp() override { // Code here will be called immediately after the constructor (right  // before each test).  } void TearDown() override { // Code here will be called immediately after each test (right  // before the destructor).  } // Class members declared here can be used by all tests in the test suite  // for Foo. }; // Tests that the Foo::Bar() method does Abc. TEST_F(FooTest, MethodBarDoesAbc) { const std::string input_filepath = \u0026#34;this/package/testdata/myinputfile.dat\u0026#34;; const std::string output_filepath = \u0026#34;this/package/testdata/myoutputfile.dat\u0026#34;; Foo f; EXPECT_EQ(f.Bar(input_filepath, output_filepath), 0); } // Tests that Foo does Xyz. TEST_F(FooTest, DoesXyz) { // Exercises the Xyz feature of Foo. } } // namespace } // namespace project } // namespace my  int main(int argc, char **argv) { ::testing::InitGoogleTest(\u0026amp;argc, argv); return RUN_ALL_TESTS(); } ::testing::InitGoogleTest() 함수는 해당 프로그램의 명령행을 해석하여 GoogleTest의 설정 중 인식된 부분을 제거합니다. 이를 통해 사용자는 다양한 설정을 통해 테스트 프로그램의 동작을 설정할 수 있습니다. 해당 부분은 고급 사용법에서 다룹니다. 해당 함수(::testing::InitGoogleTest())는 RUN_ALL_TESTS()가 호출되기 전에 미리 호출해야 설정이 적용됩니다. 만약 먼저 호출되지 않는다면 의도한 대로 초기화되지 않을 것입니다.\nWindows에서는 InitGoogleTest() 함수가 확장 문자열을 지원합니다. 즉, UNICODE 환경으로 컴파일된 프로그램에서도 사용할 수 있습니다.\n어쩌면 이렇게 main()함수를 작성하는 것이 너무 귀찮다고 생각할 수도 있습니다. 저희도 귀찮다는 것에 동의하기 때문에 GoogleTest에서는 기본적인 main()함수의 구현을 제공합니다. 만약 저희가 제공하는 기본적인 구현 수준이 충분하다면 gtest_main 라이브러리를 링크함으로서 main()함수 호출 작성을 생략할 수 있습니다.\n 비고:\nParseGUnitFlags()함수는 InitGoogleTest()으로 대체될 예정입니다.\n 알려진 제약 사항  GoogleTest는 thread-safe하게 설계되었습니다. pthreads를 사용할 수 있는 환경에서만 구현되어있습니다. 즉, Windows같이 pthreads를 사용할 수 없는 환경에서는 두개 이상의 쓰레드가 동시에(concurrently) 단언문을 사용하는 것은 안전하지 않습니다. 대부분의 테스트에서 단언문은 메인 쓰레드에 의해 수행되기 때문에 큰 문제가 되지 않을 것입니다. 만약 이 문제를 도와줄 수 있다면, 여러분의 환경(platform)에서 필수적인 동기화 동작을 gtest-port.h에 구현해주시길 바랍니다.  번역 관련 주석 (원문에 존재하지 않음) 원문과 번역한 단어의 목록은 다음과 같습니다. (그대로 음차한 번역은 생략합니다.) 익숙하지 않은 표현이거나, 오해의 가능성이 있는 번역의 경우, 처음 해당 표현이 나온 부분에 원문을 추가로 작성했습니다.\n   원문 번역 비고     Assertion 단언문 Wiki에서는 표명으로 번역됨, 단언문이 더 직관적이라 생각하여 번역함   Fatal 심각한 치명적인으로 번역했으나, 문맥상 심각한이 더 자연스러운 것으로 판단하여 이와 같이 번역함   Predicate 서술부 사전에 따라 단정하다를 고려했으나, Assertion의 번역인 단언과 유사한데다, 표현의 의도가 복잡한 논리식이므로 서술부로 번역함   Test fixture 테스트 고정부 소프트웨어 개발자 테스팅의 번역을 인용함   Test suite 테스트 모음 같은 설계를 가지면서 값을 공유할 수 있는 프로그램의 집합의 의미에서 모음으로 번역함   Wide string 확장 문자열 Wiki의 확장 문자문서를 참고하여 번역함    ","description":"","id":5,"section":"posts","tags":["GoogleTest"],"title":"GoogleTest User's Guide: 입문하기","uri":"https://devlog.jsyoo5b.net/ko/posts/googletest/userguide-translate/primer/"},{"content":"10장 클래스를 읽으면서 내용에 대해 보충하거나, 개인적인 의견으로 반박하거나, 고민해 볼 부분에 대해 적어보려 한다.\n클래스 체계 자바의 표준 코딩 컨벤션에 따르면 클래스 작성 시 배치 순서가 존재한다. 요약하면 다음과 같다.\n static 상수/변수 인스턴스 변수 생성자 메서드  같은 조건에서는 (ex. static 상수/변수가 여럿일 때) public, protected, 패키지(접근 한정자 없음), private 순으로 배치한다.\n메서드의 경우 모든 public 메서드 정의 이후 protected/private 메서드를 정의하는 방식이 아니라, 현재 정의한 public 메서드에서 내부적으로 호출한 다른 접근자의(protected/private 등) 메서드를 순서대로 정의하는 방식이다.\n캡슐화 우리는 기본적으로 변수와 내부적으로 사용되는 유용한 함수들(utility functions)을 private하게 선언하는 것을 선호한다. 하지만 테스팅 과정에서 변수들이나 유용한 함수들을 직접 접근해야 해서, protected로 변경해야 하는 경우가 존재한다. (최대한 private 상태를 유지할 방법을 고민해보고, 더 이상 좋은 방법이 없을때만 변경하는 식으로 해야 한다.)\n매우 이상한 내용이라 생각한다. (내가 이런 상황을 경험하지 못한 것이 크겠지만, 일종의 객체지향의 기본 원칙을 뒤집는듯한 주장처럼 들려서 더더욱 반발하고 있다.)\n protected의 목적은 상속 시 자식 클래스가 접근하기 위함이다. 원래 private해야 하나, 상속 과정에서 자식 클래스(구체화 클래스)가 접근할 수 있으면서도 public하지 않게 하기 위함이다. 캡슐화의 목적 중 하나가 허가되지 않은 방식(public 메서드 호출 외의 방식)으로 객체의 상태를 변경하는 것을 막는 것으로 알고 있다. 이런 목적으로 수행된 캡슐화를 테스트 때문에 접근자를 변경한다?  접근자 변경의 문제는 다음과 같이 고려되어야 한다고 생각한다.\n 멤버 변수의 경우, 상태 값을 가져오는 것도 허가된 방식(public 메서드 호출)으로 기대하는 상태를 확인해야 한다.\n내부적으로 관리하는 변수라서 private하게 선언되었다면, 이 값은 테스트를 통해 검증할 값이 아니다.\n(원칙적으로 공개하지 않는 값인데, 굳이 확인을 하겠다는 것은 객체의 설계를 무시하겠다는 것이다.) 해당 객체의 상태가 메서드 호출 순서 등에 따라 바뀌는 등, 객체의 속성이 복잡한 경우(ex. 원형 버퍼/큐 등) 내부 변수를 통해 유효성을 쉽게 확인하고 싶을 것이다.\n하지만 이런 경우는 확인하고자 하는 경우에 대한 시나리오를 만들어서 테스트를 수행하는 방식으로 검증하는 것이 옳다고 생각한다. 해당 객체의 상태가 비결정적일 경우(해당 객체/프로그램 외부 상황에 의해 결과가 변경), 이런 검증은 단위 테스트의 범위를 넘어갈 가능성이 높다. (ex. DB 연결, 네트워크 통신 등)\n외부 상황에 따른 내부적인 논리만 확인하려 할 경우, Mock 기법으로 외부 상황을 통제한 채 테스트한다.\n만약 외부 상황을 고려하는 테스트라면, 이것은 단위테스트가 아니라 통합 테스트에서 수행되어야 한다.\n각 단계 별 테스트 순서는 V-model을 참고하자. 객체의 상태가 비결정적이면서, 무작위성을 기반으로 한다면(ex. 복권 번호 생성) 접근법이 다르다.\n먼저 단위 테스트에서 확인할 수 있는 부분은 결과값이 유효한지 확인하는 것이다.\n해당 객체의 무작위성 성능이나, 동작 방식에 대한 검증은 유효성이 아니라 성능의 영역에 해당한다. 이 검증은 벤치마킹으로 봐야한다. 유용한 함수들(utility functions)의 경우, 아마 코드 상의 중복 제거나, 문맥에 대한 가독성 향상을 위해 작성되었을 것이다.\n먼저, 순수함수와 같이 현재 상태와 관계없는 함수라면 해당 함수/기능을 묶어 다른 클래스로 분리하는 것이 좋을 것이다.\n만약 문맥에 대한 가독성 향상을 위해 작성된 함수 등 순수함수가 아니라면 원래 있던 복잡한 코드를 추상화한 것이므로 테스트 대상이 아니다.  위의 내용과는 별개의 질문인데, 자바를 사용한 실무 경험이 적어서 그런지 패키지(접근 한정자 없음) 권한은 어떤 때 써야 할지 잘 모르겠다. 그리고 테스트 코드가 같은 패키지에 있는 것이 적합한지도 잘 모르겠다. (구현 패키지와 테스트 패키지가 서로 분리되어 있어야 할 것 같다.)\n클래스는 작아야 한다 클래스는 최대한 작게 만들어야 한다. 함수에서 비슷한 이야기를 했지만 작게 만드는 것이 기본 규칙이다. 그렇다면 함수에서는 라인 수로 크기를 측정했는데, 클래스는 무엇을 기준으로 크기를 측정할까?\n클래스의 크기는 책임으로 그 기준을 측정한다.\n예시로 나오는 SuperDashboard 클래스의 설계는 너무 많은 책임을 가지고 있다. 메서드 개수가 너무 많은 것은 딱 봐도 책임이 너무 많아 보인다. 메서드의 개수를 5개로 줄였음에도 불구하고 여전히 책임이 많다.\n메서드 개수가 너무 많은 클래스 여전히 책임이 너무 많은 클래스  public class SuperDashboard extends JFrame implements MetaDataUser { public String getCustomizerLanguagePath() public void setSystemConfigPath(String systemConfigPath) public String getSystemConfigDocument() public void setSystemConfigDocument(String systemConfigDocument) public boolean getGuruState() public boolean getNoviceState() public boolean getOpenSourceState() public void showObject(MetaObject object) public void showProgress(String s) public boolean isMetadataDirty() public void setIsMetadataDirty(boolean isMetadataDirty) public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) public void setMouseSelectState(boolean isMouseSelected) public boolean isMouseSelected() public LanguageManager getLanguageManager() public Project getProject() public Project getFirstProject() public Project getLastProject() public String getNewProjectName() public void setComponentSizes(Dimension dim) public String getCurrentDir() public void setCurrentDir(String newDir) public void updateStatus(int dotPos, int markPos) public Class[] getDataBaseClasses() public MetadataFeeder getMetadataFeeder() public void addProject(Project project) public boolean setCurrentProject(Project project) public boolean removeProject(Project project) public MetaProjectHeader getProgramMetadata() public void resetDashboard() public Project loadProject(String fileName, String projectName) public void setCanSaveMetadata(boolean canSave) public MetaObject getSelectedObject() public void deselectObjects() public void setProject(Project project) public void editorAction(String actionName, ActionEvent event) public void setMode(int mode) public FileManager getFileManager() public void setFileManager(FileManager fileManager) public ConfigManager getConfigManager() public void setConfigManager(ConfigManager configManager) public ClassLoader getClassLoader() public void setClassLoader(ClassLoader classLoader) public Properties getProps() public String getUserHome() public String getBaseDir() public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() public MetaObject pasting( MetaObject target, MetaObject pasted, MetaProject project) public void processMenuItems(MetaObject metaObject) public void processMenuSeparators(MetaObject metaObject) public void processTabPages(MetaObject metaObject) public void processPlacement(MetaObject object) public void processCreateLayout(MetaObject object) public void updateDisplayLayer(MetaObject object, int layerIndex) public void propertyEditedRepaint(MetaObject object) public void processDeleteObject(MetaObject object) public boolean getAttachedToDesigner() public void processProjectChangedState(boolean hasProjectChanged) public void processObjectNameChanged(MetaObject object) public void runProject() public void setAçowDragging(boolean allowDragging) public boolean allowDragging() public boolean isCustomizing() public void setTitle(String title) public IdeMenuBar getIdeMenuBar() public void showHelper(MetaObject metaObject, String propertyName) // ... many non-public methods follow ... }   public class SuperDashboard extends JFrame implements MetaDataUser { public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() }     'use strict'; var containerId = JSON.parse(\"\\\"b43176acd80dfba2\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  책임이 적다면, 클래스를 짧은 문장으로 설명할 수 있을 것이다. 심지어 책에서는 만일(\u0026ldquo;if\u0026rdquo;), 그리고(\u0026ldquo;and\u0026rdquo;), 또는(\u0026ldquo;or\u0026rdquo;), 하지만(\u0026ldquo;but\u0026rdquo;) 같은 표현을 사용하지 말라고 하는데, 이는 위의 표현들이 아래 설명할 단일 책임 원칙을 위반하는 단어기 때문이다.\n메서드의 이름으로 SuperDashboard 클래스의 책임을 분석해보자.\n 포커스되었던 Component를 설정하거나 가져오는 책임\ngetLastFocusedComponent(), setLastFocused() 버전 정보를 가져오는 책임\ngetMajorVersionNumber(), getMinorVersionNumber(), getBuildNumber() GUI를 관리하는 책임\nJFrame을 상속받으면서 생긴 책임  아마 책에서의 분석 내용으로 봤을때 1번 책임은 3번 책임을 기반으로 확장되어야 할 것이다. 1번 책임과 3번 책임을 묶더라도 여전히 2개의 책임을 가지고 있다. 이제 클래스의 책임을 줄이기 위한 원칙인 단일 책임 원칙을 확인해보자.\n단일 책임 원칙  클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다.\n 위 문장에서는 책임의 정의와 클래스의 크기에 대한 가이드를 제공하고 있다. 책임의 정의를 클래스나 모듈을 변경할 이유라고 하고 있으며, 클래스나 모듈은 하나의 책임만 가져야 한다고 크기를 정하고 있다.\n이전에 분석한대로, SuperDashboard는 두가지 책임을 갖고 있다. 이 중 버전 정보를 출력하는 기능은 이상적이라면 코드가 수정될 때마다 코드가 변경되어야 할 것이다. (버전 정보가 하드코딩된 경우에 국한된 상황이며, 오히려 관리 측면에선 좋지 않은 방법이지만 일단은 이 책의 이야기를 따르도록 하자.) SuperDashboard의 다른 책임(GUI 관련)을 수정할 때 버전 정보가 수정되어야 하는 것은 당연하지만, 반대로 버전 정보를 수정할 때마다 다른 책임의 코드도 수정해야 하는 것은 아니다.\n책임을 기준으로 클래스 분리  public class SuperDashboard extends JFrame implements MetaDataUser { public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) } public class Version { public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() }     'use strict'; var containerId = JSON.parse(\"\\\"830ccba80ff1edb9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위와 같이 단일 책임 원칙은 객체지향 관점에서 중요하면서, 이해하기 쉽고, 지키기도 쉬운 원칙이다. 하지만 정작 잘 지켜지지 않는 편이며, 너무 많은 책임을 가진 클래스를 자주 보게 된다.\n소프트웨어가 돌아가게 작성하는 것(요구사항을 만족하는 것)과 코드를 깨끗하게 작성하는 것(단일 책임 원칙 등을 지키는 것)은 다른 일이며, 대부분 돌아가게 하는 것에 더 집중하기 때문이다. 그리고 소프트웨어가 잘 동작하면 거기서 일이 끝났다고 생각하기 때문에 실패하는 것이다.\n게다가 많은 프로그래머들은 여러 개의 단일 책임 클래스로 구성하는 것이 전체 구조를 이해하는데 더 어려울 것이라며 두려워한다는 것이다. (어떤 일을 하기 위해 여러 클래스들을 돌아다녀야 하기 때문에 일을 키운다고 생각한다.)\n개인적인 의견으로, 이렇게 생각하는 사람이 진짜 있긴 한지 의문이 든다. 과거에는 개발환경이 불편해서 이런 생각을 했을 지 몰라도, 지금도 이런 생각을 하고 있다면 그 사람이 이상한 사람이라 생각한다. IDE에서 정의 찾아보기 기능은 기본이고, (가끔 Visual Studio에서는 선언만 찾아주고 정작 정의는 안 찾아주는 짜증나는 상황은 있지만, 이건 생략하도록 하자.) 듀얼모니터는 일반적이며, 개별 모니터의 해상도도 훨씬 크고, 여러 개의 탭도 쓸수 있고, 자동완성 기능도 잘 제공되는데, 정말 이런 생각을 하는 사람이 있는 지 궁금하다.\n응집도Cohesion  클래스는 인스턴스 변수를 적게 가지고 있어야 좋다. 아마 클래스의 메서드는 인스턴스 변수를 1개 이상 사용할 것이다. 각 메서드에서 많은 인스턴스 변수를 쓸 수록 더 응집되어있다고 한다.  응집도가 높은 Stack 클래스를 보자. (size() 메서드를 제외한 모든 메서드가 모든 멤버 변수를 접근하고 있다.)\n응집도가 높은 Stack 클래스  public class Stack { private int topOfStack = 0; List\u0026lt;Integer\u0026gt; elements = new LinkedList\u0026lt;Integer\u0026gt;(); public int size() { return topOfStack; } public void push(int element) { topOfStack++; elements.add(element); } public int pop() throws PoppedWhenEmpty { if (topOfStack == 0) throw new PoppedWhenEmpty(); int element = elements.get(--topOfStack); elements.remove(topOfStack); return element; } }     'use strict'; var containerId = JSON.parse(\"\\\"416e55da9fe1dd91\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  함수의 크기를 작게 만들고, 매개변수의 개수를 줄이면서 클래스를 만들다보면 일부 메서드만이 사용하는 인스턴스 변수가 많아진다. 이는 관련 메서드들을 새로운 클래스로 쪼개야 한다는 신호다. (내부적인 연관성이 낮아지므로, 서로 다른 책임이 섞여 있을 가능성이 높다는 뜻이다.)\n응집도를 유지하면 작은 클래스 여럿이 나온다 큰 함수를 작은 함수들로 쪼개는 행위만으로도 응집도를 높이는 클래스로 구성할 수 있다.\n책에서는 예시로 도널드 커누스의 Literate Programming 책에 나온 PrintPrimes 프로그램의 코드를 자바로 변환했을 때의 코드를 원본으로 가정하고 있다.\n큰 함수를 작은 함수로 쪼개는 방식, 그 과정에서 응집도를 높이기 위해 클래스를 분리하는 방식으로 리팩토링을 수행한 결과를 보여주고 있다.\n리팩토링 하기 전의 큰 클래스 리팩토링 #1(메인 함수) 리팩토링 #2(출력 형식 변환기) 리팩토링 #3(소수 생성기)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  package literatePrimes; public class PrintPrimes { public static void main(String[] args) { final int M = 1000; final int RR = 50; final int CC = 4; final int WW = 10; final int ORDMAX = 30; int P[] = new int[M + 1]; int PAGENUMBER; int PAGEOFFSET; int ROWOFFSET; int C; int J; int K; boolean JPRIME; int ORD; int SQUARE; int N; int MULT[] = new int[ORDMAX + 1]; J = 1; K = 1; P[1] = 2; ORD = 2; SQUARE = 9; while (K \u0026lt; M) { do { J = J + 2; if (J == SQUARE) { ORD = ORD + 1; SQUARE = P[ORD] * P[ORD]; MULT[ORD - 1] = J; } N = 2; JPRIME = true; while (N \u0026lt; ORD \u0026amp;\u0026amp; JPRIME) { while (MULT[N] \u0026lt; J) MULT[N] = MULT[N] + P[N] + P[N]; if (MULT[N] == J) JPRIME = false; N = N + 1; } } while (!JPRIME); K = K + 1; P[K] = J; } { PAGENUMBER = 1; PAGEOFFSET = 1; while (PAGEOFFSET \u0026lt;= M) { System.out.println(\u0026#34;The First \u0026#34; + M + \u0026#34; Prime Numbers --- Page \u0026#34; + PAGENUMBER); System.out.println(\u0026#34;\u0026#34;); for (ROWOFFSET = PAGEOFFSET; ROWOFFSET \u0026lt; PAGEOFFSET + RR; ROWOFFSET++) { for (C = 0; C \u0026lt; CC;C++) if (ROWOFFSET + C * RR \u0026lt;= M) System.out.format(\u0026#34;%10d\u0026#34;, P[ROWOFFSET + C * RR]); System.out.println(\u0026#34;\u0026#34;); } System.out.println(\u0026#34;\\f\u0026#34;); PAGENUMBER = PAGENUMBER + 1; PAGEOFFSET = PAGEOFFSET + RR * CC; } } } }     package literatePrimes; public class PrimePrinter { public static void main(String[] args) { final int NUMBER_OF_PRIMES = 1000; int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES); final int ROWS_PER_PAGE = 50; final int COLUMNS_PER_PAGE = 4; RowColumnPagePrinter tablePrinter = new RowColumnPagePrinter(ROWS_PER_PAGE, COLUMNS_PER_PAGE, \u0026#34;The First \u0026#34; + NUMBER_OF_PRIMES + \u0026#34; Prime Numbers\u0026#34;); tablePrinter.print(primes); } }   package literatePrimes; import java.io.PrintStream; public class RowColumnPagePrinter { private int rowsPerPage; private int columnsPerPage; private int numbersPerPage; private String pageHeader; private PrintStream printStream; public RowColumnPagePrinter(int rowsPerPage, int columnsPerPage, String pageHeader) { this.rowsPerPage = rowsPerPage; this.columnsPerPage = columnsPerPage; this.pageHeader = pageHeader; numbersPerPage = rowsPerPage * columnsPerPage; printStream = System.out; } public void print(int data[]) { int pageNumber = 1; for (int firstIndexOnPage = 0 ; firstIndexOnPage \u0026lt; data.length ; firstIndexOnPage += numbersPerPage) { int lastIndexOnPage = Math.min(firstIndexOnPage + numbersPerPage - 1, data.length - 1); printPageHeader(pageHeader, pageNumber); printPage(firstIndexOnPage, lastIndexOnPage, data); printStream.println(\u0026#34;\\f\u0026#34;); pageNumber++; } } private void printPage(int firstIndexOnPage, int lastIndexOnPage, int[] data) { int firstIndexOfLastRowOnPage = firstIndexOnPage + rowsPerPage - 1; for (int firstIndexInRow = firstIndexOnPage ; firstIndexInRow \u0026lt;= firstIndexOfLastRowOnPage ; firstIndexInRow++) { printRow(firstIndexInRow, lastIndexOnPage, data); printStream.println(\u0026#34;\u0026#34;); } } private void printRow(int firstIndexInRow, int lastIndexOnPage, int[] data) { for (int column = 0; column \u0026lt; columnsPerPage; column++) { int index = firstIndexInRow + column * rowsPerPage; if (index \u0026lt;= lastIndexOnPage) printStream.format(\u0026#34;%10d\u0026#34;, data[index]); } } private void printPageHeader(String pageHeader, int pageNumber) { printStream.println(pageHeader + \u0026#34; --- Page \u0026#34; + pageNumber); printStream.println(\u0026#34;\u0026#34;); } public void setOutput(PrintStream printStream) { this.printStream = printStream; } }   package literatePrimes; import java.util.ArrayList; public class PrimeGenerator { private static int[] primes; private static ArrayList\u0026lt;Integer\u0026gt; multiplesOfPrimeFactors; protected static int[] generate(int n) { primes = new int[n]; multiplesOfPrimeFactors = new ArrayList\u0026lt;Integer\u0026gt;(); set2AsFirstPrime(); checkOddNumbersForSubsequentPrimes(); return primes; } private static void set2AsFirstPrime() { primes[0] = 2; multiplesOfPrimeFactors.add(2); } private static void checkOddNumbersForSubsequentPrimes() { int primeIndex = 1; for (int candidate = 3 ; primeIndex \u0026lt; primes.length ; candidate += 2) { if (isPrime(candidate)) primes[primeIndex++] = candidate; } } private static boolean isPrime(int candidate) { if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) { multiplesOfPrimeFactors.add(candidate); return false; } return isNotMultipleOfAnyPreviousPrimeFactor(candidate); } private static boolean isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) { int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()]; int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor; return candidate == leastRelevantMultiple; } private static boolean isNotMultipleOfAnyPreviousPrimeFactor(int candidate) { for (int n = 1; n \u0026lt; multiplesOfPrimeFactors.size(); n++) { if (isMultipleOfNthPrimeFactor(candidate, n)) return false; } return true; } private static boolean isMultipleOfNthPrimeFactor(int candidate, int n) { return candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n); } private static int smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) { int multiple = multiplesOfPrimeFactors.get(n); while (multiple \u0026lt; candidate) multiple += 2 * primes[n]; multiplesOfPrimeFactors.set(n, multiple); return multiple; } }     'use strict'; var containerId = JSON.parse(\"\\\"e47cf7aa5fc85ada\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  책에서 리팩토링 한 순서는 다음과 같다.\n 큰 함수를 작은 함수로 분리한다. 분리 과정에서 함수 당 매개변수 개수를 줄이기 위해 일부를 멤버변수로 승격시킨다. 이 과정에서 함수와 변수 사이의 관계가 줄어들면서 응집도가 낮아진다. 응집도가 낮은 것을 기준으로 클래스를 분리한다.  원본 코드의 main()함수를 의미 단위로 분리해보자.\n Line 29~49는 소수를 구하는 방법을 (에라토스테네스의 체 알고리즘을 사용) 표현하고 있다. Line 50~64는 구해진 소수들을 출력하는 방법을 표현하고 있다. Line 5~9는 구할 소수의 범위, 출력 조건 등을 설정하고 있다. (상수로 프로그램 동작을 위한 입력값 표현)  각 의미에 따라 최종적으로 3개의 클래스로 리팩토링 된 것을 볼 수 있다.\n PrimeGenerator: 소수를 구하는 책임 RowColumnPagePrinter: 화면에 형식을 맞춰 출력하는 책임 PrimePrinter: 전체 프로그램을 동작시키는 책임 (소수를 구해서 화면에 출력시키는 역할)  변경하기 쉬운 클래스 대부분의 시스템에서 변경은 불가피하게 일어나며, 각 변경은 시스템의 남은 부분이 의도대로 동작하지 않게 하는 위험성을 내포하고 있다. 깨끗한 시스템이라면 변경에 의한 위험성을 줄이기 위해 구성되었을 것이다.\n아래와 같이 SQL 쿼리문을 생성하는 클래스가 있고, 초기 설계와 같이 Sql 클래스 안에 모든 기능이 집중되어 있다고 가정하자. 이 설계는 아래와 같은 예시로 단일 책임 원칙을 위반한다.\n update() 같이 새로운 쿼리문을 생성하는 메서드를 추가할 때 select() 메서드에서 내장된 SELECT와 같이 서브쿼리를 지원하려 할 때  게다가 selectWithCriteria() 메서드는 select() 형태의 메서드에서 사용하기 위해 분리한 함수일 가능성이 높다.\n변경하기 어려운 클래스 변경하기 쉽게 나눈 클래스들  public class Sql { public Sql(String table, Column[] columns) public String create() public String insert(Object[] fields) public String selectAll() public String findByKey(String keyColumn, String keyValue) public String select(Column column, String pattern) public String select(Criteria criteria) public String preparedInsert() private String columnList(Column[] columns) private String valuesList(Object[] fields, final Column[] columns) private String selectWithCriteria(String criteria) private String placeholderList(Column[] columns) }   abstract public class Sql { public Sql(String table, Column[] columns) abstract public String generate(); } public class CreateSql extends Sql { public CreateSql(String table, Column[] columns) @Override public String generate() } public class SelectSql extends Sql { public SelectSql(String table, Column[] columns) @Override public String generate() } public class InsertSql extends Sql { public InsertSql(String table, Column[] columns, Object[] fields) @Override public String generate() private String valuesList(Object[] fields, final Column[] columns) } public class SelectWithCriteriaSql extends Sql { public SelectWithCriteriaSql( String table, Column[] columns, Criteria criteria) @Override public String generate() } public class SelectWithMatchSql extends Sql { public SelectWithMatchSql( String table, Column[] columns, Column column, String pattern) @Override public String generate() } public class FindByKeySql extends Sql { public FindByKeySql( String table, Column[] columns, String keyColumn, String keyValue) @Override public String generate() } public class PreparedInsertSql extends Sql { public PreparedInsertSql(String table, Column[] columns) @Override public String generate() private String placeholderList(Column[] columns) } public class Where { public Where(String criteria) public String generate() } public class ColumnList { public ColumnList(Column[] columns) public String generate() }     'use strict'; var containerId = JSON.parse(\"\\\"f11445125e4867f9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  변경한 코드는 Sql이라는 추상클래스를 상속받아, 각 기능별로 개별적인 클래스로 구별하였다. 이전에 private로 선언되었던 함수들은 필요한 클래스의 내부 함수로 옮겨졌으며, 공통적으로 사용되는 내부함수는 Where, ColumnList와 같이 개별적인 클래스로 분리되었다.\n변경으로부터 격리 요구사항은 변경될 것이며, 당연히 코드도 변경될 것이다.\n","description":"","id":6,"section":"posts","tags":["클린 코드","객체 지향"],"title":"Clean Code 10장: \"클래스\" 정리","uri":"https://devlog.jsyoo5b.net/ko/posts/clean-code/ch10/"},{"content":"6장 객체와 자료 구조를 읽으면서 내용에 대해 보충하거나, 개인적인 의견으로 반박하거나, 고민해 볼 부분에 대해 적어보려 한다.\n자료 추상화 직교 좌표계에서 점을 표현하는 두 예시를 비교해보자.\n구체적인 Point 추상적인 Point  public class Point { public double x; public double y; }   public interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta); }     'use strict'; var containerId = JSON.parse(\"\\\"9de97fd5ce165422\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  추상적인 Point는 해당 점이 내부적으로 직교좌표계를 사용하는지, 극좌표계를 사용하는지 알 수 없다. (심지어 둘다 아닐 수도 있다.) 하지만 메서드를 통해 직교좌표값이나 극좌표값을 알아낼 수 있다.\n반면 구체적인 Point는 직교좌표계로 구현되어있고, 이를 직접 사용할 수 있게 한다. 다만 직교좌표값만 알아낼 수 있다.\n자료/객체 비대칭 객체와 자료구조의 차이를 아래와 같이 정의하고 있다.\n 객체는 데이터를 추상화로 숨기고, 데이터를 사용하는 함수를 노출한다. 자료구조는 데이터를 노출하고, 의미있는 함수가 존재하지 않는다.  절차적 도형 다형성을 갖춘 도형  public class Square { public Point topLeft; public double side; } public class Rectangle { public Point topLeft; public double height; public double width; } public class Circle { public Point center; public double radius; } public class Geometry { public final double PI = 3.141592653589793; public double area(Object shape) throws NoSuchShapeException { if (shape instanceof Square) { Square s = (Square)shape; return s.side * s.side; } else if (shape instanceof Rectangle) { Rectangle r = (Rectangle)shape; return r.height * r.width; } else if (shape instanceof Circle) { Circle c = (Circle)shape; return PI * c.radius * c.radius; } throw new NoSuchShapeException(); } }   public class Square implements Shape { private Point topLeft; private double side; public double area() { return side*side; } } public class Rectangle implements Shape { private Point topLeft; private double height; private double width; public double area() { return height * width; } } public class Circle implements Shape { private Point center; private double radius; public final double PI = 3.141592653589793; public double area() { return PI * radius * radius; } }     'use strict'; var containerId = JSON.parse(\"\\\"907bd69104dddee1\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  여기서는 도형을 절차지향적(자료구조 표현)으로 구현한 방식과 객체지향적(상속을 통한 다형성) 구현 방식의 차이를 설명하고 있다.\n절차지향적 구현\n 절차지향의 경우, 새로운 도형의 추가는 다른 도형 class에 영향을 미치지 않음 하지만 Geometry 클래스의 area() 함수는 변경되어야 함 만약 도형에 대해 둘레를 구하는 perimeter() 함수를 추가하려면 Geometry 클래스만 변경하면 됨  객체지향적 구현\n area() 함수가 다형적으로 구현되어있으므로, Geometry 클래스가 불필요함 새로운 도형 추가로 인해 기존의 area()가 변경될 필요가 없음 도형에 대해 둘레를 구하는 perimeter()를 추가하려면 모든 클래스가 변경되어야 함  상황에 따라 객체지향적인 구현이 유리할 수도 있고, 절차지향적인 구현이 유리할 수도 있다.\n디미터 법칙 디미터 법칙, 혹은 최소 지식의 원칙은 소프트웨어 모듈 사이의 결합도를 줄여서 코드의 품질을 높이자는 취지의 가이드라인이다.\n책에서 설명하는 디미터의 법칙은 아래와 같다.\n 클래스 C와, 해당 클래스의 메서드 f 메서드 f가 생성한 객체 메서드 f에 인자로 전달 된 객체 클래스 C의 인스턴스 변수 안에 있는 객체  위의 목록에 해당하는 객체, 객체의 메서드들만 호출할 것을 말하고 있다. 해당 객체에 직접적으로 연관된 객체들만 사용할 것을 말하고 있다.\n디미터의 법칙을 어기는 예시로는, 해당 클래스나 메서드에 관련되지 않은 객체를 사용하지 말라는 것이다. 메서드 내부에서만 다른 객체를 사용하면, 각 객체간의 결합도를 알 수 없기 때문인 것으로 보인다.\nfinal String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 위 코드는 디미터의 법칙을 어기는 코드다.\n getOptions() 함수가 호출됨 (디미터의 법칙을 지킴) getScratchDir() 함수가 호출됨 (getOptions()의 결과 객체를 사용하므로 디미터의 법칙을 어김) getAbsolutePath() 함수가 호출됨 (getScratchDir()의 결과 객체를 사용하므로 디미터의 법칙을 어김)  기차 충돌 아까 위에서 본 코드를 기차 충돌이라고 한다. 함수 호출이 연속되며, 조잡한 방식이기 때문에 이런 방식의 코드를 사용하지 말라고 한다.\n기차 충돌 코드 함수 호출을 분리하여 개선한 코드  final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();   Options opts = ctxt.getOptions(); File scratchDir = opts.getScratchDir(); final String outputDir = scratchDir.getAbsolutePath();     'use strict'; var containerId = JSON.parse(\"\\\"4fc7a7f0bade36f0\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  여기에서 디미터의 법칙 위반 여부는 각 함수 호출의 결과 객체인 File, Options가 객체냐 자료구조에 따라 다르다. (자료구조라면 당연히 데이터를 노출하고, 의미있는 함수가 존재하지 않으므로 디미터의 법칙을 위반하지 않는다고 한다.)\n그런데 자료구조라면 굳이 메서드로 각 객체를 가져올 필요가 없다. 아래와 같이 멤버 변수를 바로 접근하면 된다.\nfinal String outputDir = ctxt.options.scratchDir.absolutePath; 위와 같이 클래스 안에 멤버 변수로 사용된 클래스, 이런 상황이 중첩된 상황을 예전에 겪어본 적이 있었다.\n임베디드 개발에서 C언어로 객체지향적인 설계를 하려면 구조체별로 묶어서 모듈로 관리하는데, 각 변수를 의미 기준으로 묶다보면 구조체 속 구조체와 같이 중첩된 정의를 하게 된다.\n문제는 중첩된 구조체의 변수에 접근하게 될 때 지금의 기차 충돌처럼 호출이 너무 복잡해진다.\n모듈의 변수에 접근할 때 기차 충돌식 코드 기차 충돌을 개선한 코드  int Driver_AddCtrlPkt(Driver *pDriverCb, CtrlPktHdr *pCtrlHdr, char *pPayload) { int tRetCode = RET_FAIL; if (pDriverCb-\u0026gt;tMsgMgr.tCtrlBuf.tHead == pDriverCb-\u0026gt;tMsgMgr.tCtrlBuf.tTail) { // Implementation...  } return tRetCode; }   int Driver_AddCtrlPkt(Driver *pDriverCb, CtrlPktHdr *pCtrlHdr, char *pPayload) { int tRetCode = RET_FAIL; DriverMsgBuf *pCtrlBuf = \u0026amp;(pDriverCb-\u0026gt;tMsgMgr.tCtrlBuf); if (pCtrlBuf-\u0026gt;tHead == pCtrlBuf-\u0026gt;tTail) { // Implementation...  } return tRetCode; }     'use strict'; var containerId = JSON.parse(\"\\\"6fc781e748aceaf4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  책에서 기차 충돌을 피하라는 것 처럼, 구조체 속 구조체를 매번 접근하면 변수 길이가 길어진다. 만약 유사한 변수라도 있다면 작성하다가 잘못 호출할 수도 있다. 코드 호출을 단순화 하고 오류를 줄이기 위해 필요한 구조체의 포인터 타입으로 연결하여 접근하도록 개선해봤다.\n그리고 위와 같은 기차 충돌 식 코드는 함수형 프로그래밍 패러다임에서 자주 봤던 것으로 기억한다.\n자바 8 그루비  public String cleanNames(List\u0026lt;String\u0026gt; names) { return names .stream() .filter(name -\u0026gt; name != null) .filter(name -\u0026gt; name.length() \u0026gt; 1) .map(name -\u0026gt; capitalize(name)) .collect(Collectors.joining(\u0026#34;,\u0026#34;)) }   public String cleanNames(listOfNames) { listOfNames .findAll { it.length() \u0026gt; 1 } .collect { it.capitalize() } .join \u0026#39;,\u0026#39; }     'use strict'; var containerId = JSON.parse(\"\\\"34a544014e563a35\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  절차적인 프로그래밍 패러다임에서는 지역변수에 상태를 저장하면서 각 연산 단계를 나누는 것이 일반적이기 때문에 함수 호출을 분리하는 것이 일반적이지만, 함수형 프로그래밍 패러다임은 수학 공식을 모델링하는 표현과 변형으로 기술하기 때문에 가변 상태를 지양하려 하는 것으로 알고있다.\n잡종 구조 아까 기차 충돌의 코드에서 함수의 결과 값을 자료구조라고 생각하면 디미터의 법칙을 지킬수 있다고 했지만, 기존의 코드를 보면 getter 형태로 메서드가 호출된 것을 알 수 있다.\n즉, 이 중간 객체들은 함수를 호출하는 형태로 봤을 때는 객체임에도, 디미터의 법칙을 지키기 위해 내부 구조를 개방하면 객체이면서 자료구조가 되게 된다. 이런 상황은 객체와 자료구조의 단점을 모두 갖게 되므로 지양해야 한다.\n구조체 감추기 만약 중간 결과 값이 실제 행위를 수행할 수 있는 객체라면 어떨까? 이전의 기차 충돌 식 코드를 예시로 마저 설명해보자.\n디미터의 법칙을 지키기 위해, 중간 변수들은 드러나선 안된다. 하지만 이렇게 되면 처음 호출한 객체가 하위 객체의 정보를 모두 알아야 한다. 즉, 객체 설계에서 결합도가 높아지는 문제가 생긴다.\n해당 코드를 메서드 이름으로 의도를 유추하면, 임시 디렉토리의 절대 경로를 얻는 것이다. 그렇다면 절대 경로를 얻는 것이 목적의 끝일까? 해당 변수가 사용되는 코드를 보니 임시 디렉토리에 임시 파일을 생성하는 것이었다면, 이와 관련된 부분을 더 숨길 수 있다.\n중간 변수를 숨기는 방식의 리팩토링 변수의 용도가 포함된 코드 블럭 변수의 목적을 고려한 리팩토링  final String outputDir = ctxt.getAbsolutePathOfScratchDirectoryOption(); // otherwise, final String outputDir = ctxt.getScratchDirectoryOption().getAbsolutePath();   final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); String outFile = outputDir + \u0026#34;/\u0026#34; + className.replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;) + \u0026#34;.class\u0026#34;; FileOutputStream fout = new FileOutputStream(outFile); BufferedOutputStream bos = new BufferedOutputStream(fout);   BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);     'use strict'; var containerId = JSON.parse(\"\\\"af175f358a6d1f25\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  자료 전달 객체 통신이나 데이터베이스의 값을 가져오기 위해 자료구조만 표현하는 형태의 객체가 사용되는데, 이를 DTO(Data Transfer Object)라 한다. ORM(Object-Relational Mapping) 혹은 protobuf로 생성한 클래스, 객체가 그 예시라 생각한다.\n아래와 같이 객체의 초기 값만 설정하고, 그 값을 읽어 오는 메서드만 제공하는 형태의 클래스를 bean이라 한다.\nJavaBeans 형태로 표현한 address  public class Address { private String street; private String streetExtra; private String city; private String state; private String zip; public Address(String street, String streetExtra, String city, String state, String zip) { this.street = street; this.streetExtra = streetExtra; this.city = city; this.state = state; this.zip = zip; } public String getStreet() { return street; } public String getStreetExtra() { return streetExtra; } public String getCity() { return city; } public String getState() { return state; } public String getZip() { return zip; } }     'use strict'; var containerId = JSON.parse(\"\\\"1fd6d11c73a10327\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  활성 레코드 데이터베이스의 테이블을 직접 변환하여, 기존 DTO와 유사하지면서 find(), save() 등의 레코드 작업을 수행하는 형태를 활성 레코드라 한다.\n가끔 개발자들이 이런 자료구조에 비즈니스 로직(업무적인 기능)을 넣는 형태로 개발하기도 하는데, 이는 잡종 구조를 만들 수 있으니 지양하라고 한다. 최대한 객체와 자료구조를 구분하여 다룰 것을 추천하고 있다.\n결론 이번 장에서 이야기하는 핵심은 객체(행동 기반)과 자료구조(자료 기반)의 차이를 명확히 하고, 이를 잘 구별할 것을 말하고 있다.\n사실 객체지향은 완전히 이해하기 상당히 어려운 주제다. 고작 책의 일부로 다루기엔 많이 복잡한 내용임이 확실하다. 하지만 내가 경험했던 것을 바탕으로 생각해보면 완전 객체지향으로 작성하는 것은 생각만큼 효율적이지 않을 수도 있다.\n데이터베이스 이론에서는 각 테이블의 상황에 따른 문제를 해결하기 위한 정규화 개념이 있지만, 모든 단계의 정규화를 적용하면 성능이 떨어지기 때문에 역정규화를 수행하듯, 이론이 현실에 완전 적용되지 않는 것을 볼 수 있다.\n객체지향에서 추상화에 집중한다면 라자냐 코드를 생성하게 될 가능성이 높다.\n직접 겪어보니 초급 개발자와 중급 이상 개발자의 가장 큰 차이는 적절한 선을 두고 저울질 할 수 있는 능력을 포함하는 것 같다. 디자인 패턴이 코드의 구조를 규격화하는 데 유용한 도구지만, 무분별하게 패턴을 적용할 필요가 없듯, 디미터의 법칙도 적절히 적용하는 것이 맞을 것 같다.\n객체지향과 관련된 다른 이야기 최근에는 객체지향 방식 자체에 대한 반발이 있다고 한다. 분명 객체지향은 코드를 추상화하는 좋은 방법이지만, 객체지향적인 코드를 작성하기 위해 작성해야 하는 보일러 플레이트 코드들이 많아진다는 문제가 있다.\n아마 함수형 프로그래밍 패러다임의 유행에는 객체 방식의 표현으로 인한 피로를 줄이고, 코드를 명확하게 하기 위한 전략 중 하나일 가능성도 있다고 생각한다.\n이 외에 객체지향이란 한국어 표현 자체가 적합하지 않고, SOLID 지향 프로그래밍이라고 표현하는 것이 더 적합하다는 의견도 있다. 이미 지금의 객체지향 방식은 객체를 기본으로 사용하고 있기 때문에 지향이란 표현이 어울리지 않는다는 것이다.\n오히려 SOLID 법칙은 객체지향을 효율적으로 작성하기 위한 법칙이지만, 위의 역정규화 예시처럼 현실적으로 모든 법칙을 지키기 힘들다. SOLID라는 이상향을 쫒는 상황이니 SOLID 지향 프로그래밍이라는 표현을 하는 것이다. 이 관점에 대해 더 관심이 있다면 아래 영상을 참고하길 바란다.\n  ","description":"","id":7,"section":"posts","tags":["클린 코드","객체 지향"],"title":"Clean Code 6장: \"객체와 자료 구조\" 정리","uri":"https://devlog.jsyoo5b.net/ko/posts/clean-code/ch06/"},{"content":"5장 형식 맞추기를 읽으면서 내용에 대해 보충하거나, 개인적인 의견으로 반박하거나, 고민해 볼 부분에 대해 적어보려 한다.\n형식을 맞추는 목적 형식을 맞추는 것은 너무 당연해서 중요하다는 사실을 잊을 정도다. 형식을 맞추는 것은 코드를 통해 의사소통을 하는 데 있어서 가장 중요한 것이다.\n마치 외국어를 사용할 때, 단어만 떠듬 떠듬 말해도 어떻게든 의사소통은 가능하지만, 이해 가능한 수준의 문법으로 말해야 이해가 쉬워지는 것과 비슷하다고 생각하면 된다. (필수는 아니지만 효율성을 위해 지켜야 한다고 생각하면 될 것 같다.)\n적절한 행 길이를 유지하라 책에서는 자바를 기준으로 하고 있고, 자바의 경우 파일 단위가 클래스를 기준으로 구분되기 때문에, 파일의 크기는 클래스의 크기에 비례하는 편이다. 클래스의 크기에 관련된 이야기는 6장에서 다루기 때문에 그냥 라인 수를 기준으로 판별했다고 한다. (굳이 클래스의 크기를 비교하자면 멤버 변수, 메서드의 수에 따라 분석할 수 있을 것이다.)\n책에서는 JUnit, FitNesse, testNG, Time and Money, JDepend, Ant, Tomcat의 소스 파일을 분석하여 파일당 길이가 얼마나 되는지를 분석해봤다. 일반적으로 200라인 정도에 최대 500라인 정도라고 한다.\n신문 기사처럼 작성하라 신문을 보면 헤드라인부터 시작해서 top-down 방식으로 읽기 좋게 구성된다. 코드의 구성을 이런 식으로, 목적을 알 수 있는 제목이나 큰 함수부터 점점 상세한 구현부를 서술하는 방식으로 작성하라는 것으로 보인다.\n개념은 빈 행으로 분리하라 개념별로 빈 행을 두어 관련된 코드끼리 그룹을 지을 수 있게 하자. 우리가 글을 작성할 때 문단 단위로 글을 나누는 것과 같은 맥락이라 생각하면 된다.\n세로 밀집도 개념별로 빈 행을 두어 구분하듯, 반대로 관련 있는 코드들은 붙여 작성함으로서 서로 관계가 있음을 나타내자.\n수직 거리 각 변수나 함수의 정의가 사용되는 곳으로부터 얼마나 멀리 정의되어있느냐를 표현하는 것이다.\n현재 맥락과 관련된 변수, 함수의 선언을 가까운 곳에 둬서 커서를 최소한으로 움직이면서 맥락을 확인할 수 있게 배치하란 뜻이다.\n세로 순서 관련 있는 순서부터 글을 쓰도록 한다. (Top-down)\n가로 형식 맞추기 자바를 기준으로 하면서 가로 길이를 논하는 것이 매우 이상하게 들린다.\n기존 프로젝트들을 분석해 본 결과, 가로 밀집도는 보통 20~60자라고 하는데, 가끔씩 긴 키워드들 때문에 (class에서 상속, 인터페이스 정의 등) 일부 코드 행이 120자가 넘는 경우도 많다.\n제발 가로로 길게 쓰지 않았으면 좋겠다. 코드 볼때 커서는 위-아래만으로도 충분하다. if문에 검사 조건이 많으면 책에서 얘기하듯 함수로 추출하던가, 아니면 \u0026amp;\u0026amp;이나 || 기준으로 줄을 나눠 썼으면 좋겠다. 한 줄에 다 쓴다고 이해가 더 잘 되는 것도 아니다.\n나는 심지어 아직도 80자를 기준으로 잡고 있다. (가끔 애매한 것은 80자를 넘기는 경우도 있지만, 기본적으로 80자를 넘기지 않으려고 노력한다.)\n가로 공백과 밀집도 연산자 사이에 공백을 둬서 무슨 연산이 일어나는지 알기 쉽게 하자.\n가로 정렬 정렬하는데 피로도는 높아지고, 그렇다고 딱히 효율적이지도 않다. 오히려 타입과 변수명을 멀리 떨어뜨림으로서 그 관계성이 약해지게 만든다.\n들여쓰기 리눅스 커널 코딩 스타일을 예시로 들고 싶다.\n들여쓰기의 폭을 4칸, 2칸도 아닌 기본 설정인 8칸으로 할 것을 권장한다. 분명 비효율적인 것은 맞지만, 이로 인해 현재 들여쓰기가 과도하게 일어나고 있는 것은 아닌지 되돌아보게 해준다.\n팀 규칙 로마에 오면 로마 법을 따라야 한다. 책에서 설명한 형식이 현재 업무에 사용하는 형식보다 좋아보이더라도 일단은 현재 형식을 따르는 것이 더 중요하다.\n제일 처음에 이야기했듯, 코드를 통해 의사소통을 할 때 서로 지정된 규정대로 대화하는 것이 좋다.\n","description":"","id":8,"section":"posts","tags":["클린 코드","코딩 스타일"],"title":"Clean Code 5장: \"형식 맞추기\" 정리","uri":"https://devlog.jsyoo5b.net/ko/posts/clean-code/ch05/"},{"content":"4장 주석을 읽으면서 내용에 대해 보충하거나, 개인적인 의견으로 반박하거나, 고민해 볼 부분에 대해 적어보려 한다.\n4장에서는 본격적인 이야기 전 서론부터 주석에 대해 잘 해봐야 필요 악 정도라는 표현 등 매우 부정적으로 취급하고 있다. 프로그래밍을 처음 배울 때는 주석을 꼭 써야 식으로 교육받았던 것 같지만, 나도 경험이 생김에 따라 주석에 대한 관점은 이 책처럼 어쩔 수 없이 최소한으로 작성하는 것이라 생각한다.\n주석은 나쁜 코드를 보완하지 못한다 보통 주석을 작성하는 이유는 코드가 더럽기 때문이다. 작성한 모듈이 헷갈리고 체계적이지 않다는 이유로 주석을 달곤 하는데, 코드를 정리하는 것이 더 낫다.\n어질러진 코드에 변명처럼 주석을 다는 데 시간을 보내지 말고, 깨끗한 코드를 작성하란 뜻이다.\n코드로 의도를 표현하라 그나마 주석을 잘 작성하는 의도는 왜 이런 코드/흐름을 사용하는가를 설명하는 것이라 생각한다. 하지만 책에서는 그 조차도 최대한 코드만으로 표현하라고 한다.\n주석을 사용한 의도 표현 함수명만 사용한 의도 표현  // Check to see if the employee is eligible for full benefits if ((employee.flags \u0026amp; HOURLY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65))   if (employee.isEligibleForFullBenefits())     'use strict'; var containerId = JSON.parse(\"\\\"8b33a06471741983\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  해당 예시는 좋을 수도, 나쁠 수도 있다고 생각한다. 책에서 의도하는 대로 직관적인 함수 명으로 주석을 대체할 수 있다면 좋겠지만, 해당 코드의 내용처럼 함수로 구분해야 할 만큼 자주 나오거나, 내용이 복잡할까? 차라리 캡슐화를 더 보강하기 위해 멤버 변수에 직접 접근하지 않고 메서드로 추출했다고 하는 편이 더 논리적인 것 같다.\n좋은 주석 일부 주석은 필수적이거나 도움이 된다. (물론 주석이 없는 것이 더 도움이 된다.)\n법적인 주석 각 코드에 저작권 및 소유권에 관한 법률 정보를 작성해야 하는 경우가 있다. 오픈 소스의 경우 각 라이선스에 관한 경고문이라거나, 업무 상의 코드는 회사의 법적 소유권을 증명하기 위해 필요하다.\n사실 좋은 주석이라기보단 불가피하게 보존해야만 하는 주석이라는 표현이 맞을 것 같다. (사업적으로는 영향을 줄 수도 있겠지만, 개발자에게는 거의 영향을 주지 못하기 때문에)\n정보를 제공하는 주석 기본적인 정보를 제공하기 위해 작성된 주석을 예시로 들고 있다.\n아래와 같이 추상 메서드의 반환 값에 대한 설명을 하는 주석을 보자.\n메서드 반환 정보 주석 함수 이름 리팩토링으로 주석 제거  // Returns an instance of the Responder being tested. protected abstract Responder responderInstance();   protected abstract Responder responderBeingTested();     'use strict'; var containerId = JSON.parse(\"\\\"7859339fe72d5791\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  그런데 위의 예시와 같은 추상 메서드는 팩토리 패턴 계열이나, 싱글턴 패턴에서 인스턴스를 생성하거나 받기 위해 사용할 것으로 보이는데, getInstance() 식의 함수 명이 아닌 것도 이상하고, 고친 예시로 나온 responderBeingTested()도 명사구로 표현된 메서드라는 점에서 이상한 것 같다. (테스트 혹은 검사를 위해 추상 메서드를 사용하는 것도 이상하다는 생각이 든다.)\n다른 예시로 정규표현식의 결과를 표현하는 주석을 보여주고 있다.\n메서드 반환 정보 주석 Java 내장 메서드 사용  // format matched kk:mm:ss EEE, MMM dd, yyyy Pattern timeMatcher = Pattern.compile( \u0026#34;\\\\d*:\\\\d*:\\\\d* \\\\w*, \\\\w* \\\\d, \\\\d*\u0026#34;);   SimpleDateFormat timeMatcher = new SimpleDateFormat(\u0026#34;kk:mm:ss EEE, MMM dd, yyyy\u0026#34;);     'use strict'; var containerId = JSON.parse(\"\\\"28d93843076864f9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  정규표현식의 경우 \u0026ldquo;Write once, read never\u0026quot;같은 소리가 나오는 가독성 면에서는 좋지 않은 표현이니, 이를 설명하기 위해 어떤 형태의 문자열이 매칭되는지 설명하는 것이 좋은 예시라며 보여주고 있다. (예시의 정규표현식이 잘못된 패턴도 매칭시킬수 있다는 문제가 있다는 점은 일단 무시하겠다.)\n설명에서는 SimpleDateFormat.format() 함수를 언급하면서 해당 기능을 처리하기 위한 클래스로 추출하는 것이 더 좋을 것이라고 언급을 하는데, 결국 어디선가는 이런 정규표현식에 대한 설명이 필요할텐데, 새로운 객체 내부로 주석에 대한 책임을 미루겠다는 것으로 밖에 안들린다.\n그리고 정규표현식의 예시는 아래 의미를 명료하게 밝히는 주석에서 언급하는 것이 더 좋지 않았을까?\n게다가 초반에 코드로 의도를 표현하라에서 예시로 보여준 것을 다시 반박하는 것 같다.\n의도를 설명하는 주석 전적으로 동의한다. 무엇을 할 것인지는 함수/모듈 이름이 표현하고 있고, 어떻게 할 지는 코드의 흐름이 표현하고 있다. 왜 이런 식으로 수행해야 하는 지에 대한 설명은 함수/모듈 이름이나 코드의 흐름만으로는 표현하기 힘들다.\n물론 구구절절 모든 코드 문단마다 이유를 작성할 필요는 없다. 갑작스레 나타난 코드 흐름이라던가, 직관적으로 이해되지 않는 코드에 대해 어떤 의도를 가지고 작성된 것인지 설명만 해도 충분할 것이다.\n함수 반환의 의도를 설명하는 주석 중간에 직관적으로 이해되지 않는 코드 흐름에 대한 설명  public int compareTo(Objcet o) { if (o instanceof WikiPagePath) { WikiPagePath p = (WikiPagePath) o; String compressedName = StringUtil.join(names, \u0026#34;\u0026#34;); String compressedArgumentName = StringUtil.join(p.names, \u0026#34;\u0026#34;); return compressedName.compareTo(compressedArgumentName); } return 1 // we are greater because we are the right type }   public void testConcurrentAddWidgets() throws Exception { WidgetBuilder widgetBuilder = new WidgetBuilder(new Class[](BoldWidget.class)); String text = \u0026#34;\u0026#39;\u0026#39;\u0026#39;bold text\u0026#39;\u0026#39;\u0026#39;\u0026#34;; ParentWidget parent = new BoldWidget(new MockWidgetRoot(), \u0026#34;\u0026#39;\u0026#39;\u0026#39;bold text\u0026#39;\u0026#39;\u0026#39;\u0026#34;); AtomicBoolean failFlag = new AtomicBoolean(); failFlag.set(false); // This is our best attempt to get a race condition  // by creating large number of threads.  for (int i = 0; i \u0026lt; 25000; i++) { WidgetBuilderThread widgetBuilderThread = new WidgetBuilderThread(widgetBuilder, text, parent, failFlag); Thread thread = new Thread(widgetBuilderThread); thread.start(); } assertEquals(false, failFlag.get()); }     'use strict'; var containerId = JSON.parse(\"\\\"8a9a006b016025e9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  직관적으로 이해되지 않는 코드 흐름에 대한 설명을 위해 주석을 다는 것은 좋으나, 나라면 앞에 FIXME나 HACK, XXX같은 태그를 붙였을 것이다. (아래 TODO 주석에서 다시 설명할 것이다.)\n의미를 명료하게 밝히는 주석 가끔씩 코드의 내용이 복잡하거나 가독성이 낮은 부분을 설명해주기 위한 주석도 좋다. (함수 인자로 들어가는 값이 복잡하거나, 결과 값이 직관적이지 않을 때) 원칙적으로는 복잡한 부분을 해소시켜서 코드만으로 의미를 알 수 있게 하는 것이 좋으나, 표준 라이브러리 안의 내용이라던가, 내부 코드를 교체할 수 없는 상황(외부 라이브러리 사용 등)에서는 이러한 부분이 도움이 될 수 있다.\n의미를 설명하는 주석  public void testCompareTo() throws Exception { WikiPagePath a = PathParser.parse(\u0026#34;PageA\u0026#34;); WikiPagePath ab = PathParser.parse(\u0026#34;PageA.PageB\u0026#34;); WikiPagePath b = PathParser.parse(\u0026#34;PageB\u0026#34;); WikiPagePath aa = PathParser.parse(\u0026#34;PageA.PageA\u0026#34;); WikiPagePath bb = PathParser.parse(\u0026#34;PageB.PageB\u0026#34;); WikiPagePath ba = PathParser.parse(\u0026#34;PageB.PageB\u0026#34;); assertTrue(a.compareTo(a) == 0); // a == a  assertTrue(a.compareTo(b) != 0); // a != b  assertTrue(ab.compareTo(ab) == 0); // ab == ab  assertTrue(a.compareTo(b) == -1); // a \u0026lt; a  assertTrue(aa.compareTo(ab) == -1); // aa \u0026lt; ab  assertTrue(ba.compareTo(bb) == -1); // ba \u0026lt; bb  assertTrue(b.compareTo(a) == 1); // b \u0026gt; a  assertTrue(ab.compareTo(aa) == 1); // ab \u0026gt; aa  assertTrue(bb.compareTo(ba) == 1); // bb \u0026gt; ba }     'use strict'; var containerId = JSON.parse(\"\\\"9894f80ed0386196\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  앞에서 언급했듯, 정규표현식이야말로 대체 불가능한 복잡한 코드라고 생각한다.\n결과를 경고하는 주석 테스트 수행 시간을 경고하는 주석 적절한 경고 주석  // Don\u0026#39;t run unless you have some time to kill public void _testWithReallyBigFile() { writeLineToFile(10000000); response.setBody(testFile); response.readyToSend(this); String responseString = output.toString(); assertSubString(\u0026#34;Content-Length: 1000000000\u0026#34;, respnseString); assertTrue(bytesSent \u0026gt; 1000000000); }   public static SimpleDateFormat makeStandardHttpDateFormat() { // SimpleDateFormat is not thread safe.  // so we need to create each instance independently.  SimpleDateFormat df = new SimpleDateformat(\u0026#34;EEE, dd MMM yyyy HH:mm:ss z\u0026#34;); df.setTimeZone(TimeZone.getTimeZone(\u0026#34;GMT\u0026#34;)); return df; }     'use strict'; var containerId = JSON.parse(\"\\\"8c27f00d6d46cd05\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  첫 번째 예시의 경우, 수행 시간이 오래 걸린다는 점을 경고하고 있다. (테스트 자체가 효율적인지에 대한 의문은 들지만, 부하 테스트 등에서 필요할 수도 있으니 넘어가도록 하자.) 물론 책에서 언급하였듯 JUnit4 이후로는 @Ignore같은 어노테이션을 활용할 수 있다.\n아래 TODO 주석에서도 설명하겠지만, 이런 내용의 경고를 강조하려면, 주석 앞에 NOTE나 WARN 등의 태그를 붙이는 것이 더 효율적이라고 생각한다.\nTODO 주석 위에서도 몇번이고 언급했지만, TODO는 좋은 주석이라고 생각한다. 코드에 어떤 부분이 부족하고, 뭘 해야 할 지를 정확히 알려주기 때문이다. 게다가 TODO를 포함하여 자주 사용되는 주석의 태그들은 IDE에서 자동으로 하이라이트 해주고, 쉽게 찾을 수 있도록 도와주기 때문에 코드를 읽을 때도 도움이 된다 생각한다.\n자주 사용되는 주석의 태그들은 아래와 같다.\n TODO : 아직 해당 기능이 작성되지 않았지만, 코드 틀을 작성하느라 임시로 생성한 함수를 표현할 때 FIXME : 임시 방편으로 작성된 코드거나(하드 코딩), 수정이 필요하다고 논의된 코드에 메모를 남길 때 HACK : 문제를 회피하는 기법에 대한 메모, 직관적으로 이해하기 힘들지만 효율적인 코드에 대한 간단한 설명에 사용 XXX : 경고를 표현할 때 사용, WARN 등으로도 표현  위의 태그들은 공식적으로 지정된 규칙은 없지만, 어느 환경에서나 TODO, FIXME는 공통적으로 활용된다.\n물론 더러운 코드를 작성해 놓고 TODO등으로 메모만 해놓고 방치하면 이런 주석 태그의 효과가 약해지므로, 남발하지 않는 것이 좋다.\nTODO나 FIXME는 책에서 어느정도 설명이 되었으니, HACK을 적용하는 예시를 보여주도록 하겠다.\n전처리기를 사용한 설명 주석에서 코드를 첨부한 설명  // HACK: Get counts of packing payload without branch #if 0// unoptimized version pkt_cnt = size / PKT_PAYLOAD_MAX; if (size % PKT_PAYLOAD_MAX \u0026gt; 0) pkt_cnt += 1; #endif  pkt_cnt = (size + PKT_PAYLOAD_MAX - 1) / PKT_PAYLOAD_MAX;   // HACK: Get counts of packing payload without branch  // pkt_cnt = size / PKT_PAYLOAD_MAX;  // if (size % PKT_PAYLOAD_MAX \u0026gt; 0)  // pky_cnt += 1;  pkt_cnt = (size + PKT_PAYLOAD_MAX - 1) / PKT_PAYLOAD_MAX;     'use strict'; var containerId = JSON.parse(\"\\\"7e8fbc16bb2380cb\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  중요성을 강조하는 주석 아래와 같이 코드 흐름에서 강조를 해 주는 주석이 있다. (NOTE 등으로 강조를 해 주는 것이 좋다고 생각한다.)\ntrim()이 필수적인 이유를 설명하는 주석  String listItemContent = match.group(3).trim(); // the trim is real important. It removes the starting // spaces that could cause the item to be recognized // as another list. new ListItemWidget(this, listItemContent, this.level + 1); return buildList(text.substring(match.end()));     'use strict'; var containerId = JSON.parse(\"\\\"cb6f1d2bc22cc846\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  공개 API에서 Javadocs 잘 작성된 API 문서는 큰 도움이 된다. 사실 좋은 개발 방법은 구글(+스택 오버플로우)에 검색하는 것 보다 공식 문서를 보면서 작성하는 것이 더 좋다. (물론 방법을 모를 때는 어떤 문서를 봐야 할지 모르니 검색을 할 수 밖에 없지만 이미 사용할 함수/클래스를 알고 있을 때, 공식 문서가 가장 좋은 예시를 보여준다 생각한다.)\nJava의 경우, Javadoc 기능으로 각 함수에 대한 문서화를 자동으로 수행해 주며, C/C++ 등은 doxygen 등의 도구를 활용하여 문서화를 자동 생성하기도 한다.\n이런 문서화 도구에서 아래와 같은 내용들을 표현한다.\n 설명: 짧은 설명(brief), 긴 설명(description)으로 해당 함수/클래스에 대한 역할, 수행 결과 등을 설명한다. 인자: 함수의 인자, 클래스 생성 인자 등을 설명한다. (param이나 arg 등으로 표현되며, C/C++같은 경우는 포인터/레퍼런스를 통해 함수에서 값을 변경하는 경우도 있으므로 param[in], param[out] 등의 표기도 사용된다.) 반환: 함수가 반환하는 값에 대해 설명한다. (return 등으로 표현) 예외: Java같이 예외 처리를 자주 사용하는 언어는 거의 필수적으로 나온다. 해당 함수를 수행할 때 어떤 경우에 어떤 형식의 예외가 발생하는지 설명한다. (throws 등으로 표현)  나쁜 주석 위의 좋은 주석에 해당하지 않는 대부분의 주석이 나쁜 주석에 해당한다.\n주절거리는 주석 기왕 주석을 써야 한다면, 시간을 들여서 꼭 필요한 중요한 주석만 작성해라.\n같은 이야기를 중복하는 주석 어차피 코드에서 충분히 의도와 맥락이 설명되고 있다면, 같은 이야기를 중복하는 주석은 코드를 읽는 시간만 느리게 할 뿐이다.\n코드 내용으로 이해할수 있는 것을 설명하는 주석 굳이 하나하나 설명하는 주석  // Utility method that returns when this.closed is true. Throws an exception // if the timeout is reached. public synchronized void waitForClose(final long timeoutMillis) throws Exception { if (!closed) { wait(timeoutMillis); if (!closed) throw new Exception(\u0026#34;MockResponseSender could not be closed\u0026#34;); } }   public abstract class ContainerBase implements Container, Lifecycle, Pipeline, MBeanRegistration, Serializable { /** * The processor delay for this component. */ protected int backgroundProcessorDelay = -1; /** * The lifecycle event support for this component. */ protected LifecycleSupport lifecycle = new LifecycleSupport(this); /** * The container event listeners for this Container. */ protected ArrayList listeners = new ArrayList(); /** * The Loader implementation with which this Container is * associated. */ protected Loader loader = null; /** * The Logger implementation with which this Container is * associated. */ protected Log logger = null; /** * Associated logger name. */ protected String logName = null; /** * The Manager implementation with which this Container is * associated. */ protected Manager manager = null; /** * The cluster with which this Container is associated. */ protected Cluster cluster = null; /** * The human-readable name of this Container. */ protected String name = null; /** * The parent Container to which this Container is a child. */ protected Container parent = null; /** * The parent class loader to be configured when we install a * Loader. */ protected ClassLoader parentClassLoader = null; /** * The Pipeline object with which this Container is * associated. */ protected Pipeline pipeline = new StandardPipeline(this); /** * The Realm with which this Container is associated. */ protected Realm realm = null; /** * The resources DirContext object with which this Container * is associated. */ protected DirContext resources = null;     'use strict'; var containerId = JSON.parse(\"\\\"3c2023d06921ac94\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  오해할 여지가 있는 주석 다른 나쁜 주석들은 불필요하고 괜히 관심을 끄는 주석이라면, 이런 주석은 말 그대로 나쁜 주석이다. 코드를 이해하는 것을 방해하기 때문이다.\n의무적으로 다는 주석 의무적으로 작성된 Javadoc  /** * * @param title The title of the CD * @param author The author of the CD * @param tracks The number of tracks on the CD * @param durationInMinutes The duration of the CD in minutes */ public void addCD(String title, String author, int tracks, int durationInMinutes) { CD cd = new CD(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = duration; cdList.add(cd); }     'use strict'; var containerId = JSON.parse(\"\\\"310c1d05ec21f018\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  코드 작성할 때 주석에 대한 피로도를 높이는 주범이다. 모든 함수/클래스에 문서화 작업을 강제하면 불필요한 주석을 작성하게 만든다.\n나의 경우 함수의 구조를 설계하다가 인자가 변경되는 경우, 해당 문서화 주석이 코드의 변화를 못 따라가는 경우도 있었다. (사실 함수 인터페이스를 변경하지 않도록 잘 고민해서 시작하는 것이 더 좋다는 것은 나도 알고있다.)\n이력을 기록하는 주석 릴리즈 노트나 패치 노트에 언급할 내용을 주석에 작성하지 말자. 형상 관리 시스템을 잘 사용하면 다 알 수 있다. (코드 배포가 직접적으로 소스만 전달되면 모르겠지만, 이건 배포 방법이 구식이라는 점도 생각해봐야한다.)\n있으나 마나 한 주석 당연한 걸 굳이 하나하나 설명하는 주석은 어떠한 도움도 주지 못한다. (기본 생성자라고 설명하는 주석이나, 뻔히 변수/함수 명으로 설명되는 것을 설명하는 주석)\n무서운 잡음 return 0; // 0을 반환한다. 같은 주석. 보통 프로그래밍을 처음 배울 때 문법 자체에 익숙하지 않은데다 주석을 작성하라고 해서 그대로 작성하는 주석들은 특히 쓸모가 없다.\n굳이 이런 주석이 의미가 있으려면, return 0; // 정상 종료 같이 코드상으로 바로 이해가 안 되는 흐름을 설명할 때겠지만, 이것도 return EXIT_SUCCESS; 같이 리팩토링하여 주석을 제거할 수 있다.\n함수나 변수로 표현할 수 있다면 주석을 달지 마라 같은 이야기를 중복해서 표현하는 주석이나 다름없다. 함수를 통해 무슨 일을 하는지 설명하고, 변수를 통해 이 변수가 어떤 의도로 값을 저장하는지를 나타낼 수 있다면 주석은 불필요하다.\n굳이 설명하는 주석 함수나 변수명으로만 표현한 코드  // does the module from the global list \u0026lt;mod\u0026gt; depend on the // subsystem we are part of? if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem()))   ArrayList moduleDependees = smodule.getDependSubsystems(); String ourSubSystem = subSysMod.getSubSystem(); if (moduleDependees.contains(ourSubSystem))     'use strict'; var containerId = JSON.parse(\"\\\"8cb4f1749b7f0e7b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위치를 표시하는 주석 소스 코드의 길이가 길어질 때, 역할 별로 코드를 구분하기 위해 구분자 같은 주석을 사용하기도 한다.\nC#의 경우, #region ~ #endregion을 통해 코드의 구역을 나눠서, 에디터(비주얼스튜디오)에서 접어 둘 수도 있게 하는 기능을 제공하기도 한다.\n닫는 괄호에 다는 주석 제일 간단한 해결법이 있다. 들여쓰기를 작작 하자. 들여쓰기 횟수가 많지 않으면 이 부분이 어느 부분을 닫는 괄호인지 고민할 일이 줄어든다.\n예전 회사 코드에서는 4중, 5중 if문을 본 적이 있다. 아무리 생각해봐도 성능 효율이 아니라 그냥 생각나는 대로 작성한 코드였던 것 같다. if문 안에 조건 검사가 여러 차례 걸쳐서 일어난다면, \u0026amp;\u0026amp; 등을 활용하자. 어차피 short circuit evaluation으로 인해 불필요한 조건 검사는 일어나지 않는다.\n만약 if 안에 if-else가 연속해서 나타나는 상황이라면, 한두개 정도는 \u0026amp;\u0026amp; 등으로 묶어도 되지만, 그 이상이 된다면 조건문을 해석하는 데 시간이 많이 걸리기 때문에, 이런 경우는 함수로 구분하여 작성하는 것이 좋다. (한 함수 안에서 if-else문의 중첩이 자주 일어난다면, 해당 함수가 너무 많은 맥락을 한번에 표현하려는 것이라고 볼 수 있다.)\n공로를 돌리거나 저자를 표시하는 주석 이전 회사에서 이런 주석을 많이 봤는데, 솔직히 내 코드에 불만 있으면 자리로 찾아오던가로 밖에 안 들린다. 제대로 된 형상 관리 시스템을 사용하고 있다면 변경분마다 작성자 정보가 나타날 것이기 때문에 저자를 표시하는 것은 무의미하다.\n그리고, 수정한 부분에 자기 이름을 남겨놓고, 잊고 있다가 나중에 다른 사람이 해당 코드 수정 이유에 대해 질문하러 찾아올 때, 모든 수정 사항과 그 이유를 기억할 수 있을까? 이런 주석은 남발할수록 서로에 대한 신뢰를 천천히 잃게 한다.\n주석으로 처리한 코드 디버깅 중, 동작 확인을 위해 일부 코드 행을 주석처리 하곤 한다. 이런 실험을 끝냈으면 해당 주석을 남겨놓으면 안된다. 다른 사람이 보기에 이 주석 처리된 코드는 중요해서 남겨둔건가? 라고 생각해서 완전히 지우지 못할 수도 있다.\nC/C++에서는 #if 0 ~ #endif 등의 전처리기를 이용해 주석처리를 하지 않고도 일부 코드를 비활성화 할 수 있다.\nHTML 주석 보통 Javadoc같은 문서화 도구는 HTML 형태로 출력하기 때문에 강조나 문맥 구분 등을 위해 관련 주석 중간에 HTML을 삽입하기도 하는데, 코드를 읽는 입장에서 방해되는 요소다.\n전역 정보 주석을 작성한다면, 해당 주석 근처의 코드만 서술해야한다. 너무 멀리 있는 내용을 서술하면 주석 및 코드를 이해하기 위해 계속 소스 코드를 오고 가며 읽어야 하기 때문에 불편하기 때문이다.\n너무 많은 정보 이 코드가 왜 이렇게 되었는 지에 대한 과거 배경을 설명한다던가, 불필요할정도로 자세한 정보를 작성할 필요는 없다.\n책에서는 base64 인코딩/디코딩 모듈을 테스트하는 모듈에서 base64 인코딩/디코딩 방법을 설명하는 주석을 보여주고 있다. 굳이 자세한 정보를 주고 싶다면, base64가 정의된 RFC 문서 번호, 해당 부분을 찾을 수 있는 목차 번호 정도만 제공되어도 충분하다.\n모호한 관계 주석의 설명과 코드 사이에 간극이 있는 경우를 말한다.\n 주석에서 의도는 한 부분만 설명하는데, 코드에서 여러 부분을 동시에 처리하는 경우 수식이 복잡한데 의도만 설명해서 해당 수식을 이해하기 힘든 경우  함수 헤더 짧은 함수는 설명이 많이 필요하지 않다. 함수 이름만 잘 선택해도 주석이 불필요하다.\n비공개 코드에서 Javadocs 이전의 좋은 주석에서 공개 API에서 Javadocs를 좋은 주석이라고 했다. 함수/클래스를 설명하는 주석은 분명 좋은 주석이다. 하지만 해당 주석의 대상 독자는 내가 작성한 코드를 재사용하는 프로그래머가 의도에 맞게 사용할 수 있도록 정보를 알리는 데 있다.\nJavadoc 같은 도구는 코드를 작성하면서 문서화 작업을 동시에 처리할 수 있도록 도움을 준다. 그리고 아마 대부분의 프로그래머가 문서화는 필요하지만 귀찮다고 생각하고 있을 것이다. 그러므로 문서화는 꼭 필요한, 외부로 공개하는 코드에만 작성하는 것이 좋다. 비공개 코드에도 문서화 작업을 계속 하다 보면 문서화/주석 작성에 피로도를 느끼게 할 수도 있기 때문이다.\n마치면서 사실 주석이 부정적으로 취급되는 가장 큰 이유는 코드의 변화를 주석이 잘 따라가지 못하는 편이기 때문이다. 처음 코드 작성시에는 클래스/모듈/함수 설계 등으로 인해 목적을 정하고, 코드 흐름에 대한 메모로 주석을 잘 작성하는 편이다. 하지만 시간이 지날 수록 버그를 수정하면서 바뀐 코드 흐름에 맞춰 주석이 변경되지 않거나, 그대로 남아있는 경우가 있다.\n","description":"","id":9,"section":"posts","tags":["클린 코드","주석"],"title":"Clean Code 4장: \"주석\" 정리","uri":"https://devlog.jsyoo5b.net/ko/posts/clean-code/ch04/"},{"content":"2장 의미 있는 이름을 읽으면서 내용에 대해 보충하거나, 개인적인 의견으로 반박하거나, 고민해 볼 부분에 대해 적어보려 한다.\n들어가면서 프로그래머들은 변수, 함수, 클래스, 파일, 패키지/모듈, 프로젝트 이름 등 이곳 저곳에서 이름을 짓곤 한다.\n하지만 마치 태어날 아이의 이름을 짓는 것 처럼, 좋은 이름을 지어 주는 것은 상당히 어려운 일이다.\n의도를 분명히 밝혀라 변수, 함수, 클래스 등의 이름은 왜 이것이 존재하는지, 무엇을 하는지, 어떻게 쓰는 지 알려줘야 한다. 만약 해당 이름이 주석을 요구한다면 그것은 그 의도를 정확히 나타내지 못하는 것이다.\n안 좋은 변수 선언 수정한 변수 선언  int d; // elapsed time in days   int elapsedTimeInDays; int daysSinceCreation; int daysSinceModification; int fileAgeInDays;     'use strict'; var containerId = JSON.parse(\"\\\"f8a7af466321595b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  책에서 나온 예제로, 좀 더 상세한 정보를 나타내길 바라고 있다. 하지만 나는 수정한 예시가 별로 좋지 못하다고 생각한다. (정확히는 예시의 시작부터 별로 좋지 못하다고 생각한다.)\n 단위가 변수 이름에 나오는데, 이는 변수 명이 너무 장황하게 한다. daysSinceCreation, daysSinceModification은 모두 days로 시작하는데, 복수 표현으로 인해 collection형 타입으로 의심할 수도 있다. 해당 변수 존재 자체가 무의미하다 생각한다.\n내 생각에 변수는 중요한 정보를 담기 위해, 계산 과정이 복잡한 결과를 보관하기 위해, 중간 상태를 저장하기 위해 존재해야 한다고 생각한다. 하지만 이렇게 시간 간격을 나타내는 값은 단순하게 timestamp 간 차이로 알 수 있다. 요즘 IDE의 자동완성, 정의 미리보기 등의 기능을 고려했을 때, 해당 주석이 잘 보일 가능성이 높다. 내가 영어를 잘 못하는 것일 수도 있지만, int elapsedDays로도 충분해보인다.  의도를 알 수 없는 함수 1차 리팩토링 2차 리팩토링  public List\u0026lt;int[]\u0026gt; getThem() { List\u0026lt;int[]\u0026gt; list1 = new ArrayList\u0026lt;int[]\u0026gt;{}; for (int[] x : theList) if (x[0] == 4) list1.add(x); return list1; }   public List\u0026lt;int[]\u0026gt; getFlaggedCells() { List\u0026lt;int[]\u0026gt; flaggedCells = new ArrayList\u0026lt;int[]\u0026gt;{}; for (int[] cell : gameBoard) if (cell[STATUS_VALUE] == FLAGGED) flaggedCells.add(cell); return flaggedCells; }   public List\u0026lt;Cell\u0026gt; getFlaggedCells() { List\u0026lt;Cell\u0026gt; flaggedCells = new ArrayList\u0026lt;int[]\u0026gt;{}; for (Cell cell : gameBoard) if (cell.isFlagged()) flaggedCells.add(cell); return flaggedCells; }     'use strict'; var containerId = JSON.parse(\"\\\"0c8e84efadea23b0\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  초기 코드에서는 theList가 무엇인지도 알 수 없고, 왜 배열의 0번째 요소를 확인하는지, 왜 값이 4인지 확인하는지에 대한 정보를 알 수 없다. 또한 list1이 코드 흐름에 따르면 무엇인가를 찾아서 그 목록을 반환해주는 것은 알 수 있지만 적절한 이름으로는 보이지 않는다.\n1차 리팩토링 과정에서는 위의 문제를 해결하도록 변수, 상수 명을 교체, 선언했다.\n2차 리팩토링 과정에서는 코드를 단순화 하면서 왜 getFlaggedCells()의 반환 타입이 int[]인지 고민하지 않도록 Cell이란 클래스로 추상화하였다. 또한 이를 추상화 함으로서 실제 배열의 특정 인덱스 값을 비교하는 것에서 간단한 확인 함수를 호출하는 것으로 변경하였다.\n1차 리팩토링까지는 격하게 공감하지만, 2차 리팩토링의 경우 조금 의문을 갖게 한다.\n 해당 Cell이란 클래스가 따로 클래스로 구별되어야 할 만큼 추상화가 필요할까? 간단한 비교문을 확인하기 위해 메서드 isFlagged()가 호출된다.\n함수 호출로 인한 시간적 비용이 추가된다. (차라리 비트 연산을 통해 확인하는 것이었다면 함수로 표현한 것이 더 좋은 추상화라 생각한다.) Cell을 클래스로 추상화했다면, 해당 메서드는 다른 클래스의 멤버 메서드가 아니라, Cell 클래스의 static 메서드여야 더 적절하지 않을까?  위의 예시들은 의미 있는 이름을 표현하기 위한 단적인 예시를 보여주느라 복합적인 상황은 판단하지 못한 것으로 보인다.\n그릇된 정보를 피하라 프로그래머들은 코드에 잘못된 단서를 남기는 것을 피해야 한다. 이 잘못된 단서로 인해 전체 코드의 의미를 오해할 수 있기 때문이다.\n예를 들어 accountList는 해당 변수가 진짜 List 형식이 아니라면 사용하지 말고, 차라리 accountGroup, bunchOfAccounts, 혹은 그냥 accounts로 표현하는 것이 더 낫다고 한다.\n나도 약간 비슷한 기법을 사용하는데, collection형 타입(배열, 템플릿 기반 자료구조 등)은 언제나 복수로 표현한다. 한국어와 달리 영어는(당연히 코드를 영어로 작성하니 영어만 말하는 것이다.) 단수, 복수 표현이 엄밀하게 구분되므로, 복수 표현만으로 collection형 정보를 나타낼 수 있다는 것은 매우 경제적이라 생각한다.\n변수명에서 헷갈리는 글자를 쓰지 말라고 하면서, 소문자 L, 대문자 i, 숫자 1들을, 대문자 o, 숫자 0를 섞어 사용하지 말라고 한다. 그런데 이건 프로그래머라면 이런 글자들을 잘 구분할 수 있는 폰트를 사용하고 있을텐데, 그렇게 치명적인 문제가 될 수 있는지 모르겠다. 게다가 IDE에서 자동완성이나 문법 검사 등으로 경고를 해줄텐데 말이다.\n의미 있게 구분하라 수열 형태의 이름(a1, a2, a3\u0026hellip;)은 의도를 알 수 없는 이름의 대표적인 예시이다.\n수열 형태의 이름 의도를 표현하는 이름  public static void copyChars(char a1[], char a2[]) { for (int i = 0; i \u0026lt; a1.length; i++) { a2[i] = a1[i]; } }   public static void copyChars(char src[], char dst[]) { for (int i = 0; i \u0026lt; src.length; i++) { dst[i] = src[i]; } }     'use strict'; var containerId = JSON.parse(\"\\\"15a2168223b09b6e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  책에서 설명한 예시처럼 복사할때 원본과 복사본을 잘 구분할 수 있게 수정해 본 예시다.\n그 외에도 무의미하게 비슷한 이름은 헷갈리게 하는 명명법 중 하나라고 하면서 아래 예시를 보여주고 있다.\ngetActiveAccount(); getActiveAccounts(); getActiveAccountInfo(); 그런데 위에서 얘기한 것 처럼 나는 복수 표현으로 일반 변수와 collection형 변수를 구분하는데, 이 외에도 영어에서의 관사 표현과 관련된 이야기도 하고 있다.\n영어의 문법적인 용법을 모두 사용하는 것은 좋은 방법일 수도 있지만, (대부분이 개발용 표현 언어로 영어만 쓰는 상황에서) 오히려 기초지식을 요구하는 안 좋은 기법이 될 수도 있겠다는 생각이 든다.\n발음하기 쉬운 이름을 사용하라 축약한 변수명 발음하기 쉬운 변수명  class DtaRcrd102 { private Date genymdhms; private Date modymdhms; private final String pszqint = \u0026#34;102\u0026#34;; /* ... */ }   class Customer { private Date generationTimestamp; private Date modificationTimestamp; private final String recordId = \u0026#34;102\u0026#34;; /* ... */ }     'use strict'; var containerId = JSON.parse(\"\\\"1fdb68eb8c17739c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  전혀 동의되지 않는 기법이다. 일단 Java답게 쓸데없이 이름이 길어지는 것도 불필요하다고 생각하고, 변수 명을 저렇게 줄여놔도 당연히 서로 대화할 때는 풀어서 부르지 않을까?\n추가적으로 변수명을 축약하기 위한 내 기법은 다음과 같다.\n 적절한 영문 단어를 선택한다. 해당 영문 단어를 한글로 음독한다고 가정한다. 각 음절의 초성에 해당하는 알파벳으로 단어를 줄인다.  예를 들어, DB의 항목을 표현하는 변수를 Record라 했을 때, 레코드에서 rcd로 변수 명을 선언하고, 서비스를 svc로 선언하는 식이다.\n검색하기 쉬운 이름을 사용하라 솔직히 검색하기 쉬운 이름같은 표현보단 매직 넘버를 사용하지 말라고 표현하는게 더 간단한데, 굳이 이런 긴 설명이 필요했을까 싶다.\n인코딩을 피하라 대표적인 변수 이름을 인코딩 하는 방법인 헝가리식 표기법 위주로 설명을 하고 있다.\n책에서 다루는 헝가리식 표기법 외에도, 이전 회사의 경우 C언어에서 변수가 포인터인지, 일반 변수인지 구별을 위해 앞에 p나 t를 붙이는 방법도 사용해봤다.\n헝가리식 표기법 MFC 하면 신나게 볼 수 있는 헝가리안 표기법이다.\n나도 헝가리안 표기법이 안 좋은 표기법이라고 생각하는데, 아쉽게도 로마에서는 로마법을 따르라고, MFC에서는 헝가리안 표기법을 따르는게 가독성을 올리는 방법이다.\n헝가리안 표기법의 문제는 다음과 같다.\n 현대 IDE에서 변수의 자동완성은 쉽다. 자료형을 prefix에 표현하는데, 자료형이 변경될 때 매번 리팩토링 해 줘야 한다. 부자연스러운 표기법이 된다.  자신의 기억력을 자랑하지 마라 반복문의 인덱스 표현을 위한 i, j, k는 이미 전통적으로 사용되어왔고, 코드 상 해당 변수의 볌위가 넓지 않으므로 괜찮으나, 다른 부분에서 사용하는 짧은 글자의 변수는 좋지 않다.\n클래스 이름 클래스 이름은 명사 혹은 명사구여야 한다.\nManager, Processor, Data, Info같은 단어 사용을 피하라고 하는데, 이는 너무 일반화된 단어를 사용하여 해당 클래스의 의미를 모호하게 하지 말라는 것으로 보인다.\n클래스 이름은 동사가 되어선 안된다.\n메서드 이름 메서드 이름은 동사 혹은 동사구여야 한다.\n접근자, 수정자, 서술자(조건 확인)는 각각 get, set, is등으로 시작하여 해당 값을 나타내는 방식으로 표현해야 한다.\n생성자가 오버로딩 되어있는 경우, static 팩토리 메서드를 통해 어떤 값으로 생성되는지를 나타내라.\n기발한 이름은 피하라 대표적 실패한 예시로 리눅스의 kill, PHP5의 explode()가 생각난다. (개인적으로는 C++의 stl vector\u0026lt;\u0026gt;도 안 좋은 예시라 생각한다.)\nkill은 리눅스에서 프로세스를 종료시키는 명령어인데, 마치 살아있는 프로세스를 죽이는 것 처럼 표현하기 위해 kill이란 이름을 사용한 것으로 보인다. kill이란 표현법 자체가 비유인 것도 아쉽지만, 내부 동작 원리나, 실제 사용 예시 등을 고려했을 때 더 실패한 예시라 생각한다. kill의 내부 원리는 해당 프로세스에게 시그널을 보내는 것 뿐이다. 기본적으로 SIGTERM을 보내는데, 해당 시그널은 종료 요청일 뿐, 해당 프로세스가 바로 종료되지 않을 수도 있다. (보통 프로세스 종료 전 리소스 정리, 마무리 등을 할 수 있게 하려고 사용한다.) 섬뜩한 설명이지만, 상대를 죽일 때 유서를 쓸 시간도 주고, 인생을 정리 할 시간도 주고 죽이는가? kill의 의미에 더 적절한 시그널은 SIGKILL인데, (즉시 해당 프로세스가 종료된다.) 시그널의 이름이나, 명령어 역할이 완벽히 일치하지 않는 문제를 볼 수 있다.\nexplode()는 예전부터 봤던 실패한 함수 이름의 대표적인 예시다. 해당 문서를 보면 알 수 있겠지만, 문자열을 다른 경계 문자열로 자르는 함수다. 대부분의 프로그래밍 언어는 split()으로 해당 기능을 제공하며, C의 경우 strtok()으로 해당 기능을 제공한다. split()는 문자열을 분리한다는 의미를 내포하고 있으며, strtok()는 문자열을 토큰화 한다는 의미로 명명되었다. 하지만 explode()는 폭발시킨다는 뜻인데, 이것만으로는 문자열을 분리한다고 이해하기 힘들 수도 있다.\nvector\u0026lt;\u0026gt;는 Java의 ArrayList\u0026lt;\u0026gt;처럼 길이가 가변적인 배열을 표현하는 collection형 자료구조다. 일반적인 벡터라는 단어의 용례를 생각했을 때, 이 이름이 적절한지 의문이다. (물론 해당 자료구조를 사용해 정말 벡터를 표현할 수도 있겠지만, 일반적으로 사용할 수 있는 가장 적절한 이름은 절대 아닌 것 같다.)\n한 개념에 한 단어를 사용하라 프로그래밍 중에는 자주 사용하는 비슷한 개념의 용어들이 많다. fetch, retrieve, get 모두 무언가를 가져오거나 받을 때 사용할 만한 함수의 이름이다. 이런 식으로 비슷한 단어를 이용하여 이름을 지으면 나중에 코드를 읽거나, 검색할 때 헷갈리기 쉽다.\n책에서는 다른 예시로 controller, manager, driver가 모두 비슷한 역할처럼 보이기 때문에 정확한 용도를 구분하기 힘들다고 이야기 한다. 이전 회사에서는 한 프로젝트 안에서 저 단어들을 모두 사용하여 작업한 적이 있는데, 당시에는 각 단어들을 엄밀하게 정의했기 때문에 가능했다. (게다가 임베디드 환경은 이런 비슷하게 들리는 단어들을 자주 사용하는 편이다.)\n적절한 단어를 선택하고자 한다면 Thesaurus(유의어 사전)을 참고하는 것도 좋다. (좀 더 목적에 정확한 단어 선택을 위해 참고)\n말장난을 하지 마라 한 개념에 여러 단어를 사용했을 때의 문제와 반대로, 한 단어에 여러 개념을 표현하지 말라는 것이다.\n예를 들어 collection형 자료구조에서 add()를 사용한다면 특정 자료를 추가하는 것은 알 수 있으나, 특정 위치에 삽입되는지, 자료 구조의 특징에 따라 자율적으로 배치되는지, 다른 collection과 합치는 것인지 구분하기 힘들다. append()나 insert()로 목적을 더 정확하게 표현하는 것이 좋다.\n해법 영역에서 가져온 이름을 사용하라 당연히 코드를 읽는 프로그래머들은 컴퓨터과학 지식을 갖고 있을테니 컴퓨터과학 관련 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 활용하자.\n문제 영역에서 가져온 이름을 사용하라 도메인 전문 용어가 필요한 경우, 해당 용어를 사용하자.\n의미 있는 맥락을 추가하라 예를 들어 street, houseNumber, city, state, zipcode가 같이 선언된 코드 맥락에서 state는 주(미국 기준, 아마 한국 기준으로는 시/도)를 표현하는 것을 바로 알 수 있다. 하지만 다른 변수가 없이 그냥 state만 있었다면 상태를 나타내는 것이라고 생각할 수도 있다. 이럴 경우 앞에 맥락을 추가해서 의도를 분명히 할 수 있다. 예를 들어 addrState처럼 말이다.\n맥락이 불분명한 변수들 맥락을 지닌 변수들  private void printGuessStatistics(char candidate, int count) { String number; String verb; String pluralModifier; if (count == 0) { number = \u0026#34;no\u0026#34;; verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } else if (count == 1) { number = \u0026#34;1\u0026#34;; verb = \u0026#34;is\u0026#34;; pluralModifier = \u0026#34;\u0026#34;; } else { number = Integer.toString(count); verb = \u0026#34;are\u0026#34; pluralModifier = \u0026#34;s\u0026#34;; } String guessMessage = String.format( \u0026#34;There %s %s %s%s\u0026#34;, verb, number, candidate, pluralModifier ); print(guessMessage); }   public class GuessStatisticMessage { private String number; private String verb; private String pluralModifier; public String make(char candidate, int count) { createPluralDependentMessageParts(count); return String.format( \u0026#34;There %s %s %s%s\u0026#34;, verb, number, candidate, pluralModifier ); } private void createPluralDependentMessageParts(int count) { if (count == 0) { thereAreNoLetters(); } else if (count == 1) { thereIsOneLetter(); } else { thereAreManyLetters(count); } } private void thereAreManyLetters(int count) { number = Integer.toString(count); verb = \u0026#34;are\u0026#34; pluralModifier = \u0026#34;s\u0026#34;; } private void thereIsOneLetter() { number = \u0026#34;1\u0026#34;; verb = \u0026#34;is\u0026#34;; pluralModifier = \u0026#34;\u0026#34;; } private void thereAreNoLetters() { number = \u0026#34;no\u0026#34;; verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } }     'use strict'; var containerId = JSON.parse(\"\\\"411329285ec5e310\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  솔직히 예시로 보여준 코드에선 크게 공감이 가지 않는다. (그냥 주석으로 단수/복수 표현에 관련된 문법 표현을 변경한다고만 해도 충분해 보인다.)\n불필요한 맥락을 없애라 격하게 공감하는 바이다. 이전 회사의 코딩 스타일에서는 불필요할정도로 회사의 키워드를 prefix로 쓰는 경우가 많았다.\n특히 임베디드 환경이다 보니 정수형 타입도 비트 크기에 따라 U8, S32, 등으로 구분하여 표현하는 것이 좋은데, 굳이 그런 모든 타입에 회사 키워드 prefix를 붙이게 했다.\n회사내 정확한 코딩 컨벤션의 문서에서는 외부로 공유될 코드에는 해당 규칙을 따르라고 했는데, 솔직히 무슨 의미가 있나 싶다. 괜히 불필요한 타입 변환 경고만 출력하게 하고, 추상화가 잘 이루어 지는 것도 아니고, 그렇다고 구조체 수준의 복잡한 자료구조가 많았던 것도 아닌데 말이다.\n그나마 이런 prefix를 붙여서 의미 있는 경우라면, 여러 종류의 제품이나 환경을 합치는 adapter pattern을 적용할 때가 있을 것 같다.\n마치면서 역시 나는 Java가 싫은가보다. 여러 특성 중 Java의 장황함이 가장 싫어서 그런 것 같다.\n","description":"","id":10,"section":"posts","tags":["클린 코드","이름 짓기"],"title":"Clean Code 2장: \"의미 있는 이름\" 정리","uri":"https://devlog.jsyoo5b.net/ko/posts/clean-code/ch02/"},{"content":"1장 깨끗한 코드를 읽으면서 내용에 대해 보충하거나, 개인적인 의견으로 반박하거나, 고민해 볼 부분에 대해 적어보려 한다.\n코드가 존재하리라 내가 정확하게 기억하는 것인지 모르겠지만, 컴퓨터과학적으로 프로그래밍이 완전히 자동으로 대체될 수 없다고 한 내용을 봤던 것 같다. 문제는 어디에서 봤는지, 다시 찾으려면 어떤 키워드로 검색해야 하는지 기억이 안 난다는 거다.\n조금 더 높은 단계의 추상화를 위해 새로운 도메인 언어가 나오고, 고급 언어가 나오지만 아직도 막연한 요구사항을 구현하는 기술은 나오지 않았다. 아직 자연어로 컴파일되거나 실행되는 프로그래밍 언어는 나오지 않은 것으로 알고 있다.\n이미 최근에는 copilot이란 기술이 나와서 주석이나 함수 이름 등 문맥을 이해하고 코드를 생성해준다. 직접 경험해 보진 못했지만, 문맥에 따라 어느정도 패턴화 된 코드 블럭을 자동으로 제공해 주는 것으로 예상되는데, 결국 프로그래머가 개입을 해야한다는 사실은 아직까지 유지되는 것 같다.\n비주얼 스튜디오에서도 자동으로 함수나 코드 일부를 작성해 주지만, MFC에서 이벤트 핸들러 함수 등록도 원하는 수준으로 자동화 되지 않아서 결국 내가 직접 수정해서 써 버릇 했다. (여러 요소를 반복으로 등록할 수 없는 문제, 원하는 위치에 등록할 수 없는 문제때문에 직접 수정했다.)\n예전에 다른 과목 교수님이 우스갯소리로 하길, 설계 프로그램의 목적은 소프트웨어를 설계하는 것이지만, 실제로 가장 많이 사용되는 경우는 이미 작성한 코드로부터 구조를 읽어오기 위한 것이라고 했었다. 사양을 가장 잘 나타내는 문서는 코드라는 것에 대한 유사한 예시라고 할 수도 있겠다.\n아무리 코드가 사양을 가장 잘 나타내는 문서라지만, 설계문서가 필요 없다는 것은 아니다. 왜 이런 식으로 설계가 되었는지는 코드 밖에서 서술하는 수 밖에 없다. 대부분 유연한 확장성을 위한 코드 구조를 설계하는데, 이 부분은 코드에서 쉽게 나타낼 수 없을 것이다.\n나쁜 코드  르블랑의 법칙: 나중은 결코 오지 않는다.\n 당연한 사실이다. 프로젝트가 마감 기한을 끝내고 나면 리팩토링하면서 나쁜 코드를 수정할 기회가 오지 않는다. 사업 관점에서는 이미 요구사항을 만족했는데 왜 굳이 그걸 더 수정해야 하냐며 리팩토링 할 시간을 주지 않을 것이다.\n불가능한 이야기지만, 처음부터 잘 짜야 한다. 그렇다면 차선책은 무엇일까? 나의 차선책은 수정하기 쉽게 짜야 한다. 고 생각한다.\n나쁜 코드로 치르는 대가 나쁜 코드는 생산성을 떨어트린다. 생산성을 올리겠다고 사람을 더 투입하다간 브룩스의 법칙에 의해 생산성을 더 낮출 뿐이다.\n레거시 코드를 보면서 밀어버리고 다시 짜고 싶다는 생각은 어찌 보면 당연한 것이다.\n원대한 재설계의 꿈 결국 생산성 문제로 인해 새로 설계를 진행한다고 가정하자. 기존 생산성 낮은 프로젝트는 시장의 요구사항을 만족하며 계속 진행되긴 할 것이며, 새로운 설계 팀은 기존 프로젝트의 진행을 역전해야먄 완전히 대체될 수 있다. 아무리 레퍼런스 코드가 있다 한들 완전히 대체되는데 걸리는 시간은 길다. 빨리 역전하려고 서두를수록 기존의 실수를 범하기 쉽다. 결국 새로운 설계 프로젝트가 완성되더라도 밀어버리고 싶다는 생각이 다시 나오고, 반복된다.\n대표적으로 넷스케이프의 몰락이야기를 들 수 있겠다. (완전 동일한 이야기는 아니지만 맥락상 비슷한 이야기가 될 것으로 보인다.)\n웹 브라우저 시장을 잘 점유하던 넷스케이프는 넷스케이프 5부터 오픈소스화 하면서 코드를 공개했는데, 당시 코드가 너무 어렵다는 이유로 소스 코드를 다시 작성하기로 결정한다. 이 결정으로 넷스케이프는 다음 메이저 버전 배포가 늦어지고, 후에 출시한 넷스케이프 6는 준비가 덜 된 상태에서 출시한 수준이었다.\n물론 넷스케이프의 몰락에는 인터넷 익스플로러 끼워팔기도 어느정도 영향을 줬지만, 코드를 밀고 다시 짜는 이야기가 나올때 거의 매번 언급되는 것을 볼 수 있다. (학교에서도 몇번 들었고, 조엘 온 소프트웨어 책에도 나온다.)\n태도 깨끗한 코드가 중요한걸 알면서도 왜 굳이 더러운 코드로 작성하는가? 요구 사항이 바뀌기 때문에? 일정이 빡빡해서? 그런데 원인은 개발자 잘못이라고 한다.\n위의 조건(요구사항 변화, 빡빡한 마감)을 만족하면서 코드를 작성하는 방법은 더럽게 짜는 방법밖에 없다고 관리자를 설득해야 한다고 한다. 코드 작성에는 내가 전문가이니, 당연히 전문가로서 관리자를 설득해야 한다고 한다.\n의도는 알겠는데, 현실적으로 이런 설득이 먹혀들어가는 환경인지는 모르겠다. 대부분 그러면 야근으로 귀결되지 않나? 이런 설득이 안 통하는 경우에는 나쁜 직장이니 퇴사해야한다는 건가? 좋은 뜻으로 한 얘기겠지만, 약간 무책임해보이는 부분은 있다.\n원초적 난제 기존에 어질러진 코드들이 개발 속도를 낮춘다. 와 마감을 지키기 위해 코드를 더럽히는 수 밖에 없다는 압박감에 시달린다. 이 두가지 상반된 문장이 난제라는 것 같다.\n하지만 진짜 전문가들은 마감을 지키기 위해 코드를 더럽히는 수밖에 없다는 것이 틀렸다고 한다. 결국 어지럽힌 코드가 내 생산성을 떨어뜨릴 것이라는것이다.\n깨끗한 코드라는 예술? 그렇게 깨끗한 코드가 중요하다고 치고, 그럼 깨끗한 코드는 어떻게 작성하는데요? 어떻게 해야 깨끗한 코드인질 모르는데 어떻게 깨끗하게 짜요?\n그림을 그리는 방법을 잘 몰라도, 어떤 그림이 좋은 그림이고, 나쁜 그림인지는 알수 있듯 깨끗한 코드를 작성하는 법을 몰라도 코드가 깨끗한지 더러운지는 판별할 수 있다는 것이다.\n깨끗한 코드를 작성하는 감각이 있으면, 어지러운 코드를 봐도 어떤 방법으로 해결할 지에 대한 생각을 도와준다고 한다.\n깨끗한 코드란? 오랜 경험을 한 다른 개발자들에게 깨끗한 코드란 뭐라고 생각하냐? 고 물어봤다고 한다.\nBjarne Stroustrup C++ 언어의 창시자인 바야네 스트롭스트룹의 의견이다.\n 코드가 우아하고 효율적인 것을 좋아한다. 논리가 간단해야 버그가 쉽게 숨지 못하며, 유지보수를 용이하게 하기 위해 의존성이 최소화되어야 한다. 오류 처리는 명백한 전략에 따라 처리해야 한다. 성능을 최적으로 유지해야 사람들이 근본없는 최적화를 시도하지 않는다. 깨끗한 코드는 한가지 일을 잘 한다.\n 깨끗한 코드는 보기 즐거운 코드라 한다.\nC++ 창시자 답게 성능에 대한 언급을 두번씩이나 하는데, 그 이면에는 불필요한 코드가 들어오지 못하게 하려는 의도가 있다고 생각한다.\n코드가 점점 더 더러워 지는 현상에 대해서 깨진 유리창에 비유를 하는데 더러운 코드일수록 정이 안 가서 더 더럽게 된다. 는 얘기다.\nGrady Booch Object Oriented Analysis and Desing with Applications의 저자인 그래디 부치의 의견이다. (국내에는 UML을 활용한 객체지향 분석 설계로 번역되었다.)\n 깨끗한 코드는 간단하고 명료하다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 기획자의 의도를 어지럽히지 않으며, 명쾌한 추상화와 단순한 제어문으로 가득하다.\n 특히 가독성 관점에서 집중해 이야기하고 있는데, 명쾌한 추상화와 단순한 제어문 이야기하고 있다.\n컴퓨터공학에서 추상화는 구현하고자 하는 대상의 핵심적인 특징을 가지는 모델을 뜻한다. 즉, 명쾌한 추상화와 단순한 제어문이라는 이야기는 필요한 내용만 작성된 코드를 뜻한다.\nDave Thomas OTI의 창립자이자 이클립스 전략(아마도 IDE인 Eclipse의 오픈소스화 전략을 말하는 것 같다.)의 대부 데이브 토마스의 의견이다. (동명이인의 데이브 토마스는 실용주의 프로그래머의 공동 저자로, 다른 사람이다.)\n 깨끗한 코드는 원 저자가 아닌 다른 사람들도 읽고 발전시킬수 있다. 단위 테스트와 인수 테스트를 포함하고 있으며, 의미 있는 이름을 가지고 있다. 특정 목적을 달성하기 위한 방법이 하나만 제공된다. 명확하게 정의된 최소한의 의존성만 가지고 있으며, API는 명확하고 최소한으로 제공된다. 언어에 따라 필요한 모든 정보가 코드만으로 표현될 수 없기 때문에 코드는 문학적이어야 한다.\n 다른 사람이 변경하기 쉬워야 한다는 점에서 그래디 부치가 이야기한 가독성과 비슷하면서도 다른 이야기를 하고 있다. 코드가 읽기 쉬운 것과, 변경하기 쉬운것은 다른 문제이기 때문이다.\n또한 테스트에 대한 이야기를 하는데, 과거에는 의문을 불러일으킬 이야기였을지 모르지만, 테스트 주도 개발이 활성화된 요즘, 테스트는 매우 중요하다.\n최소한이란 단어도 자주 사용하는데, 이는 코드가 작은 것에 더 큰 가치를 두고 있는 것 같다.\n테스트에 관한 이야기가 나와서 하는 말인데, 예전에 내가 오픈소스 기여 전략을 배울때도 테스트의 중요성을 이야기했었다. 테스트 코드는 코드의 안전성 확보 뿐만 아니라, 해당 코드의 함수/기능을 어떻게 사용하는지 보여주는 문서의 역할도 수행할 수 있다고 했다.\nMichael Feathers 레거시 코드 활용 전략의 저자 마이클 페더스의 의견이다. (참고로 해당 책도 좋은 책이지만 번역이 좋지 않다는 의견이 있다.)\n 깨끗한 코드의 특징은 여러가지 있지만, 그 중 모든 것을 아우르는 특징이 하나 있다. 깨끗한 코드는 언제나 누군가 주의깊게 짰다는 느낌을 준다. 이미 작성자가 코드에서 모든 사항을 고려하여 작성했으며, 더 발전시키려 해도 딱히 발전시킬 거리가 보이지 않는다. 해당 코드라는 작품에 감사함을 느끼게 한다.\n 모든 사항을 고려해서 짰다는 말은 나에게는 두가지 의미로 해석된다.\n첫번째는 방어적으로 프로그래밍을 했다는 것이다. 예를 들어 함수 API를 제공한다면, 잘못된 입력에 대한 적절한 예외처리, 코드 흐름상 오류가 날 수 없게 검증을 잘 한 코드라는 것이다. 문제가 생겼을 때 해당 API 내부를 의심하지 않아도 되게 작성했다고 볼 수 있다.\n두번째는 각 기능의 동작 방식에 유연하게 대처할 수 있게 작성된 코드라는 것이다. 보통 유명한 API들은 각 함수의 기능 범위가 작은 편인데, 이는 정확하게 어느 단계에서 문제가 생긴 것인지 알기 쉽게 한다. 또한 멀티쓰레드 등의 환경에서도 문제 없도록 동기화 문제를 해결하고, 입출력시 상태를 쉽게 확인하고, 중간에 취소 등을 할 수 있도록 짧게 blocking하는 방식으로 작성되어있다.\nRon Jeffries 익스트림 프로그래밍의 창시자 중 한명인 론 제프리스의 의견이다.\n 켄트 백의 단순한 코드에 대한 규칙을 중요도 순으로 나타내면 아래와 같다.\n 모든 테스트를 통과한다. 중복이 없다. 시스템의 모든 설계 아이디어를 표현한다. 클래스, 메서드, 함수 등을 최소로 줄인다.  특히 이 중에서도 중복이 핵심이라 생각한다. 같은 일이 계속 반복된다면, 코드에서 표현이 잘 안되었다는 생각이 든다. 나는 이런 것을 찾아 더 명확하게 표현하려 한다.\n나에게 표현력이란 의미 있는 이름이고, 이름을 정하기 까지 몇번이고 바꾸는 편이다. 이클립스같은 현대 개발환경에서 이름을 바꾸는 것은 별로 어렵지 않다. 물론 이름 뿐만 아니라 객체나 함수가 한가지 일만 수행하는지 확인한다. 만약 두가지 이상의 일을 수행한다면 이것을 분리해야 하며, 한가지 일만 수행하도록 변경한다.\n중복을 줄이고, 표현력을 높이고, 단순하게 추상화하기. 이 방법으로 나는 깨끗한 코드를 만든다.\n 상당히 길게 예시까지 들어가며 의견을 제시했는데, 핵심은 마지막 문장으로 볼 수 있겠다.\nWard Cunningham 위키의 발명자, 익스트림 프로그래밍의 창시자 중 한명, 디자인 패턴의 원동력인 워드 커닝햄의 의견이다.\n 깨끗한 코드로 일을 할 때면, 각 루틴은 짐작한대로 수행한다. 해당 코드가 문제를 해결하기 위해 작성된 언어처럼 보인다면, 아름다운 코드라고 불러도 되겠다.\n 깨끗한 코드는 읽으면서 놀라는 일이 없어야 한다. 크게 노력하지 않아도 코드를 바로 이해할 수 있다. 너무 잘 작성된 코드는 잘 작성되었다는 사실조차 알아채기 힘들다.\n우리들 생각 앞으로 이 책에서 깨끗한 변수명, 깨긋한 함수, 깨끗한 클래스를 작성하는 방법에 대해 알려줄 것이다.\n무술을 예로 들면, 최고의 무술이 존재하지 않고, 각 관장이나 계파에 따라 다른 것을 배우게 된다. 절대적인 정답이 없으며, 가르치는 환경에 따라 배우는 것이 다르다.\n당연히 이 책은 저자 기준으로 아는 방법을 가르칠 것이며, 해당 내용에는 논쟁의 여지가 있다. 하지만 이 책에서 설명하는 내용은 나름 저자가 오랫동안 숙고한 방식이다. 그러니 저자의 관점을 존중해 주길 바란다.\n우리는 저자다 Javadoc에서@author 항목은 우리가 저자라는 것을 알려준다. 저자라는것은 독자가 있다는 것이며, 저자로서 독자들과 잘 소통하기 위한 책임이 있다. 앞으로 코드를 작성할 때, 저자로서의 노력을 평가할 독자들을 생각하면서 코드를 작성하라고 한다.\n코드를 작성하는 것 보다 읽는데 시간이 더 많이 소모된다. 읽는 시간 대 작성 시간의 비율은 약 10:1정도다. 우리는 코드를 작성하면서도 이전의 코드 일부를 읽어야하기 때문이다.\n결국 코드를 쉽게 작성하고 싶다면, 읽기 쉽게 작성하는 것이 중요하다.\n보이스카우트 원칙 코드를 깨끗히 작성하는 것만으론 부족하다. 코드는 계속 깨끗하게 유지되어야 한다. 시간이 지남에 따라 코드가 점점 더러워진다.\n보이스카우틑 원칙은 우리의 사명을 나타낸다고 생각한다.\n 캠프장을 오기 전보다 더 깨끗하게 해놓고 떠나라.\n 한번에 많은 노력을 들여 코드를 정리하지 않아도 된다. 변수 이름을 더 좋게 변경하거나, 큰 함수를 분리하거나, 작은 중복을 제거하거나, 복잡한 if문 하나 정리면 충분하다.\n기타 책을 원서로 읽고 있는데, 내용을 정리하면 정리할 수록 내가 번역한 초안을 올리는 것 같아서 일부 너무 똑같은 내용은 좀 정리를 했다.\n이 책의 다른 장도 중간중간 본 적이 있었는데, 기본적으로 좀 비현실적이거나 논란의 여지가 있어 보인다고 생각했다.\n다행히 저자는 학파가 다른 것 처럼, 자신의 주장일 뿐이고, 그 의견을 존중하길 바라지만, 절대 정답이 아니라는 식으로 이야기하고 있다.\n책의 내용을 참고하여 더 다양한 기법, 전략을 알아보고 각 상황에 맞는 적절한 기법을 사용해야겠다.\n","description":"","id":11,"section":"posts","tags":["클린 코드","프로그래밍 철학"],"title":"Clean Code 1장: \"깨끗한 코드\" 정리","uri":"https://devlog.jsyoo5b.net/ko/posts/clean-code/ch01/"},{"content":"본 리뷰는 특판남이 알려주는 돈 되는 특허 A to Z 책에 대한 리뷰입니다.\n읽은 계기 의외로 해당 책을 읽게 된 계기는 출판사 쪽에 있다. 해당 책의 출판사에서 출간한 Tucker의 Go 언어 프로그래밍 책의 스터디에 참여했었는데, 해당 스터디 당시 저자의 직강 방식이 매우 마음에 들었기 때문에 큰 고민없이 이 책을 통한 특허 스터디에도 참여하게 되었다.\n사실 특허에 직접적인 수요가 있어서 읽었다기 보단, 스터디가 진행되니 상식을 좀 더 넓히자는 관점에서 스터디에 참여하게 되었다. 마침 해당 책은 변리사 관점보다는 스타트업의 관점에서 사업과 연계된 특허 이야기를 다룬다고 하는 추천도 있었기에 좋은 기회라고 생각했다.\n책의 장점 앞에서 설명했듯, 특허를 변리사 관점보다 사업 관점에서 다뤘기 때문에 특허 지식에 입문하는 관점에서 괜찮은 책이라 생각한다. 아마 변리사가 공부하는 특허 관련 내용은 법학적인 기초를 바탕으로 이야기할텐데, 이 책은 법리적 해석(?)같은 것은 다루지 않고 특허 출원에 필요한 제도 관련 설명만 한다.\n물론 이 책만 읽는다고 해서 특허를 모두 아는 것은 아니다. 하지만 대략적으로 변리사에게 무슨 일을 맡길 수 있는지, 내가 어디까지 준비해야하는지, 특허를 인생의 업적이 아니라, 사업의 전략으로 사용할 수 있다는 점을 배울 수 있다.\n책의 단점 이 부분은 다른 사람들에게는 장점일 수도 있다. 하지만 나는 개인적으로 3~5장이 분리되어 다른 책으로 다뤄도 좋지 않았을까 생각한다. 해당 부분은 아이디어 살리기, 구체화, 시제품 제작 부분인데, 상당히 유용한 팁이 들어있다. 이걸 그대로 웹에 올리면 안될 것 같은 생각이 드는 비법같다. (그래서 스터디 로그도 부분적으로만 기록했다.)\n그리고 책에서 다루는 특허가 저자 분의 특허 위주의 예시로 설명되어있는데, 다른 예시도 보여주면서 자세히 분석해 보는 부분도 있으면 좋지 않았을까 하는 생각이 든다.\n책을 통해 배운 것 일단 상식을 넓히는 관점에서는 완전히 성공했다. 특허 출원이란 용어도 몰랐던 내가 전체 특허 프로세스를 개략적으로 알게 되고, 안개 속에서 이정표를 발견한 정도의 지식을 얻었다.\n그리고 제품의 발명을 위한 구조 뿐만 아니라, UI/UX 관련 특허도 출원이 가능하다는 사실은 이 책을 통해 처음 알았다. 예전에 \u0026ldquo;밀어서 잠금해제\u0026rdquo; 관련 특허로 애플이 소송 걸었던 것을 알고 있었지만, 이런 식의 UI/UX 관련 특허가 정말 많다는 것은 이 책의 서론에서 처음 안 사실이다.\n기타 이야기 분명 스터디 시작할 때는 10명 가량이었는데, 4주차부터 나만 혼자 참여하게 되어, 저자 분으로부터 1:1 특강을 받았다.\n내가 생각하고 있던 발명이나 사업 거리에 대한 자문도 받아볼 수 있었고, 만약 특허 출원이나 사업을 하려면 어떤 전략이 좋을지에 대한 이야기도 들을 수 있었다. 그리고 연락처도 받아서 추후 자문이 필요할 때 연락할 수 있는 인맥도 생겼다.\n내가 특허 자체에 관심을 갖고 있지 않았기 때문에 몰랐던 것이지, 비슷한 내용을 다루는 특허 관련 웨비나나 다른 책들도 있다.\n특허나 사업에 좀 더 진지하게 고민하게 되면 아래 책들도 읽어봐야겠다.\n 비즈니스와 특허 포트폴리오 특허로 말하라 스타트업을 위한 지식재산 가이드  ","description":"","id":12,"section":"posts","tags":["특허"],"title":"[책 리뷰] 특판남이 알려주는 돈 되는 특허 A to Z","uri":"https://devlog.jsyoo5b.net/ko/posts/review/book-musthave-patent-a-to-z/"},{"content":"iamroot 17기 스터디를 다행히 아직 참여하고 있다. 요새 진도 내용을 잘 못 따라가고 있기도 하고, 이전 스터디에 대한 복습이 필요한 것 같아, 내용을 정리하려 한다.\n이전보다는 리눅스 커널 소스도 직접 읽어보고, 추가적으로 공부한 지식이 있으니, 당시 있던 의문에 더 정확한 결론을 내릴 수 있을 것 같다.\n스터디 초기에는 커널의 내부 구성, 역할 등에 대한 이론을 이해하기 위해 리눅스 커널 내부 구조를 참고해 이론 스터디를 진행했다.\n3주차 진도는 Chapter.5 ~ Chapter.7 (p130 ~ p203)이었다.\nChapter.5 파일시스템과 가상 파일시스템 Q. 블록체인 할당 기법이나, FAT 할당 기법이나 linked-list와 비슷해보이는데 무슨 차이인가? (p136) 둘 다 링크드 리스트 형태로 구현된 점은 같은 것으로 보인다. 임의의 위치 seek에 대한 시간 복잡도는 O(n)이 예상된다.\n블록체인 할당 기법의 경우, 해당 블록에서 다음 블록에 대한 정보를 알아내서 그 블록으로 이동하는 행위를 반복해야 알 수 있다.\n반면 FAT는 전역적으로 존재하는 FAT를 사용하므로, FAT가 저장된 블록만 읽어서 해당 블록을 찾아 이동할 수 있다.\n가장 중요한 차이는 파일의 크기에 대해 seek의 복잡도가 O(n)인 것은 같지만, 여기서 표현하지 않은 계수의 크기가 n보다 큰 영향력을 발휘한다.\n 현재 사용되는 DRAM인 DDR4 중 가장 느린 PC4-12800의 최고 전송 속도는 12800MB/s다. 하드디스크나 SSD를 연결하는 SATA 3 인터페이스의 최고 전송속도는 6.0Gbps다. DRAM은 모든 임의 접근에 대해 비슷한 속도를 내지만, 하드디스크의 경우 탐색시간, 회전 지연 시간 등으로 인해 매우 느려진다.  알고리즘 구현 방식으로 생각하자면, 블록체인 할당 기법은 재귀적(Recursive) 방식으로 구현하는 것이고, FAT는 반복적(Iterative) 방식으로 구현하는 것이라 생각할 수 있다.\nQ. ext계열의 indirect block에서, indirect indexing 단계는 가변적으로 구성 가능한가? (p141) indirect block의 순서에 따라 single, double, triple indirect indexing으로 고정된 것으로 보임.\n만약 가변적으로 구성이 가능했다면, 책에서는 파일 크기를 설명할 때 48KB + 4TB * 3 으로 표현했을 것이다. (triple indirect indexing으로 3개 표현)\n가변적이었다면 굳이 single, double, triple 뿐만 아니라 quadruple도 가능했을 것이다. 또한 indexing에 있어서 현재 몇단계 indexing을 나타내는 지에 대한 메타데이터 표현도 필요하다.\n(페이지 테이블의 경우 페이지 크기의 하위 비트를 메타데이터로 사용하는데, 디스크도 이렇게 메타데이터로 사용할 수 있는 비트가 남는지는 확인이 필요할 것 같다.)\nQ. inode 테이블을 모두 사용하는 경우는 언급하는데, 왜 데이터 블록을 모두 사용하는 경우는 언급하지 않는가? (p146) 일단 inode 테이블을 모두 사용할 가능성이 데이터 블록을 모두 사용할 가능성보다 높다. 블록 그룹 내 테이블의 비트맵 비율로 계산하면 inode 하나당 1024개 데이터 블록을 사용해야 동일한 비율로 가득 채움.\n현재 블록의 크기가 4KB이므로, 평균 4MB의 크기 이상이 되어야 한다.(디렉터리가 일반적으로 4KB 크기인데도 이를 넘겨야 함.)\n현재 블록 그룹에서 데이터 블록을 다 사용하면 다음 블록으로 옮기는 방식으로 구현될 것이라 예상된다.\n굳이 inode 테이블을 모두 사용하는 경우를 언급하는 이유는 디스크의 용량이 꽉 차지 않았음에도 꽉 찬것과 똑같은 증상이 일어나기 때문으로 예상된다.\nChapter.6 인터럽트와 트랩 그리고 시스템 호출 Top half, Bottom half 책에서는 인터럽트와 트랩만 구분했지만, softIRQ와 같은 기법에 대한 이야기가 없는 것 같다. 심지어 대표적인 예시인 네트워크 부분에서도 언급이 되지 않은 것으로 보인다.\n임베디드 프로그래밍 중, 리얼타임을 지원해야 할 때 사용되는 기법으로, Top half/Bottom half라고 하는데, 인터럽트 핸들링 해야할 양이 많을 때 사용되는 기법이다.\n간단하게 요약하자면 인터럽트 핸들링은 최대한 빨리 이뤄져야 한다. 하지만 인터럽트 핸들러가 해야 할 일이 많을 때는 문제가 된다. 이 때 인터럽트 핸들러의 시간을 많이 잡아먹는 로직을 뒤로 미루는 방식이다.\n네트워크의 경우를 예시로 든다면 아래와 같다. (네트워크 관련 코드를 직접 분석해 보지 못해 완전히 동일하지는 않을 수도 있지만, 맥락은 비슷할 것으로 예상한다.)\n 네트워크 카드가 패킷 수신을 완료하면 인터럽트를 발생시킨다.\n(아마도 DMA 영역에 복사해 놨을 것이다.) 해당 패킷에는 L2, L3, L4 헤더가 포함되어 있다. 각 레이어 별 헤더 파싱에 필요한 연산량은 인터럽트 발생 주기보다 시간을 더 많이 소요한다. 최소한의 데이터 검증만 수행하고 해당 패킷을 다른 버퍼에 복사한다. (Top half) 추후 커널 태스크에서(softIRQ) 쌓여있는 버퍼의 패킷 헤더 파싱을 수행한다. (Bottom half) 헤더 파싱 결과 라우팅을 하거나, 버리거나, 유저 프로세스에게 전달한다.  여기서 Top half와 Bottom half의 차이는 CPU time을 보장받을수 있냐/없냐의 차이로 볼 수 있다.\n펌웨어 개발할 때는 이런 방식의 후처리 인터럽트를 사용하는 경우가 많았는데, 리눅스 디바이스 드라이버는 어떻게 처리해야 하는지 자세히는 모른다.\n커널 내에서는 softIRQ를 사용하고, 디바이스 드라이버는 tasklet으로 Bottom half를 처리하는 것 같다. (내부적으로 tasklet이 softIRQ로 합쳐졌지만, 디바이스 드라이버에서 tasklet 등록 등의 API는 호환을 위해 남아있다고 한다.)\n좀 더 자세한건 문c블로그를 참고하자.\n","description":"","id":13,"section":"posts","tags":["커널"],"title":"[iamroot] 3주차 스터디 회고 (리눅스 커널 내부구조)","uri":"https://devlog.jsyoo5b.net/ko/posts/linux-kernel/iamroot/week3-lki/"},{"content":"《특판남이 알려주는 돈 되는 특허 A to Z》 스터디 요약 노트입니다.\n도전! 특허 판매하기 특허를 판매하는 데 있어서 대상을 선정하고, 판매 제안서를 작성하는 것도 중요하지만, 특허를 판매하기 위한 창구를 잘 찾는 것도 중요하다. 책의 내용이나, 저자분의 경험을 토대로 한 강의를 들어본 결과, 역시나 발품팔이가 매우 중요하다는 생각이 들었다.\n책과 강의에서 들은 내용 중에는 특허 판매를 위해 CEO의 연락처(이메일)를 잘 찾지 못해서 우편으로 제안서를 전달하는 경우도 있었다.\n일부 기업의 경우, 공식 거래 제안 창구나, 아이디어 접수 홈페이지를 운영하는 경우도 있다.\n글로벌 기업의 경우 워낙 조직이 방대하다 보니, 동일한 특허에 대해서도 니즈와 평가가 달라질 수 있다. 본사에서는 가치를 낮게 보더라도 다른 나라의 사업부는 높게 평가할 수도 있다. (물론 국제적인 특허가 준비된 상태여야겠지만) 운이 좋다면 접수를 한 회사에서 다른 사업부로 전달해 줄 수도 있지만, 아쉬운 쪽이 더 적극적으로 나서야 한다.\n확실히 기술자 관점으로만 생각하던 나로서는 생각조차 못 해본 부분이다보니, 역시나 사업은 어렵다는 생각이 들었다.\n","description":"","id":14,"section":"posts","tags":["특허"],"title":"특판남이 알려주는 돈 되는 특허 A to Z 9장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/patent/musthave/ch09/"},{"content":"리눅스 커널의 소스를 분석하다 보면 include/generated/에 존재하는 헤더들을 볼 수 있다. 경로의 의미 그대로, 여기 있는 헤더들은 빌드 과정에서 자동으로 생성된다.\n문제 발견: bounds.h iamroot 리눅스 커널 스터디 중 zone_sizes_init() 분석 과정에서 MAX_NR_ZONES 상수가 등장한다.\narch/arm64/mm/init.c  195 196 197 198 199 200 201 202 203 204 205 206 207 208  static void __init zone_sizes_init(unsigned long min, unsigned long max) { unsigned long max_zone_pfns[MAX_NR_ZONES] = {0}; #ifdef CONFIG_ZONE_DMA \tmax_zone_pfns[ZONE_DMA] = PFN_DOWN(arm64_dma_phys_limit); #endif #ifdef CONFIG_ZONE_DMA32 \tmax_zone_pfns[ZONE_DMA32] = PFN_DOWN(arm64_dma32_phys_limit); #endif \tmax_zone_pfns[ZONE_NORMAL] = max; free_area_init(max_zone_pfns); }       'use strict'; var containerId = JSON.parse(\"\\\"493b3414803acc53\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  해당 상수에 대해 cscope로 검색하면 include/generated/bounds.h의 전처리기 정의가 나타나지만, ctags로 검색하면 kernel/bounds.c의 매크로를 통한 정의 코드로 나타나게 된다.\ninclude/generated/bounds.h kernel/bounds.c  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #ifndef __LINUX_BOUNDS_H__ #define __LINUX_BOUNDS_H__ /* * DO NOT MODIFY. * * This file was generated by Kbuild */ #define NR_PAGEFLAGS 23 /* __NR_PAGEFLAGS */#define MAX_NR_ZONES 4 /* __MAX_NR_ZONES */#define NR_CPUS_BITS 8 /* ilog2(CONFIG_NR_CPUS) */#define SPINLOCK_SIZE 4 /* sizeof(spinlock_t) */ #endif     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // SPDX-License-Identifier: GPL-2.0 /* * Generate definitions needed by the preprocessor. * This code generates raw asm output which is post-processed * to extract and format the required data. */ #define __GENERATING_BOUNDS_H /* Include headers that define the enum constants of interest */ #include \u0026lt;linux/page-flags.h\u0026gt;#include \u0026lt;linux/mmzone.h\u0026gt;#include \u0026lt;linux/kbuild.h\u0026gt;#include \u0026lt;linux/log2.h\u0026gt;#include \u0026lt;linux/spinlock_types.h\u0026gt; int main(void) { /* The enum constants to put into include/generated/bounds.h */ DEFINE(NR_PAGEFLAGS, __NR_PAGEFLAGS); DEFINE(MAX_NR_ZONES, __MAX_NR_ZONES); #ifdef CONFIG_SMP \tDEFINE(NR_CPUS_BITS, ilog2(CONFIG_NR_CPUS)); #endif \tDEFINE(SPINLOCK_SIZE, sizeof(spinlock_t)); /* End of constants */ return 0; }       'use strict'; var containerId = JSON.parse(\"\\\"13e5c7b2ae32eb13\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위의 주석을 보면 알겠지만, kernel/bounds.c가 원본이 되는 소스고, 빌드 과정 중에 include/generated/bounds.h가 생성되었기 때문에 수정하지 말라는 것을 확인할 수 있다.\n여기서 몇가지 질문이 생겼다.\n include/generated/bounds.h 헤더는 언제 생성되었는가? kernel/bounds.c에서 어떻게 include/generated/bounds.h가 생성되었을까? 왜 직접 헤더에서 DEFINE() 매크로를 사용하지 않고 헤더를 생성해야 했을까?  include/generated/ 헤더 생성 과정 include/generated/의 헤더를 여러 소스에서 사용하고 있기 때문에, 해당 헤더들의 생성 시기는 본격적인 커널 구성 소스들의 컴파일 이전에 생성되어야 한다.\n일단 해당 문제를 제기한 include/generated/bounds.h 관련해서 검색해 본 결과 Kbuild에서 힌트를 찾을 수 있었다.\nKbuild  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  # SPDX-License-Identifier: GPL-2.0 # # Kbuild for top-level directory of the kernel  ##### # Generate bounds.h  bounds-file := include/generated/bounds.h always-y := $(bounds-file) targets := kernel/bounds.s $(bounds-file): kernel/bounds.s FORCE $(call filechk,offsets,__LINUX_BOUNDS_H__) ##### # Generate timeconst.h  timeconst-file := include/generated/timeconst.h filechk_gentimeconst = echo $(CONFIG_HZ) | bc -q $\u0026lt; $(timeconst-file): kernel/time/timeconst.bc FORCE $(call filechk,gentimeconst) ##### # Generate asm-offsets.h  offsets-file := include/generated/asm-offsets.h always-y += $(offsets-file) targets += arch/$(SRCARCH)/kernel/asm-offsets.s arch/$(SRCARCH)/kernel/asm-offsets.s: $(timeconst-file) $(bounds-file) $(offsets-file): arch/$(SRCARCH)/kernel/asm-offsets.s FORCE $(call filechk,offsets,__ASM_OFFSETS_H__) ##### # Check for missing system calls  always-y += missing-syscalls quiet_cmd_syscalls = CALL $\u0026lt; cmd_syscalls = $(CONFIG_SHELL) $\u0026lt; $(CC) $(c_flags) $(missing_syscalls_flags) missing-syscalls: scripts/checksyscalls.sh $(offsets-file) FORCE $(call cmd,syscalls) ##### # Check atomic headers are up-to-date  always-y += old-atomics quiet_cmd_atomics = CALL $\u0026lt; cmd_atomics = $(CONFIG_SHELL) $\u0026lt; old-atomics: scripts/atomic/check-atomics.sh FORCE $(call cmd,atomics)       'use strict'; var containerId = JSON.parse(\"\\\"6aeb2499a99277ca\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  해당 부분을 분석해 보면 아래와 같다.\n bounds-file := include/generated/bounds.h는 생성될 헤더를 변수로 선언하고 있다. always-y := $(bounds-file)는 해당 헤더가 언제나 생성되어야 하는 목록에 추가되는 것으로 보인다.\n(여기에서는 :=로 할당되어있지만, 아래 헤더들을 보면 +=로 추가하는 것을 확인할 수 있다.) targets := kernel/bounds.s는 빌드 타겟에 어셈블리 소스 코드가 추가되는 것으로 보인다.\n(여기에서는 :=로 할당되어있지만, 아래 헤더들을 보면 +=로 추가하는 것을 확인할 수 있다.) $(bounds-file): kernel/bounds.s FORCE는 헤더를 만들기 위해선 어셈블리 소스를 필요로 한다는 것을 확인할 수 있다. $(call filechk,offsets,__LINUX_BOUNDS_H__)는 헤더를 만들기 위한 명령어/함수를 서술하는 것으로 보인다.  일단 kernel/bounds.s → include/generated/bounds.h 순으로 헤더가 생성되는 것으로 보인다. 하지만 리포지터리 내에 kernel/bounds.s가 없으며, 심지어 .gitignore에서 *.s가 있는 것으로 보아, kernel/bounds.s는 생성된 어셈블리 코드로 보인다. (arch/arm64/kernel/head.S 같이 직접 작성한 어셈블리 코드의 확장자는 대문자 S로 구분하는 것 같다.)\n위의 targets가 어디서 컴파일되는지는 바로 파악되지 않지만, kernel/bounds.c → kernel/bounds.s → include/generated/bounds.h 순으로 생성된다고 예측할 수 있다.\n어셈블리 코드에서 헤더 생성 과정 일단 헤더 생성 과정은 $(call filechk,offsets,__LINUX_BOUNDS_H__)인 것을 확인했으니, 어셈블리 코드를 헤더로 생성하는 과정을 찾아보자. filechk,offsets 관련 코드를 검색해 본 결과 scripts/Makefile.lib에서 예상되는 함수를 찾았다.\nscripts/Makefile.lib kernel/bounds.s include/generated/bounds.h  453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478  # Default sed regexp - multiline due to syntax constraints # # Use [:space:] because LLVM\u0026#39;s integrated assembler inserts \u0026lt;tab\u0026gt; around # the .ascii directive whereas GCC keeps the \u0026lt;space\u0026gt; as-is. define sed-offsets \u0026#39;s:^[[:space:]]*\\.ascii[[:space:]]*\u0026#34;\\(.*\\)\u0026#34;.*:\\1:; \\ /^-\u0026gt;/{s:-\u0026gt;#\\(.*\\):/* \\1 */:; \\ s:^-\u0026gt;\\([^ ]*\\) [\\$$#]*\\([^ ]*\\) \\(.*\\):#define \\1 \\2 /* \\3 */:; \\ s:-\u0026gt;::; p;}\u0026#39; endef # Use filechk to avoid rebuilds when a header changes, but the resulting file # does not define filechk_offsets echo \u0026#34;#ifndef $2\u0026#34;; \\ \techo \u0026#34;#define $2\u0026#34;; \\ \techo \u0026#34;/*\u0026#34;; \\ \techo \u0026#34; * DO NOT MODIFY.\u0026#34;; \\ \techo \u0026#34; *\u0026#34;; \\ \techo \u0026#34; * This file was generated by Kbuild\u0026#34;; \\ \techo \u0026#34; */\u0026#34;; \\ \techo \u0026#34;\u0026#34;; \\ \tsed -ne $(sed-offsets) \u0026lt; $\u0026lt;; \\ \techo \u0026#34;\u0026#34;; \\ \techo \u0026#34;#endif\u0026#34; endef     84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  .text .section\t.text.startup,\u0026#34;ax\u0026#34;,@progbits .align\t2 .p2align 3,,7 .global\tmain .type\tmain, %function main: .LFB970: .cfi_startproc hint\t25 // paciasp \t.cfi_window_save // kernel/bounds.c:19: DEFINE(NR_PAGEFLAGS, __NR_PAGEFLAGS); #APP // 19 \u0026#34;kernel/bounds.c\u0026#34; 1  .ascii \u0026#34;-\u0026gt;NR_PAGEFLAGS 23 __NR_PAGEFLAGS\u0026#34;\t// // 0 \u0026#34;\u0026#34; 2 // kernel/bounds.c:20: DEFINE(MAX_NR_ZONES, __MAX_NR_ZONES); // 20 \u0026#34;kernel/bounds.c\u0026#34; 1  .ascii \u0026#34;-\u0026gt;MAX_NR_ZONES 4 __MAX_NR_ZONES\u0026#34;\t// // 0 \u0026#34;\u0026#34; 2 // kernel/bounds.c:22: DEFINE(NR_CPUS_BITS, ilog2(CONFIG_NR_CPUS)); // 22 \u0026#34;kernel/bounds.c\u0026#34; 1  .ascii \u0026#34;-\u0026gt;NR_CPUS_BITS 8 ilog2(CONFIG_NR_CPUS)\u0026#34;\t// // 0 \u0026#34;\u0026#34; 2 // kernel/bounds.c:24: DEFINE(SPINLOCK_SIZE, sizeof(spinlock_t)); // 24 \u0026#34;kernel/bounds.c\u0026#34; 1  .ascii \u0026#34;-\u0026gt;SPINLOCK_SIZE 4 sizeof(spinlock_t)\u0026#34;\t// // 0 \u0026#34;\u0026#34; 2 // kernel/bounds.c:28: } #NO_APP \tmov\tw0, 0\t//, \thint\t29 // autiasp \t.cfi_window_save ret .cfi_endproc .LFE970: .size\tmain, .-main     1 2 3 4 5 6 7 8 9 10 11 12 13 14  #ifndef __LINUX_BOUNDS_H__ #define __LINUX_BOUNDS_H__ /* * DO NOT MODIFY. * * This file was generated by Kbuild */ #define NR_PAGEFLAGS 23 /* __NR_PAGEFLAGS */#define MAX_NR_ZONES 4 /* __MAX_NR_ZONES */#define NR_CPUS_BITS 8 /* ilog2(CONFIG_NR_CPUS) */#define SPINLOCK_SIZE 4 /* sizeof(spinlock_t) */ #endif       'use strict'; var containerId = JSON.parse(\"\\\"19ee4484d1c54c91\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  scripts/Makefile.lib를 확인해 보면 어셈블리 코드의 .ascii로 시작하는 부분을 정규표현식으로 찾아서, 순서대로 문자열을 추출하여 헤더의 정의 방식 대로 출력하게 하는 것을 볼 수 있다.\n어셈블리 코드의 생성 이전의 targets := kernel/bounds.s에서 설정한 targets가 어디까지 연결되고, 어디서 사용되는지는 완전히 확인하지 못했지만, 어셈블리 소스 파일을 생성하기 위한 패턴은 scripts/Makefile.build에서 확인할 수 있었다.\nscripts/Makefile.build  110 111 112 113 114 115 116 117  # Compile C sources (.c) # ---------------------------------------------------------------------------  quiet_cmd_cc_s_c = CC $(quiet_modtag) $@ cmd_cc_s_c = $(CC) $(filter-out $(DEBUG_CFLAGS), $(c_flags)) $(DISABLE_LTO) -fverbose-asm -S -o $@ $\u0026lt; $(obj)/%.s: $(src)/%.c FORCE $(call if_changed_dep,cc_s_c)       'use strict'; var containerId = JSON.parse(\"\\\"4abf2776583a5054\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  어셈블리 코드로 컴파일해야 하는 타겟은 cmd_cc_s_c를 사용하게 될텐데, 여기서 사용되는 gcc 옵션들 중 어셈블리 관련 옵션을 확인해보면 아래와 같다.\n -S\nStop after the stage of compilation proper; do not assemble. The output is in the form of an assembler code file for each non-assembler input file specified.\nBy default, the assembler file name for a source file is made by replacing the suffix ‘.c’, ‘.i’, etc., with ‘.s’.\nInput files that don’t require compilation are ignored. -fverbose-asm\nPut extra commentary information in the generated assembly code to make it more readable. This option is generally only of use to those who actually need to read the generated assembly code (perhaps while debugging the compiler itself).\n-fno-verbose-asm, the default, causes the extra information to be omitted and is useful when comparing two assembler files.  -S로 어셈블리 코드 수준에서 컴파일을 멈추게 하고, -fverbose-asm에서 전처리기의 결과를 생략하지 말고 모두 출력하게 하고 있다. 이를 통해 DEFINE()으로 선언된 상수를 .ascii 형태로 읽을 수 있었던 것이다.\nDEFINE()의 정의를 보면, 강제로 .ascii 형태의 문자열 상수화 하는 것을 확인할 수 있다.\ninclude/linux/kbulid.h  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* SPDX-License-Identifier: GPL-2.0 */ #ifndef __LINUX_KBUILD_H #define __LINUX_KBUILD_H  #define DEFINE(sym, val) \\ asm volatile(\u0026#34;\\n.ascii \\\u0026#34;-\u0026gt;\u0026#34; #sym \u0026#34; %0 \u0026#34; #val \u0026#34;\\\u0026#34;\u0026#34; : : \u0026#34;i\u0026#34; (val))  #define BLANK() asm volatile(\u0026#34;\\n.ascii \\\u0026#34;-\u0026gt;\\\u0026#34;\u0026#34; : : )  #define OFFSET(sym, str, mem) \\ DEFINE(sym, offsetof(struct str, mem))  #define COMMENT(x) \\ asm volatile(\u0026#34;\\n.ascii \\\u0026#34;-\u0026gt;#\u0026#34; x \u0026#34;\\\u0026#34;\u0026#34;)  #endif       'use strict'; var containerId = JSON.parse(\"\\\"93ee0555b94209f4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  왜 헤더를 생성해야 하는가? 헤더가 생성되는 과정은 확인할 수 있었지만, 왜 이런 식으로 헤더를 생성해야 하는 지에 대한 부분은 코드 상에 나와있지 않았다. 해당 코드에 관련 내용을 git blame으로 확인해 본 결과 의미있는 commit을 찾을 수 있었다.\n1cdf25d704f7951d02a04064c97db547d6021872  kbuild: create a way to create preprocessor constants from C expressions The use of enums create constants that are not available to the preprocessor when building the kernel (f.e. MAX_NR_ZONES). Arch code already has a way to export constants calculated to the preprocessor through the asm-offsets.c file. Generate something similar for the core kernel through kbuild. Signed-off-by: Sam Ravnborg \u0026lt;sam@ravnborg.org\u0026gt; Signed-off-by: Christoph Lameter \u0026lt;clameter@sgi.com\u0026gt; Cc: Andy Whitcroft \u0026lt;apw@shadowen.org\u0026gt; Cc: KAMEZAWA Hiroyuki \u0026lt;kamezawa.hiroyu@jp.fujitsu.com\u0026gt; Cc: KOSAKI Motohiro \u0026lt;kosaki.motohiro@jp.fujitsu.com\u0026gt; Cc: Rik van Riel \u0026lt;riel@redhat.com\u0026gt; Cc: Mel Gorman \u0026lt;mel@csn.ul.ie\u0026gt; Cc: Jeremy Fitzhardinge \u0026lt;jeremy@goop.org\u0026gt; Signed-off-by: Andrew Morton \u0026lt;akpm@linux-foundation.org\u0026gt; Signed-off-by: Linus Torvalds \u0026lt;torvalds@linux-foundation.org\u0026gt;     'use strict'; var containerId = JSON.parse(\"\\\"2849059952af9143\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  해당 commit은 kernel/bounds.c를 추가할 때 생성된 여러 commit 중 하나로 보인다. (해당 commit의 변경분 만으로는 kernel/bounds.c에 들어갈 내용이 모자라다.)\n커널에서는 상수 정의에 #define 외에 enum을 통해 정의하기도 한다. enum은 선언 순서에 따라 값을 변경하면서 선언할 수 있기에 #define보다 자주 볼 수 있다.\n여기 내용에서 보듯, enum으로 정의된 상수를 전처리기에서 사용하고자 할 때 컴파일 순서에 의해 enum 상수 값을 전처리기가 알 수 없다는 문제가 생긴다.\n문제를 제기한 MAX_NR_ZONES를 예시로 들어보자.\ninclude/linux/mmzone.h  345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405  enum zone_type { /* * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able * to DMA to all of the addressable memory (ZONE_NORMAL). * On architectures where this area covers the whole 32 bit address * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller * DMA addressing constraints. This distinction is important as a 32bit * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit * platforms may need both zones as they support peripherals with * different DMA addressing limitations. * * Some examples: * * - i386 and x86_64 have a fixed 16M ZONE_DMA and ZONE_DMA32 for the * rest of the lower 4G. * * - arm only uses ZONE_DMA, the size, up to 4G, may vary depending on * the specific device. * * - arm64 has a fixed 1G ZONE_DMA and ZONE_DMA32 for the rest of the * lower 4G. * * - powerpc only uses ZONE_DMA, the size, up to 2G, may vary * depending on the specific device. * * - s390 uses ZONE_DMA fixed to the lower 2G. * * - ia64 and riscv only use ZONE_DMA32. * * - parisc uses neither. */ #ifdef CONFIG_ZONE_DMA \tZONE_DMA, #endif #ifdef CONFIG_ZONE_DMA32 \tZONE_DMA32, #endif \t/* * Normal addressable memory is in ZONE_NORMAL. DMA operations can be * performed on pages in ZONE_NORMAL if the DMA devices support * transfers to all addressable memory. */ ZONE_NORMAL, #ifdef CONFIG_HIGHMEM \t/* * A memory area that is only addressable by the kernel through * mapping portions into its own address space. This is for example * used by i386 to allow the kernel to address the memory beyond * 900MB. The kernel will set up special mappings (page * table entries on i386) for each page that the kernel needs to * access. */ ZONE_HIGHMEM, #endif \tZONE_MOVABLE, #ifdef CONFIG_ZONE_DEVICE \tZONE_DEVICE, #endif \t__MAX_NR_ZONES };       'use strict'; var containerId = JSON.parse(\"\\\"fdbc828c211a4c6b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  중간에 보면 CONFIG_ZONE_DMA, CONFIG_ZONE_DMA32, CONFIG_HIGHMEM, CONFIG_ZONE_DEVICE의 정의 여부에 따라 enum 중간 값이 추가되거나, 제거되기도 한다. 그리고 마지막으로 __MAX_NR_ZONES는 이전까지 enum 선언된 값의 개수에 따라 바뀐다.\nMAX_NR_ZONES가 사용되는 코드를 검색해 보면 코드 내 상수로 사용되는 것이 대부분이지만, 아래와 같이 해당 값이 전처리기에서 사용되는 경우도 존재한다.\ninclude/linux/page-flags-layout.h  8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /* * When a memory allocation must conform to specific limitations (such * as being suitable for DMA) the caller will pass in hints to the * allocator in the gfp_mask, in the zone modifier bits. These bits * are used to select a priority ordered list of memory zones which * match the requested limits. See gfp_zone() in include/linux/gfp.h */ #if MAX_NR_ZONES \u0026lt; 2 #define ZONES_SHIFT 0 #elif MAX_NR_ZONES \u0026lt;= 2 #define ZONES_SHIFT 1 #elif MAX_NR_ZONES \u0026lt;= 4 #define ZONES_SHIFT 2 #elif MAX_NR_ZONES \u0026lt;= 8 #define ZONES_SHIFT 3 #else #error ZONES_SHIFT -- too many zones configured adjust calculation #endif       'use strict'; var containerId = JSON.parse(\"\\\"d0927bb860bf3b18\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  다른 부분은 코드 내 상수로만 들어가는 것이기 때문에 enum으로 정의된 __MAX_NR_ZONES를 사용해도 큰 문제가 되지 않았다. 하지만 위의 헤더와 같이 MAX_NR_ZONES의 값이 전처리기 시기에 숫자로 치환되지 않으면 해당 부분을 의도한 대로 전처리기 해석이 불가능하다. (값의 크기를 비교해야 되는데 문자열로 치환되기 때문)\n즉, 해당 commit에서 언급한 것 처럼 enum으로 생성한 상수를 전처리기에서 사용하기 위해서는 해당 정의에 따른 값으로 완전히 치환해야 했던 것이고, 이를 위해 따로 소스 코드를 생성하고, 컴파일하여 그 내용을 바탕으로 다시 헤더를 생성한 것이다.\n","description":"","id":15,"section":"posts","tags":["커널","gcc"],"title":"리눅스 커널 내 generated 헤더 분석","uri":"https://devlog.jsyoo5b.net/ko/posts/linux-kernel/generated-header/"},{"content":"《특판남이 알려주는 돈 되는 특허 A to Z》 스터디 요약 노트입니다.\n돈 되는 특허 활용 백서 특허는 비즈니스 관점에서 큰 의미를 가진다. 정부과제 등에 지원하기 위해 특허 출원 개수를 따지기도 하지만, 기본적으로 특허는 비즈니스에서 창 혹은 방패의 역할을 한다.\n독점 사업 파나소닉 창업주는 쌍소켓(멀티탭)을 발명하고 직접 사업을 추진함으로서 사업 기초를 다졌다고 한다. 에스보드는 노숙자 출신의 발명가가 출원하고, 이를 사업화 해 연 매출 100억을 달성했다. 하지만 에스보드는 중국산 모조품에 적극적으로 대응하지 않다가 손해를 보고, 미국 특허는 다른 특허 업체에 양도되었다고 한다.\n특허 판매 특허는 한번 출원하면 출원자가 계속 권리를 유지해야 하는 것이 아니다. 일반적으로는 등록된 특허를 판매하지만, 등록이 안된 특허나, 출원 중인 특허도 판매한다. 최근 10년간 특허 소유권 이전은 약 182,000건에 이르며, 기업 간 특허 이전은 50.79%, 개인에서 기업으로의 이전은 20.37%에 이른다고 한다.\n당연히 특허가 판매되면 기존 특허권자도 더이상 해당 특허를 사용할 수 없다.\n개별적으로 판매하는 방식 외에 경매 방식으로 특허 매매가 이루어지기도 한다.\n라이선스 지적 재산권의 대가로 받고 타인에게 상업적, 경제적 권리를 부여하는 방식이 있다. 본인이 직접 독점적인 사업을 진행하기 어려울 때, 해당 특허를 필요로 하는 업체에 라이선싱을 함으로서 일정 수익을 꾸준히 받을 수도 있다.\n소유주가 다른 표준 특허 또는 관련 특허들을 이용하여 공동 라이선스 풀을 만들어 라이선싱을 진행할 수도 있다. 보통 이런 특허는 사실상 표준 기술이 들어가는 경우가 많으며, 회피 설계가 거의 불가능하기 때문에 해당 기술을 이용할 수 밖에 없게 된다.\n소송 특허와 관련되 뉴스에서 가장 많이 듣는 이야기는 소송일 것이다. 소송 활용에는 일반적으로 경쟁 기업으로부터 손해배상이 뉴스에 많이 오르내리지만, 경영 환경 타개책으로 수익을 추구하는 경우도 있다. 노키아와 같이 기존 선두 기업이지만 새로운 시장 플랫폼에 적응하지 못한 경우가 있다고 한다.\n국내는 보통 손해배상보다는 침해금지 가처분 청구가 대부분이라고 한다. 손해배상 대비 빠르게 진행되며, 상대적으로 빨리 경쟁사의 침해 행위를 저지할수 있기 때문이다.\n","description":"","id":16,"section":"posts","tags":["특허"],"title":"특판남이 알려주는 돈 되는 특허 A to Z 8장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/patent/musthave/ch08/"},{"content":"《특판남이 알려주는 돈 되는 특허 A to Z》 스터디 요약 노트입니다.\n더 강력한 특허 만들기 특허 출원 이후에도 특허를 더 강력하게 만들 수 있는 방법이 있다. 특허를 가출원하고 (청구 범위가 기재되지 않은 명세서 제출) 보정서를 제출하거나, 특허 결정 등본을 송달 받기 전까지 명세서 내용을 보정할 수 있다. 즉, 특허가 등록되기 전까지는 보정서를 통해 특허를 더 강화할 수 있다.\n중간 사건 대응하기 특허 출원 후 심사에서 바로 등록되는 특허는 매우 드물다고 한다. 해당 특허의 신규성, 진보성, 기재불비 요인으로 거절이유통지서가 나오는데, 해당 의견서 혹은 보정서를 제출해야 한다.\n강력한 청구항 작성하기 청구항을 작성할 때 자주 하는 실수 중 회피 설계를 고려하지 못하는 경우가 있다. 발명자가 자신의 발명을 위주로 생각하다보니 구체적으로 작성하려는 경향이 있는데, 오히려 청구항은 회피 설계 관점에서 일반화하여 쓰는 것이 유리하다. 논문같은 성과 보고가 아니라 내 권리를 주장하는 것이기 때문에 넓을 수록 좋기 때문이다.\n하지만 너무 넓게 작성한 청구항은 기존 선행기술과 권리범위가 동일해 질 수 있다. 즉, 적절한 범위로 청구하는 기술이 필요하다.\n회피 설계 회피 설계는 기존의 특허 침해를 피하기 위해 의도적으로 동일 목표를 수행하는 구성 요소를 삭제하거나 변형하는 기술이다. 기본적으로는 삭제나 변형이 많을수록 좋다.\n회피 설계를 위한 전략으로는 기존 특허의 포대서류를(청구항 수정 이력 및 주장) 분석하여 변형에 반영하는 방법이 있다. 그리고 해당 특허의 모출원, 자출원,(특허를 출원한 뒤 해당 출원에 연계된 출원 관계) 보류중인 청구항 상태를 모니터링하여 상대가 이미 회피 설계를 방어하고 있는지 또한 확인할 필요가 있다.\n","description":"","id":17,"section":"posts","tags":["특허"],"title":"특판남이 알려주는 돈 되는 특허 A to Z 7장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/patent/musthave/ch07/"},{"content":"《특판남이 알려주는 돈 되는 특허 A to Z》 스터디 요약 노트입니다.\n드디어 특허 출원하기 본격적인 특허 출원 과정에 대해 알아보자. 이전 단계에서 특허를 위한 발명이 모두 준비되어있다면 책의 한 글자도 놓치지 않고 읽으며 따라 해야겠지만, 지금은 특허 출원 과정에서 도움이 될 지식들 위주로 알아보려 한다.\n대리인(변리사) 선임 분명 혼자 출원한다면 소요 경비가 급격히 줄어들 것이다. 이론상 특허를 출원하는데 소요되는 특허청 관납료는 40만원 이하가 소요되지만, 그렇게 출원한 특허가 강력하지도 않을 것이고, 허점도 많을 것이고, 한 번에 완료되지 않을 것이다.\n누구나 쉽게 특허를 출원할 수 있다면 변리사들은 왜 그리도 공부를 하며 어려운 과정을 거치겠는가? 우리가 집중해야 할 것은 어떻게 하면 혼자 특허를 출원할 수 있을까? 가 아니라, 어떻게 하면 대리인이 내 특허를 정확하게 출원해 줄 수 있을까? 다.\n저자는 회사에서 특허 업무를 맡은 적이 있으니 혼자서 출원을 시도해 볼 수 있던 것이지, 대부분은 대리인을 쓰는 것이 좋은 전략이다. 만약 본인이 특허 출원 과정에 대해 잘 알고 있다면, 대리인을 부분적으로 선임할 수도 있다.\n대리인이 맡게 되는 주요 업무는 선행기술조사와 특허 명세서 작성, 특허 출원 과정 및 심사 과정에서 필요한 사건 대응, 해외 출원 등이 있다.\n출원 전략 특허를 출원하고 심사, 등록하는 데는 각각 기간이 존재한다. 미국의 경우는 출원과 동시에 심사가 이루어지지만, 국내의 경우 이 과정이 별개이며, 각각 기간이 존재하므로, 일시금으로 지출하지 않을 수 있고, 시장 상황에 따라 유리한 시기를 조율하여 진행할 수 있다. 변리사들이 이런 부분에서도 많이 업무를 하다 보니 많은 도움이 될 수 있다.\n청구항 특허의 실질적인 권리 범위를 정의하는 것은 청구항이다. 출원 전에 작성한 청구항, 공개 공보에 실린 청구항, 최종 등록 후 등록공보에 실린 청구항은 대부분 다르지만, 핵심은 특허 출원자가 원하는 범위를 작성해야한다.\n변리사를 선임해도 최소한 초안은 발명자가 작성해야 하기 때문에(출원자가 원하는 대로 권리를 인정받기 위해) 청구항에 대한 지식을 잘 알고 있는 것이 중요하다.\n 청구항은 독립항과 독립항의 한정, 부가, 구체화 하는 종속항으로 구분된다. 특허 출원 하나에 여러 청구항을 작성할 수 있다. 한 청구항은 한 문장으로 이루어진다. 각 청구항은 발명 목적을 달성하는 필수 구성요소 또는 방법으로 구성된다. 독립항, 종속항 구분 없이 모든 청구항은 침해 및 유효성을 논할 때 독립적이다.  필요에 따라 청구항을 분리하여 상대가 여러 청구항 중 하나라도 침해하게 유도하는 것이 가능하다.\n독립항 다른 청구항에 종속되지 않은 청구항을 독립항이라 한다. 예를 들어 제품의 경우, 발명의 핵심이 되는 구성 요소들을 나열하는 것이 독립항이라 할 수 있다.\n나열하는 방식 외에도 방법항(방법 청구항)으로, 각 구성 요소를 행동 중심으로 기술할 수 있다.\n종속항 특정 청구항을 가리키는 형태의 청구항을 종속항이라 한다. 보통 \u0026ldquo;제 ~항에 있어서\u0026rdquo; 로 시작하는 청구항은 종속항이다.\n종속항은 이전에 언급한 독립항에 대해서 기능이나 능력을 자세히 서술하고, 한정할 때 사용된다.\n종속항은 독립항보다 권리 범위가 작기 때문에, 종속항의 내용이 독립항의 구성 요소를 제거하는 식의 범위를 늘리는 방식은 불가능하다.\n또한 여러 청구항을 한번에 인용하는 다중 종속 청구도 불가능하다.\n청구항 작성 팁 청구항 작성 시, 상대가 무조건 침해하길 바라며 너무 넓게 청구 범위를 잡으면 특허 등록이 힘들다. 물론 반대로 청구 범위를 좁게 잡으면 권리를 행사하기 어려워진다. 흔히 말하듯 적당한 범위의 청구를 하는 것이 중요하다.\n비용 특허 출원, 심사, 등록에는 비용이 들기 마련이다. 이 중에서도 특이한 부분은 등록 이후에 드는 비용이다.\n특허를 등록할 때는 청구항마다 가산료가 올라가며, 각 연차 기간마다 기본 등록료, 가산료가 올라간다.\n이 정책은 특허의 목적에 의해 발생하는데, 독점 권리를 유지하려면 그만큼 비용을 내라는 것이며, 시간이 지날 수록 최대한 빨리 특허를 공개적으로 풀어, 모두가 사용할 수 있게 유도하는 것이다.\n","description":"","id":18,"section":"posts","tags":["특허"],"title":"특판남이 알려주는 돈 되는 특허 A to Z 6장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/patent/musthave/ch06/"},{"content":"《특판남이 알려주는 돈 되는 특허 A to Z》 스터디 요약 노트입니다.\n시제품 제작하기 발명의 개념을 증명하기 위해서만 시제품을 제작한다 생각했지만, 이 외 부수적인 효과도 있음을 알 수 있었다.\n설계 단계에서는 생각하지 못한 문제점을 발견하거나, 이를 해결하면서 새로운 발명, 특허 거리가 나올 수도 있다.\n실제로 경험해 본 바, 전혀 예상치도 못한 사소한 부분에서 시간을 오래 잡아먹으며, 메인 문제보다 사소한 문제에서 배우는 점이 더 많았던 것을 생각하면, 이 부분에 완전 동의하게 된다.\n개발 계획서 작성하기 책에서는 필요성만 언급하지 않고, 구체적인 전략 또한 설명하고 있다. 시제품 제작, 개발, 사업을 위한 계획 뿐만 아니라, 자금을 끌어오기 위한 전략까지 제안하고 있다.\n아이디어 발상회 이것은 저자 분이 대기업에서 특허 관련 업무를 했었기에 알 수 있는 방법이라 생각한다. 만들어진 시제품을 통해 역으로 특허 가능한 발명을 찾기 위해 아이디어 발상회를 제안하고 있다.\n","description":"","id":19,"section":"posts","tags":["특허"],"title":"특판남이 알려주는 돈 되는 특허 A to Z 5장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/patent/musthave/ch05/"},{"content":"《특판남이 알려주는 돈 되는 특허 A to Z》 스터디 요약 노트입니다.\n아이디어 구체화하기 4장에서는 아이디어를 더 구체화 하기 위한 과정으로 상세 선행기술조사 과정, 아이디어의 차별성과 구현 가능성 판단하는 법에 대한 설명을 하고 있다.\n상세 선행기술조사 당연히 사업 이야기가 그러하듯 기술에 집중적으로 조사해야하지만, 사업적인 경영 정보, 특허 권리 정보 등도 확인할 것을 추천하고 있다. 특히 공개공보 등을 통한 특허 정보를 집중적으로 확인하는 방법에 대해 자세히 서술하고 있다.\n국내의 경우 이전에 언급하였듯 키프리스를 활용하는 방법을 좀 더 상세히 설명하고 있다.\n아이디어 차별성 판단 차별화된 아이디어 심사 기준인 신규성과 진보성에 대해 자세한 설명이 이루어지고 있다.\n신규성은 선행기술과 동일한지 여부를 판단하는 것이다.\n진보성은 해당 발명을 용이하게 구현할 수 있는지 여부를 판단한다. 용이하게 구현이 가능하다면 누구나 쉽게 특허를 출원하게 되고, 특허권 난립으로 인한 분쟁 가능성이 높아지기 때문이다.\n즉, 매우 주관적인 영역이지만, 해당 발명이 얼마나 가치있는지에 대한 서술에 의해 달라질 수 있다.\n돈 되는 아이디어 판단 아이디어가 돈이 되는지 판단하는데는 여러가지 요소가 있다. 이 중 책을 보기 전에는 전혀 생각하지 못했던 부분 중 소모품 관련 예시를 들어보겠다.\n프린터의 경우 기계 자체도 가격이 나가지만, 실제 수익을 얻는 부분은 토너라는 이야기를 들은 적이 있다. 프린터 자체에 대한 수요는 일시적이지만, 프린터를 사용함에 있어 토너와 용지는 꾸준히 소모된다. 이런 식으로 아이디어 그 자체가 아니라, 부수적인 부분에서도 사업성을 판단할 수 있다.\n기타 기존 스터디 인원도 Go언어 스터디에 비해 훨씬 적은 인원이었지만, 4회차에는 나만 남았다. 그렇게 진지하게 생각하면서 듣고 있지 않았는데, 저자분께서 내 위주로 강의를 도와주신다고 하니 좋은 기회라 생각하고 더 열심히 공부해 봐야 겠다.\n","description":"","id":20,"section":"posts","tags":["특허"],"title":"특판남이 알려주는 돈 되는 특허 A to Z 4장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/patent/musthave/ch04/"},{"content":"《특판남이 알려주는 돈 되는 특허 A to Z》 스터디 요약 노트입니다.\n특허가 되는 아이디어 판별하기  아이디어: 문제 및 해결법 발명: 아이디어 대비 구체적인 해결책 특허: 해당 발명의 출원 여부, 향후 등록 이후의 권리 보호  3장에서는 아이디어를 생각하고, 기록하여 구체화시키기 위한 전략을 제시한다.\n선행기술 조사 선행기술 조사는 아이디어를 구체화 시키는 과정에서 많은 도움이 된다. 하지만 아이디어를 구체화 하는 과정에서만 사용되는 것은 아니다.\n 특허 출원 전에 아이디어 하나가 여러 발명으로 늘어날 때, 각 발명에 대한 사전조사가 필요하다. 특허 적용 제품 양산 전에, 동일한 문제와 해결 방안을 다루는 특허를 검색하여 권리 침해 여부를 확인할 필요가 있다. 특허 등록 후 분쟁 시 무효 주장이나 방어를 위한 선행기술을 찾아야 한다.  아이디어 평가 여러 방법으로 아이디어를 평가하여 가치있는 아이디어인지 판단한다. 이 때 독창적인지 뿐만 아니라, 구현 가능한지, 시장성은 어떤지, 사업성은 어떤지 같이 판단해 보는 것이 좋다.\n기본적으로 사업과 연결되기 때문에 시장성, 사업성은 기본적으로 확인해야하며, 특허를 출원하는 과정, 등록하는 과정에도 돈이 들기 때문에 여러 관점으로 볼 필요가 있다.\n","description":"","id":21,"section":"posts","tags":["특허"],"title":"특판남이 알려주는 돈 되는 특허 A to Z 3장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/patent/musthave/ch03/"},{"content":"macOS에서 터미널을 사용할 때 차이점 macOS에서 터미널을 사용하다 보면 ls의 색이 리눅스 터미널을 사용하던 것과 다른 색으로 출력되는 것을 볼 수 있다.\nmacOS Linux      'use strict'; var containerId = JSON.parse(\"\\\"114a2b2d1ae2158a\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  파일/디렉토리 특성에 따라 다른 색상으로 분류되기만 해도 도움은 되지만, 웬만하면 일관된 색 배치로 보는 것이 더 편하기 때문에 색상을 동일하게 나타나게 하는 방법에 대해 찾아봤다.\nls의 색상이 다른 이유 처음에는 색상이 다른 이유가 애플이 또 평소처럼 지들 멋대로 표준화해서 그런 것이라 생각했다.\n하지만 위키피디아의 ls 문서에서 해당 원인을 찾을 수 있었다.\n It is frequently possible to highlight different types of files with different colors, instead of with characters as -F would. This is an area where the two main ls versions differ:\n GNU ls uses the \u0026ndash;color option; checks the Unix file type, the file permissions and the file extension and uses its own database to control colors maintained using dircolors. FreeBSD ls uses the -G option; checks only the Unix file type and file permissions. and uses the termcap database.   번역하자면 다음과 같다.\n 대부분의 ls에서는 다른 파일 타입에 대해 다른 색상으로 하이라이트 하는 것이 가능하다. (-F 옵션을 사용하여 파일 타입에 따른 글자를 추가로 표현하는 방식도 있다.) 두가지 주류 ls 버전은 색상 하이라이트 부분에서 차이가 난다.\n GNU ls는 --color 옵션을 사용한다. 유닉스 파일 타입, 파일 권한 및 파일 확장자를 확인하며, dircolors의 데이터베이스를 통해 색상이 관리된다. FreeBSD ls는 -G 옵션을 사용한다. 유닉스 파일 타입과 파일 권한만 확인하며, termcap의 데이터베이스를 통해 색상이 관리된다.   macOS는 내부적으로 Darwin을 사용하며, 내부적으로 BSD 커널과 Mach 커널을 사용한다.\n리눅스에서는 GNU ls를 사용하고, macOS에서는 FreeBSD ls를 사용했다고 볼 수 있다. (정확히는 BSD계열이란 표현이 옳지만, 위키피디아 설명을 기준으로 구분할 경우를 말한다.) 터미널에서 man ls로 매뉴얼을 확인해 보면 macOS는 \u0026ldquo;BSD General Commands Manual\u0026quot;이라고 표현되어 있는 것을 볼 수 있다.\n해결법 내가 생각하는 해결법은 2가지다.\n macOS에서 GNU ls를 사용한다. macOS의 BSD ls를 GNU ls와 비슷하게 설정한다.  나는 1번 해결법이 더 좋은 해결법이라 생각한다. 일단 리눅스에서 사용하던 환경을 일관되게 사용하려는 것이 목적이기도 했고, GNU ls는 파일 확장자에 따른 하이라이트도 제공하기 때문이다.\nGNU ls 사용하기 먼저 GNU coreutils를 설치한다. ls는 개별적으로 설치하는 것이 아닌, GNU core utilities의 일부다.\nhomebrew가 설치되었다면 brew install coreutils 명령으로 간단하게 설치할 수 있다.\nGNU coreutils를 통해 설치된 명령어는 앞에 g가 붙는다. 즉, GNU coreutils의 ls는 gls로 호출해야 한다. ls 명령을 호출해도 gls가 호출될 수 있도록, 색상 옵션을 기본으로 넣게 설정하려면 쉘 rc파일에 아래 내용을 추가하자. (아마 최근 macOS는 zsh를 채용했기 때문에 .zshrc를 수정해야 할 것이다.)\n.zshrc  if [[ -x \u0026#34;$(command -v gls)\u0026#34; ]]; then alias ls=\u0026#39;gls --color=auto\u0026#39; fi     'use strict'; var containerId = JSON.parse(\"\\\"983b348d58ded8a6\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  alias를 활용하여 기존 BSD 버전 ls 대신 gls를, --color=auto 옵션까지 기본으로 추가해서 실행하도록 설정해주자.\n여기까지 수행하면 일반파일, 실행파일, 디렉토리, 심볼릭 링크까지는 같은 색상으로 출력하지만, 파일 확장자별 구분이나, 깨진 심볼릭 링크까지는 확실히 구분해 주지 못한다.\n현재 상태는 GNU ls의 기본 색 구분만 사용하고 있기 때문이다. 이전 원인 분석과정에서 설명했듯 GNU ls의 색상 관리에는 dircolors를 사용한다. GNU coreutils를 설치하면 ls 뿐만 아니라 dircolors도 같이 설치된다. dircolors의 설정을 반영하도록 rc파일을 수정해주자.\n.zshrc  if [[ -x \u0026#34;$(command -v gls)\u0026#34; ]]; then alias ls=\u0026#39;gls --color=auto\u0026#39; if [[ -x \u0026#34;$(command -v gdircolors)\u0026#34; ]]; then eval \u0026#34;$(gdircolors -b)\u0026#34; fi fi     'use strict'; var containerId = JSON.parse(\"\\\"313a1f0c8817c5d6\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  BSD ls를 GNU ls와 비슷하게 설정하기 설정 방법은 GNU ls 설치에 비해 매우 간단하다.\n환경 변수 중 LSCOLORS를 ExGxFxdxCxdadahbadacec로 설정하면 된다.\n해당 값은 기존 GNU ls와 최대한 비슷하도록 값을 설정한 것이다.\nrc파일에서 자동으로 설정되게 하려면 아래와 같이 수정한다.\n.zshrc  export LSCOLORS=\u0026#34;ExGxFxdxCxdadahbadacec\u0026#34;     'use strict'; var containerId = JSON.parse(\"\\\"ecf78075bde36ec1\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이전에 언급했듯 GNU ls에 비해 기능이 부족하기 때문에 다양하게 색 구분은 할 수 없지만, 따로 프로그램 설치 없이 리눅스에서 사용하던 색 배치를 최대한 일관되게 볼 수 있다.\n내부 원리 ls가 두 종류로 나뉘는 것을 설명하면서 각각 dircolors나 termcap의 데이터베이스를 사용한다는 식의 설명이 있었다. 결과적으로 두 ls 모두 shell 환경변수에서 값을 읽어온다. GNU ls는 LS_COLORS 환경변수를 참조하며, BSD ls는 LSCOLORS 환경변수를 참조한다. (중간에 _ 존재 여부로 차이난다.)\nLS_COLORS (GNU ls의 환경 변수) dircolors의 설정이 반영되도록 eval $(dircolors -b)를 rc파일에 삽입했었다. 그렇다면 dircolors -b는 무슨 일을 하는지 확인해 보자.\nshell  $ dircolors --help Usage: dircolors [OPTION]... [FILE] Output commands to set the LS_COLORS environment variable. Determine format of output: -b, --sh, --bourne-shell output Bourne shell code to set LS_COLORS -c, --csh, --c-shell output C shell code to set LS_COLORS -p, --print-database output defaults --help display this help and exit --version output version information and exit If FILE is specified, read it to determine which colors to use for which file types and extensions. Otherwise, a precompiled database is used. For details on the format of these files, run \u0026#39;dircolors --print-database\u0026#39;. GNU coreutils online help: \u0026lt;https://www.gnu.org/software/coreutils/\u0026gt; Full documentation at: \u0026lt;https://www.gnu.org/software/coreutils/dircolors\u0026gt; or available locally via: info \u0026#39;(coreutils) dircolors invocation\u0026#39; $ dircolors -b LS_COLORS=\u0026#39;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:\u0026#39;; export LS_COLORS     'use strict'; var containerId = JSON.parse(\"\\\"0dc7d576a0bf3106\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  설명에 나와있듯 dircolors -b는 bourne shell 호환 문법으로 LS_COLORS의 값을 환경변수로 설정한다. 현재 LS_COLORS의 값 부분이 길기 때문에 의미를 기준으로 좀 더 쪼개서 다시 보도록 하자.\nLS_COLORS  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  LS_COLORS=\u0026#34;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.ogv=01;35:*.ogx=01;35\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36\u0026#34; LS_COLORS=\u0026#34;$LS_COLORS:*.spx=00;36:*.xspf=00;36:\u0026#34;       'use strict'; var containerId = JSON.parse(\"\\\"4e1d40af7921d97a\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  보면 하나의 설정 당 :로 분리하여 설명하고 있으며, 여러 색 설정을 조합하여 쓰기 위해 ;를 사용하고 있음을 확인할 수 있다.\n1~2번 라인은 파일의 타입에 따라 색 설정을 하도록 하고 있다.\n3~9번 라인은 주로 압축 파일 확장자들을 같은 색으로 출력하도록 설정하고 있다. (tar등의 archive 파일이나, deb, rpm, jar 같이 내부적으로는 archive 압축 파일로 구성된 패키지 파일 등)\n10~12번 라인은 주로 이미지 파일 확장자들을 같은 색으로 출력하도록 설정하고 있다.\n13~17번 라인은 주로 동영상 파일 확장자들을 같은 색으로 출력하도록 설정하고 있다.\n18~20번 라인은 주로 오디오 파일 확장자들을 같은 색으로 출력하도록 설정하고 있다.\n여러 확장자들을 특성에 따라 같은 색으로 표현했으니, 파일 타입은 각각 어떤 방식으로 구분하는지 확인해보자.\n   코드 설명     rs 리셋 (기본 색 설정)   di 디렉토리   ln 심볼릭 링크   mh 멀티 하드 링크   pi 파이프 파일 (named pipe)   so 소켓 파일   do 도어 파일 (IPC에서 사용됨)   bd 블록 장치 파일   cd 글자 장치 파일   or 잘못된 링크(없는 파일)를 가리키는 심볼릭 링크   mi 심볼릭 링크가 가리키는 잘못된 링크의 파일 (ls -l에서 출력됨)   su SetUID 파일   sg SetGID 파일   ca 호환성   tw other write가 가능하고 sticky bit가 설정된 디렉토리   ow other write가 가능하고 sticky bit는 설정되지 않은 디렉토리   st other write가 불가능하고 sticky bit만 설정된 디렉토리   ex 실행 파일    여기서 ca, 호환성 부분은 리눅스 시스템의 capabilities를 의미하는 것 같은데, 이 부분은 완전히 이해하지 못했다.\n색상 코드 값은 ISO 6429 색상 코드를 사용하며, 해당 값에 대한 정보는 아래 표와 같다.\n   글씨 배경 색상 글씨 배경 색상     30 40 검정(Black) 90 100 회색(밝은 검정)   31 41 빨강(Red) 91 101 주황(밝은 빨강)   32 42 초록(Green) 92 102 연두(밝은 초록)   33 43 노랑(Yellow) 93 103 노랑(밝은 노랑)   34 44 파랑(Blue) 94 104 파랑(밝은 파랑)   35 45 보라(Magenta) 95 105 핑크(밝은 보라)   36 46 하늘(Cyan) 96 106 하늘(밝은 하늘)   37 47 하양(White) 97 107 하양(밝은 하양)    색상 외, 글씨에 다른 효과를 주는 코드는 아래 표와 같다.\n   코드 효과     00 기본 색상   01 굵은 글씨   04 밑줄 친   05 깜빡이는    참고로 05, 깜빡이는 속성은 직접 실험해봤는데 깜빡이지 않았다.\n이제 위의 내용을 바탕으로 LS_COLORS의 값 일부를 해석해보자\n   설정 값 해석     di=01;34 디렉토리는 굵은 파란색 글씨로 표현   ln=01;36 심볼릭 링크는 굵은 보라색 글씨로 표현   pi=40;33 파이프 파일은 검은색 배경에 노란색 글씨로 표현   bd=40;33;01 블록 장치 파일은 검은색 배경에 굵은 노란색 글씨로 표현    본 문서에서 설명되지 않은 부분은 공식 man page와 여기를 참고하자.\nLSCOLORS (BSD ls의 환경 변수) LSCOLORS는 2개 글자씩 해석하여, 아래 순서대로 색상을 결정한다.\n 디렉토리의 글씨, 배경 색 심볼릭 링크의 글씨, 배경 색 소켓 파일의 글씨, 배경 색 파이프 파일의 글씨, 배경 색 실행 파일의 글씨, 배경 색 블록 장치 파일의 글씨, 배경 색 글자 장치 파일의 글씨, 배경 색 SetUID 실행 파일의 글씨, 배경 색 SetGID 실행 파일의 글씨, 배경 색 other write 권한의 sticky bit가 없는 디렉토리의 글씨, 배경 색 other write 권한의 sticky bit가 있는 디렉토리의 글씨, 배경 색  색상의 구분 코드는 아래와 같다.\n   코드 색상 코드 색상     a 검은색(black) A 굵은 검은색   b 빨간색(red) B 굵은 빨간색   c 초록색(green) C 굵은 초록색   d 갈색(brown) D 굵은 갈색   e 파란색(blue) E 굵은 파란색   f 보라색(magenta) F 굵은 보라색   g 하늘색(cyan) G 굵은 하늘색   h 회색(grey) H 굵은 회색   x 기본색(흰색) X 굵은 기본색    위의 GNU ls 대비 노란색, 오렌지 등이 없으며, 색 반전, 밑줄 등의 효과가 없는 것을 알 수 있다.\n그럼 이전 해결법에서 설정한 LSCOLORS의 값 ExGxFxdxCxdadahbadacec을 순서대로 해석해보자.\n   글씨 배경 설명     E x 디렉토리는 굵은 파란색 글씨, 배경은 없음   G x 심볼릭 링크는 굵은 하늘색 글씨, 배경은 없음   F x 소켓 파일은 굵은 보라색 글씨, 배경은 없음   d x 파이프 파일은 갈색 글씨, 배경은 없음   C x 실행 파일은 굵은 초록색 글씨, 배경은 없음   d a 블록 장치 파일은 갈색 글씨, 배경은 검은색   d a 글자 장치 파일은 갈색 글씨, 배경은 검은색   h b SetUID 실행 파일은 회색 글씨, 배경은 빨간색   a d SetGID 실행 파일은 검은색 글씨, 배경은 갈색   a c other write, sticky bit가 있는 디렉토리는 검은색 글씨, 배경은 초록색   e c other write, sticky bit가 없는 디렉토리는 파란색 글씨, 배경은 초록색    만약 LSCOLORS의 값을 원하는 대로 수정하고 싶다면, 여기에서 직접 만들 수 있다. (GNU ls의 LS_COLORS도 출력할 수 있지만, 기존 dircolors 대비 색상의 종류가 부족하므로 추천하지 않는다.)\nGNU ls 내부 구조 분석한 코드 버전은 여기를 참고하자.\n색상 구분 상수 정의 파일 타입 별 기본 설정 값 LS_COLORS 값 해석 함수  596 597 598 599 600 601 602 603 604 605 606 607 608 609 610  enum indicator_no { C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK, C_FIFO, C_SOCK, C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID, C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK, C_CLR_TO_EOL }; static char const *const indicator_name[]= { \u0026#34;lc\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;ec\u0026#34;, \u0026#34;rs\u0026#34;, \u0026#34;no\u0026#34;, \u0026#34;fi\u0026#34;, \u0026#34;di\u0026#34;, \u0026#34;ln\u0026#34;, \u0026#34;pi\u0026#34;, \u0026#34;so\u0026#34;, \u0026#34;bd\u0026#34;, \u0026#34;cd\u0026#34;, \u0026#34;mi\u0026#34;, \u0026#34;or\u0026#34;, \u0026#34;ex\u0026#34;, \u0026#34;do\u0026#34;, \u0026#34;su\u0026#34;, \u0026#34;sg\u0026#34;, \u0026#34;st\u0026#34;, \u0026#34;ow\u0026#34;, \u0026#34;tw\u0026#34;, \u0026#34;ca\u0026#34;, \u0026#34;mh\u0026#34;, \u0026#34;cl\u0026#34;, NULL };     619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645  static struct bin_str color_indicator[] = { { LEN_STR_PAIR (\u0026#34;\\033[\u0026#34;) },\t/* lc: Left of color sequence */ { LEN_STR_PAIR (\u0026#34;m\u0026#34;) },\t/* rc: Right of color sequence */ { 0, NULL },\t/* ec: End color (replaces lc+rs+rc) */ { LEN_STR_PAIR (\u0026#34;0\u0026#34;) },\t/* rs: Reset to ordinary colors */ { 0, NULL },\t/* no: Normal */ { 0, NULL },\t/* fi: File: default */ { LEN_STR_PAIR (\u0026#34;01;34\u0026#34;) },\t/* di: Directory: bright blue */ { LEN_STR_PAIR (\u0026#34;01;36\u0026#34;) },\t/* ln: Symlink: bright cyan */ { LEN_STR_PAIR (\u0026#34;33\u0026#34;) },\t/* pi: Pipe: yellow/brown */ { LEN_STR_PAIR (\u0026#34;01;35\u0026#34;) },\t/* so: Socket: bright magenta */ { LEN_STR_PAIR (\u0026#34;01;33\u0026#34;) },\t/* bd: Block device: bright yellow */ { LEN_STR_PAIR (\u0026#34;01;33\u0026#34;) },\t/* cd: Char device: bright yellow */ { 0, NULL },\t/* mi: Missing file: undefined */ { 0, NULL },\t/* or: Orphaned symlink: undefined */ { LEN_STR_PAIR (\u0026#34;01;32\u0026#34;) },\t/* ex: Executable: bright green */ { LEN_STR_PAIR (\u0026#34;01;35\u0026#34;) },\t/* do: Door: bright magenta */ { LEN_STR_PAIR (\u0026#34;37;41\u0026#34;) },\t/* su: setuid: white on red */ { LEN_STR_PAIR (\u0026#34;30;43\u0026#34;) },\t/* sg: setgid: black on yellow */ { LEN_STR_PAIR (\u0026#34;37;44\u0026#34;) },\t/* st: sticky: black on blue */ { LEN_STR_PAIR (\u0026#34;34;42\u0026#34;) },\t/* ow: other-writable: blue on green */ { LEN_STR_PAIR (\u0026#34;30;42\u0026#34;) },\t/* tw: ow w/ sticky: black on green */ { LEN_STR_PAIR (\u0026#34;30;41\u0026#34;) },\t/* ca: black on red */ { 0, NULL },\t/* mh: disabled by default */ { LEN_STR_PAIR (\u0026#34;\\033[K\u0026#34;) },\t/* cl: clear to end of line */ };     2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839  static void parse_ls_color (void) { char const *p;\t/* Pointer to character being parsed */ char *buf;\t/* color_buf buffer pointer */ int ind_no;\t/* Indicator number */ char label[3];\t/* Indicator label */ struct color_ext_type *ext;\t/* Extension we are working on */ if ((p = getenv (\u0026#34;LS_COLORS\u0026#34;)) == NULL || *p == \u0026#39;\\0\u0026#39;) { /* LS_COLORS takes precedence, but if that\u0026#39;s not set then honor the COLORTERM and TERM env variables so that we only go with the internal ANSI color codes if the former is non empty or the latter is set to a known value. */ char const *colorterm = getenv (\u0026#34;COLORTERM\u0026#34;); if (! (colorterm \u0026amp;\u0026amp; *colorterm) \u0026amp;\u0026amp; ! known_term_type ()) print_with_color = false; return; } ext = NULL; strcpy (label, \u0026#34;??\u0026#34;); /* This is an overly conservative estimate, but any possible LS_COLORS string will *not* generate a color_buf longer than itself, so it is a safe way of allocating a buffer in advance. */ buf = color_buf = xstrdup (p); enum parse_state state = PS_START; while (true) { switch (state) { case PS_START:\t/* First label character */ switch (*p) { case \u0026#39;:\u0026#39;: ++p; break; case \u0026#39;*\u0026#39;: /* Allocate new extension block and add to head of linked list (this way a later definition will override an earlier one, which can be useful for having terminal-specific defs override global). */ ext = xmalloc (sizeof *ext); ext-\u0026gt;next = color_ext_list; color_ext_list = ext; ++p; ext-\u0026gt;ext.string = buf; state = (get_funky_string (\u0026amp;buf, \u0026amp;p, true, \u0026amp;ext-\u0026gt;ext.len) ? PS_4 : PS_FAIL); break; case \u0026#39;\\0\u0026#39;: state = PS_DONE;\t/* Done! */ goto done; default:\t/* Assume it is file type label */ label[0] = *(p++); state = PS_2; break; } break; case PS_2:\t/* Second label character */ if (*p) { label[1] = *(p++); state = PS_3; } else state = PS_FAIL;\t/* Error */ break; case PS_3:\t/* Equal sign after indicator label */ state = PS_FAIL;\t/* Assume failure... */ if (*(p++) == \u0026#39;=\u0026#39;)/* It *should* be... */ { for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no) { if (STREQ (label, indicator_name[ind_no])) { color_indicator[ind_no].string = buf; state = (get_funky_string (\u0026amp;buf, \u0026amp;p, false, \u0026amp;color_indicator[ind_no].len) ? PS_START : PS_FAIL); break; } } if (state == PS_FAIL) error (0, 0, _(\u0026#34;unrecognized prefix: %s\u0026#34;), quote (label)); } break; case PS_4:\t/* Equal sign after *.ext */ if (*(p++) == \u0026#39;=\u0026#39;) { ext-\u0026gt;seq.string = buf; state = (get_funky_string (\u0026amp;buf, \u0026amp;p, false, \u0026amp;ext-\u0026gt;seq.len) ? PS_START : PS_FAIL); } else state = PS_FAIL; break; case PS_FAIL: goto done; default: abort (); } } done: if (state == PS_FAIL) { struct color_ext_type *e; struct color_ext_type *e2; error (0, 0, _(\u0026#34;unparsable value for LS_COLORS environment variable\u0026#34;)); free (color_buf); for (e = color_ext_list; e != NULL; /* empty */) { e2 = e; e = e-\u0026gt;next; free (e2); } print_with_color = false; } if (color_indicator[C_LINK].len == 6 \u0026amp;\u0026amp; !STRNCMP_LIT (color_indicator[C_LINK].string, \u0026#34;target\u0026#34;)) color_symlink_as_referent = true; }       'use strict'; var containerId = JSON.parse(\"\\\"688d726a332b576f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  BSD ls 내부 구조 분석한 코드 버전은 여기를 참고하자.\nLSCOLORS 환경변수 읽어오는 부분 (ls.c) 파일 타입과 기본 설정 값(print.c) LSCOLORS 값 해석 함수(print.c)  511 512 513 514 515 516 517 518 519 520 521 522 523  #ifdef COLORLS \tif (f_color) { /* * We can\u0026#39;t put tabs and color sequences together: * column number will be incremented incorrectly * for \u0026#34;stty oxtabs\u0026#34; mode. */ f_notabs = 1; (void)signal(SIGINT, colorquit); (void)signal(SIGQUIT, colorquit); parsecolors(getenv(\u0026#34;LSCOLORS\u0026#34;)); } #endif     85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  #ifdef COLORLS /* Most of these are taken from \u0026lt;sys/stat.h\u0026gt; */ typedef enum Colors { C_DIR,\t/* directory */ C_LNK,\t/* symbolic link */ C_SOCK,\t/* socket */ C_FIFO,\t/* pipe */ C_EXEC,\t/* executable */ C_BLK,\t/* block special */ C_CHR,\t/* character special */ C_SUID,\t/* setuid executable */ C_SGID,\t/* setgid executable */ C_WSDIR,\t/* directory writeble to others, with sticky * bit */ C_WDIR,\t/* directory writeble to others, without * sticky bit */ C_NUMCOLORS\t/* just a place-holder */ } Colors; static const char *defcolors = \u0026#34;exfxcxdxbxegedabagacad\u0026#34;;     656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702  void parsecolors(const char *cs) { int i; int j; size_t len; char c[2]; short legacy_warn = 0; if (cs == NULL) cs = \u0026#34;\u0026#34;;\t/* LSCOLORS not set */ len = strlen(cs); for (i = 0; i \u0026lt; (int)C_NUMCOLORS; i++) { colors[i].bold = 0; if (len \u0026lt;= 2 * (size_t)i) { c[0] = defcolors[2 * i]; c[1] = defcolors[2 * i + 1]; } else { c[0] = cs[2 * i]; c[1] = cs[2 * i + 1]; } for (j = 0; j \u0026lt; 2; j++) { /* Legacy colours used 0-7 */ if (c[j] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c[j] \u0026lt;= \u0026#39;7\u0026#39;) { colors[i].num[j] = c[j] - \u0026#39;0\u0026#39;; if (!legacy_warn) { warnx(\u0026#34;LSCOLORS should use \u0026#34; \u0026#34;characters a-h instead of 0-9 (\u0026#34; \u0026#34;see the manual page)\u0026#34;); } legacy_warn = 1; } else if (c[j] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c[j] \u0026lt;= \u0026#39;h\u0026#39;) colors[i].num[j] = c[j] - \u0026#39;a\u0026#39;; else if (c[j] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c[j] \u0026lt;= \u0026#39;H\u0026#39;) { colors[i].num[j] = c[j] - \u0026#39;A\u0026#39;; colors[i].bold = 1; } else if (tolower((unsigned char)c[j]) == \u0026#39;x\u0026#39;) colors[i].num[j] = -1; else { warnx(\u0026#34;invalid character \u0026#39;%c\u0026#39; in LSCOLORS\u0026#34; \u0026#34; env var\u0026#34;, c[j]); colors[i].num[j] = -1; } } } }       'use strict'; var containerId = JSON.parse(\"\\\"fe26f32a8629bb60\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"","id":22,"section":"posts","tags":["shell","macOS"],"title":"macOS에서의 ls 색상을 리눅스와 동일하게 변경하는 법","uri":"https://devlog.jsyoo5b.net/ko/posts/shell/ls-colors-in-mac-os/"},{"content":"《특판남이 알려주는 돈 되는 특허 A to Z》 스터디 요약 노트입니다.\n특허 문서 엿보기 기술 특허 관련 문서를 통해 특허 출원이나 다른 사업 구상에 참고 자료로 사용할 수 있다. 물론 특허 관련 문서를 통해 특허 프로세스를 이해할 수도 있다.\n특허의 개념, 용어 특허청의 자료를 인용하여 내용을 요약해봤다.\n특허의 목적  발명을 보호/장려하여 국가산업의 발전을 도모하기 위한 제도 기술 공개를 대가로 특허권을 부여함 국가는 기술 공개 → 기술 축적, 공개 기술 활용 → 산업 발전 식의 이익을 얻음 발명자에게는 국가가 독점권을 부여해줌으로서 보상함  특허와 실용신안의 차이  특허는 발명이 대상, 실용신안은 고안이 대상 발명의 특허법 상 정의는 \u0026ldquo;자연 법칙을 이용한 기술적 사상의 창작으로서 고도한 것\u0026rdquo; 고안의 특허법 상 정의는 \u0026ldquo;자연 법칙을 이용한 기술적 사상의 창작\u0026rdquo; 고도성 여부에 따라 특허냐 실용신안이냐를 나누며, 그 판단은 주관적  더 자세한 설명은 여기를 참고하자.\n특허 출원  발명을 특허청에 제출하는 것 독점권이 생기는 것이 아님 출원 전에는 해당 발명을 공개해선 안됨 (예외 조항이 있긴 함) 즉, 비공개 상태이기 때문에 출원자만 아는 기술임  특허 공개  특허는 출원한지 1년 6개월 이후에는 공개됨 모든 사람이 볼 수 있도록 특허 명세서가 공개됨 등록이 되지 않은 특허도 공개됨  특허 등록  출원된 특허가 심사를 거친 것 독점권이 발생함 등록자는 특허 연차료를 납부해야 함  공개공보 위의 개념 및 용어에서 설명했듯, 출원된 특허는 1년 6개월 뒤 공개된다. 공개 공보를 통홰 해당 특허의 기술을 알 수 있다.\n등록공보 특허가 심사 과정을 거쳐 등록이 결정되고, 출원인이 등록료를 납부하면 특허가 등록된다. 공개공보와 차이는 확정 권리범위다. 독점권 인정 범위를 결정짓는 문서다.\n국내 특허 조회하는 방법 국내 특허는 키프리스에서 검색할 수 있다. 만약 특허 번호를 알고 있다면 doi를 활용할 수 있는데, https://doi.org/10.8080/$특허번호로 키프리스에서 해당 특허 번호를 검색한 결과로 바로 이동할 수 있다. 예를 들어 특허 출원 번호 10-2006-0125966(저자의 특허)을 조회하고 싶다면, https://doi.org/10.8080/1020060125966로 접근할 수 있다.\n","description":"","id":23,"section":"posts","tags":["특허"],"title":"특판남이 알려주는 돈 되는 특허 A to Z 2장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/patent/musthave/ch02/"},{"content":"《특판남이 알려주는 돈 되는 특허 A to Z》 스터디 요약 노트입니다.\n이전 Go 언어 스터디에서 많이 배운 바 있고, 상식을 좀 더 넓히자는 관점에서 특허 스터디에 참여하게 되었다.\n특허는 어떻게 돈이 되는가?  특허를 활용해 직접 사업을 한다. 내 특허를 이용한 제 3자로부터 수익의 일부를 로열티로 받는다. 상대방 특허 공격에서 방패 역할을 하고, 크로스 라이선스를 맺기도 한다. 특허 자체를 판매한다. (제3자에게 양도, 저자의 이야기) 특허 위주의 포트폴리오를 구성하여 사업을 제3자에게 이전한다. (특허 기업 장사)  UI/UX도 특허가 된다 책에서 나온 사례인 \u0026lsquo;호갱노노\u0026rsquo;의 UI/UX 특허처럼 UI/UX 관련 특허도 출원이 가능하다.\n심지어 가장 유명한 사례인 \u0026lsquo;밀어서 잠금 해제\u0026rsquo;를 활용하여 애플이 여러 스마트폰 제조사에게 소송을 걸었던 것을 생각해보면 당연한 사실이었다.\n특허 생애 주기  아이디어 착상 아이디어 구체화 (연구/개발) 발명 명세서 작성 특허 출원 특허 공개 특허 심사 특허 결정 특허 등록/취소 신청 특허권 활용 특허권 소멸  실제 특허 관련 이야기는 4. 특허 출원부터 시작이지만, 특허는 어디까지나 발명을 전제로 하기 때문에 이전 단계가 존재한다.\n그냥 특허를 낸다는 개념이 아니라, 대외적으로는 특허 출원 → 공개 → 심사 → 결정 → 등록 단계를 거친다.\n더 자세한 설명은 책을 보고 스터디를 참여하면서 익숙해 져야 할 것 같다.\n","description":"","id":24,"section":"posts","tags":["특허"],"title":"특판남이 알려주는 돈 되는 특허 A to Z 1장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/patent/musthave/ch01/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n17장. 숫자 맞추기 게임 만들기 지금까지 배운 Go 언어의 기초적 문법을 활용하여 프로그램을 작성하는 프로젝트다.\n스터디 시간에는 time 패키지에 관해 설명이 있었으므로, time 패키지에 대한 설명을 먼저 하고, 책과 달리 직접 구현한 코드를 공유하도록 하겠다.\ntime 패키지 책에서는 의사 난수 생성시 초기 값을 매번 다르게 하기 위해 현재 시간을 seed 값으로 활용하는 방식을 구현하기 위해 time 패키지를 다뤘다.\n time.Time : 시각을 나타낸다. time.Duration : 시간(시각 - 시각)을 나타낸다. time.Location : 시간대를 나타낸다. (경도에 따른 시차)  숫자 맞추기 게임 해당 코드를 구현할 때 아래 조건도 추가했다.\n main 패키지의 init()함수에서 초기화 과정을 거친다. 상수 플래그로 디버깅 용 정보 출력 여부를 선택하게 한다. main() 코드 흐름을 최대한 단순하게 하자.  아래는 직접 구현한 코드다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) const Debug bool = true var stdin *bufio.Reader func main() { var guess int var trial uint answer := GenRandNumber() // Ask guess initially \tguess = UserInput() for trial = 1; guess != answer; trial++ { if guess \u0026gt; answer { fmt.Println(\u0026#34;Your number is greater than the answer.\u0026#34;) } else { fmt.Println(\u0026#34;Your number is lesser than the answer.\u0026#34;) } if guess \u0026lt; 0 || guess \u0026gt;= 100 { fmt.Println(\u0026#34;Hint: answer is a number in range from 0 to 99\u0026#34;) } // Ask your guess again \tguess = UserInput() } fmt.Println(\u0026#34;Correct, congratulation!\u0026#34;) fmt.Printf(\u0026#34;Tried %d times\u0026#34;, trial) } func init() { // Configure random seed \trand.Seed(time.Now().UnixNano()) stdin = bufio.NewReader(os.Stdin) } func GenRandNumber() int { // Generate random number from 0 to 99 \tanswer := rand.Intn(100) // For debugging condition, print answer first \tif Debug { fmt.Println(\u0026#34;Answer is :\u0026#34;, answer) } return answer } func UserInput() int { var n int for { fmt.Print(\u0026#34;Write your guess: \u0026#34;) _, err := fmt.Scanln(\u0026amp;n) if err != nil { stdin.ReadString(\u0026#39;\\n\u0026#39;) fmt.Println(\u0026#34;Please write only numbers!\u0026#34;) } else { return n } } }    \r$ ./match_number Answer is : 78 Write your guess: a Please write only numbers! Write your guess: 99 Your number is greater than the answer. Write your guess: 77 Your number is lesser than the answer. Write your guess: 100 Your number is greater than the answer. Hint: answer is a number in range from 0 to 99 Write your guess: -1 Your number is lesser than the answer. Hint: answer is a number in range from 0 to 99 Write your guess: 78 Correct, congratulation! Tried 5 times  \r  'use strict'; var containerId = JSON.parse(\"\\\"98c386c01dd9def7\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  저자 강의   ","description":"","id":25,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 17장 풀이","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch17/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n16장. 패키지 패키지는 Go 언어에서 코드를 공유하기 위해 사용되는 단위다.\n 패키지를 읽어 오는 방법은 import \u0026quot;$pkg\u0026quot;로 사용할 패키지를 선언한다. 여러 패키지를 읽어올 때는 ()로 패키지들을 다수 선언하면 된다. 패키지 이름이 겹치는 경우 등을 처리하기 위해, 패키지에 별칭을 붙일 수 있다. 사용하지 않지만 포함해야 하는 패키지의 경우 _(blank identifier)로 패키지 별칭을 붙인다. 원격 패키지를 가져오는 경우, go mod tidy 명령으로 해당 패키지를 다운받는다. 패키지에서 외부 공개할 변수,상수,함수는 대문자로 시작, 공개하지 않을 경우 소문자로 시작한다. 패키지가 import될 때 초기화가 필요한 내용은 init() 함수에 작성한다.  상당히 내용도 많고 복잡해서 실험 내용까지 올리기는 힘들 것 같다.\n저자 강의   ","description":"","id":26,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 16장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch16/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n15장. 문자열 문자열의 Go 언어에서의 특징만 확인해보자.\n backquote(`)으로 문자열을 감싸면 줄바꿈을 포함한 모든 문자열을 원형으로 작성할 수 있다. 기본적으로 UTF-8로 문자열이 인코딩된다. range로 각 문자를 rune 단위로 순회할 수 있다. 연산자(+=, ==, !=, \u0026lt;=)를 통해 문자열을 합치거나, 비교할 수 있다. 문자열의 내용은 불변이다.  여기서 UTF-8 인코딩에 관한 확인은 ch04에서 이미 실험한 바 있으므로 변환 과정은 생략하도록 하겠다.\n문자열 순회하기 문자열을 순회하는 방법에는 세가지 방법이 존재한다.\n 문자열을 바로 배열 취급하여 byte 단위로 순회 문자열을 []rune으로 타입 변환하여 배열 순회 range로 rune 단위로 순회  문자열 배열 순회 []rune 타입 변환 후 순회 range로 순회 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14  package main import \u0026#34;fmt\u0026#34; func main() { str := `backquote로 감싸진 string은 그대로 줄바꿈이 되지만 \\n은 동작하지 않습니다.` fmt.Println(str) for i := 0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026#34;Type: %T\tValue: %d\tChar: %c\\n\u0026#34;, str[i], str[i], str[i]) } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import \u0026#34;fmt\u0026#34; func main() { str := `backquote로 감싸진 string은 그대로 줄바꿈이 되지만 \\n은 동작하지 않습니다.` arr := []rune(str) fmt.Println(arr) for i := 0; i \u0026lt; len(arr); i++ { fmt.Printf(\u0026#34;Type: %T\tValue: %d\tChar: %c\\n\u0026#34;, arr[i], arr[i], arr[i]) } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14  package main import \u0026#34;fmt\u0026#34; func main() { str := `backquote로 감싸진 string은 그대로 줄바꿈이 되지만 \\n은 동작하지 않습니다.` fmt.Println(str) for _, v := range str { fmt.Printf(\u0026#34;Type: %T\tValue: %d\tChar: %c\\n\u0026#34;, v, v, v) } }    \r$ ./go_string_traversal_index backquote로 감싸진 string은 그대로 줄바꿈이 되지만 \\n은 동작하지 않습니다. Type: uint8\tValue: 98\tChar: b Type: uint8\tValue: 97\tChar: a Type: uint8\tValue: 99\tChar: c Type: uint8\tValue: 107\tChar: k Type: uint8\tValue: 113\tChar: q Type: uint8\tValue: 117\tChar: u Type: uint8\tValue: 111\tChar: o Type: uint8\tValue: 116\tChar: t Type: uint8\tValue: 101\tChar: e Type: uint8\tValue: 235\tChar: ë Type: uint8\tValue: 161\tChar: ¡ Type: uint8\tValue: 156\tChar:  Type: uint8\tValue: 32\tChar: Type: uint8\tValue: 234\tChar: ê Type: uint8\tValue: 176\tChar: ° Type: uint8\tValue: 144\tChar:  Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 139\tChar:  Type: uint8\tValue: 184\tChar: ¸ Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 167\tChar: § Type: uint8\tValue: 132\tChar:  Type: uint8\tValue: 32\tChar: Type: uint8\tValue: 115\tChar: s Type: uint8\tValue: 116\tChar: t Type: uint8\tValue: 114\tChar: r Type: uint8\tValue: 105\tChar: i Type: uint8\tValue: 110\tChar: n Type: uint8\tValue: 103\tChar: g Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 157\tChar:  Type: uint8\tValue: 128\tChar:  Type: uint8\tValue: 10\tChar: Type: uint8\tValue: 234\tChar: ê Type: uint8\tValue: 183\tChar: · Type: uint8\tValue: 184\tChar: ¸ Type: uint8\tValue: 235\tChar: ë Type: uint8\tValue: 140\tChar:  Type: uint8\tValue: 128\tChar:  Type: uint8\tValue: 235\tChar: ë Type: uint8\tValue: 161\tChar: ¡ Type: uint8\tValue: 156\tChar:  Type: uint8\tValue: 32\tChar: Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 164\tChar: ¤ Type: uint8\tValue: 132\tChar:  Type: uint8\tValue: 235\tChar: ë Type: uint8\tValue: 176\tChar: ° Type: uint8\tValue: 148\tChar:  Type: uint8\tValue: 234\tChar: ê Type: uint8\tValue: 191\tChar: ¿ Type: uint8\tValue: 136\tChar:  Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 157\tChar:  Type: uint8\tValue: 180\tChar: ´ Type: uint8\tValue: 32\tChar: Type: uint8\tValue: 235\tChar: ë Type: uint8\tValue: 144\tChar:  Type: uint8\tValue: 152\tChar:  Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 167\tChar: § Type: uint8\tValue: 128\tChar:  Type: uint8\tValue: 235\tChar: ë Type: uint8\tValue: 167\tChar: § Type: uint8\tValue: 140\tChar:  Type: uint8\tValue: 32\tChar: Type: uint8\tValue: 92\tChar: \\ Type: uint8\tValue: 110\tChar: n Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 157\tChar:  Type: uint8\tValue: 128\tChar:  Type: uint8\tValue: 32\tChar: Type: uint8\tValue: 235\tChar: ë Type: uint8\tValue: 143\tChar:  Type: uint8\tValue: 153\tChar:  Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 158\tChar:  Type: uint8\tValue: 145\tChar:  Type: uint8\tValue: 237\tChar: í Type: uint8\tValue: 149\tChar:  Type: uint8\tValue: 152\tChar:  Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 167\tChar: § Type: uint8\tValue: 128\tChar:  Type: uint8\tValue: 32\tChar: Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 149\tChar:  Type: uint8\tValue: 138\tChar:  Type: uint8\tValue: 236\tChar: ì Type: uint8\tValue: 138\tChar:  Type: uint8\tValue: 181\tChar: µ Type: uint8\tValue: 235\tChar: ë Type: uint8\tValue: 139\tChar:  Type: uint8\tValue: 136\tChar:  Type: uint8\tValue: 235\tChar: ë Type: uint8\tValue: 139\tChar:  Type: uint8\tValue: 164\tChar: ¤ Type: uint8\tValue: 46\tChar: . $ ./go_string_traversal_rune_array [98 97 99 107 113 117 111 116 101 47196 32 44048 49912 51652 32 115 116 114 105 110 103 51008 10 44536 45824 47196 32 51460 48148 45000 51060 32 46104 51648 47564 32 92 110 51008 32 46041 51089 54616 51648 32 50506 49845 45768 45796 46] Type: int32\tValue: 98\tChar: b Type: int32\tValue: 97\tChar: a Type: int32\tValue: 99\tChar: c Type: int32\tValue: 107\tChar: k Type: int32\tValue: 113\tChar: q Type: int32\tValue: 117\tChar: u Type: int32\tValue: 111\tChar: o Type: int32\tValue: 116\tChar: t Type: int32\tValue: 101\tChar: e Type: int32\tValue: 47196\tChar: 로 Type: int32\tValue: 32\tChar: Type: int32\tValue: 44048\tChar: 감 Type: int32\tValue: 49912\tChar: 싸 Type: int32\tValue: 51652\tChar: 진 Type: int32\tValue: 32\tChar: Type: int32\tValue: 115\tChar: s Type: int32\tValue: 116\tChar: t Type: int32\tValue: 114\tChar: r Type: int32\tValue: 105\tChar: i Type: int32\tValue: 110\tChar: n Type: int32\tValue: 103\tChar: g Type: int32\tValue: 51008\tChar: 은 Type: int32\tValue: 10\tChar: Type: int32\tValue: 44536\tChar: 그 Type: int32\tValue: 45824\tChar: 대 Type: int32\tValue: 47196\tChar: 로 Type: int32\tValue: 32\tChar: Type: int32\tValue: 51460\tChar: 줄 Type: int32\tValue: 48148\tChar: 바 Type: int32\tValue: 45000\tChar: 꿈 Type: int32\tValue: 51060\tChar: 이 Type: int32\tValue: 32\tChar: Type: int32\tValue: 46104\tChar: 되 Type: int32\tValue: 51648\tChar: 지 Type: int32\tValue: 47564\tChar: 만 Type: int32\tValue: 32\tChar: Type: int32\tValue: 92\tChar: \\ Type: int32\tValue: 110\tChar: n Type: int32\tValue: 51008\tChar: 은 Type: int32\tValue: 32\tChar: Type: int32\tValue: 46041\tChar: 동 Type: int32\tValue: 51089\tChar: 작 Type: int32\tValue: 54616\tChar: 하 Type: int32\tValue: 51648\tChar: 지 Type: int32\tValue: 32\tChar: Type: int32\tValue: 50506\tChar: 않 Type: int32\tValue: 49845\tChar: 습 Type: int32\tValue: 45768\tChar: 니 Type: int32\tValue: 45796\tChar: 다 Type: int32\tValue: 46\tChar: . $ ./go_string_traversal_range backquote로 감싸진 string은 그대로 줄바꿈이 되지만 \\n은 동작하지 않습니다. Type: int32\tValue: 98\tChar: b Type: int32\tValue: 97\tChar: a Type: int32\tValue: 99\tChar: c Type: int32\tValue: 107\tChar: k Type: int32\tValue: 113\tChar: q Type: int32\tValue: 117\tChar: u Type: int32\tValue: 111\tChar: o Type: int32\tValue: 116\tChar: t Type: int32\tValue: 101\tChar: e Type: int32\tValue: 47196\tChar: 로 Type: int32\tValue: 32\tChar: Type: int32\tValue: 44048\tChar: 감 Type: int32\tValue: 49912\tChar: 싸 Type: int32\tValue: 51652\tChar: 진 Type: int32\tValue: 32\tChar: Type: int32\tValue: 115\tChar: s Type: int32\tValue: 116\tChar: t Type: int32\tValue: 114\tChar: r Type: int32\tValue: 105\tChar: i Type: int32\tValue: 110\tChar: n Type: int32\tValue: 103\tChar: g Type: int32\tValue: 51008\tChar: 은 Type: int32\tValue: 10\tChar: Type: int32\tValue: 44536\tChar: 그 Type: int32\tValue: 45824\tChar: 대 Type: int32\tValue: 47196\tChar: 로 Type: int32\tValue: 32\tChar: Type: int32\tValue: 51460\tChar: 줄 Type: int32\tValue: 48148\tChar: 바 Type: int32\tValue: 45000\tChar: 꿈 Type: int32\tValue: 51060\tChar: 이 Type: int32\tValue: 32\tChar: Type: int32\tValue: 46104\tChar: 되 Type: int32\tValue: 51648\tChar: 지 Type: int32\tValue: 47564\tChar: 만 Type: int32\tValue: 32\tChar: Type: int32\tValue: 92\tChar: \\ Type: int32\tValue: 110\tChar: n Type: int32\tValue: 51008\tChar: 은 Type: int32\tValue: 32\tChar: Type: int32\tValue: 46041\tChar: 동 Type: int32\tValue: 51089\tChar: 작 Type: int32\tValue: 54616\tChar: 하 Type: int32\tValue: 51648\tChar: 지 Type: int32\tValue: 32\tChar: Type: int32\tValue: 50506\tChar: 않 Type: int32\tValue: 49845\tChar: 습 Type: int32\tValue: 45768\tChar: 니 Type: int32\tValue: 45796\tChar: 다 Type: int32\tValue: 46\tChar: .  \r  'use strict'; var containerId = JSON.parse(\"\\\"9aa750cfc84b2109\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  문자열 연산자 +, +=연산자를 사용하여 문자열을 합칠 수 있다. == !=연산자로 두 문자열이 같은지, 다른지 확인할 수 있으며, \u0026gt;=, \u0026lt;=연산자로 두 문자열을 유니코드 값 기준으로 순서를 비교할 수 있다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package main import \u0026#34;fmt\u0026#34; func main() { strHello := \u0026#34;hello\u0026#34; strWorld := \u0026#34;world\u0026#34; strHelloWorld := strHello strHelloWorld += strWorld strHelloExcl := strHello + \u0026#34; \u0026#34; + strWorld + \u0026#34;!\u0026#34; fmt.Println(strHelloWorld) fmt.Println(strHelloExcl) fmt.Printf(\u0026#34;It is %v that \\\u0026#34;%s\\\u0026#34; is equal with \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, strHelloWorld == strHelloExcl, strHelloWorld, strHelloExcl) if strHelloWorld \u0026lt; strHelloExcl { fmt.Printf(\u0026#34;%s comes before %s when strings are sorted in Unicode order\\n\u0026#34;, strHelloWorld, strHelloExcl) } else if strHelloWorld \u0026gt; strHelloExcl { fmt.Printf(\u0026#34;%s comes after %s when strings are sorted in Unicode order\\n\u0026#34;, strHelloWorld, strHelloExcl) } }    \r$ ./go_string_operators helloworld hello world! It is false that \u0026#34;helloworld\u0026#34; is equal with \u0026#34;hello world!\u0026#34; helloworld comes after hello world! when strings are sorted in Unicode order  \r  'use strict'; var containerId = JSON.parse(\"\\\"9059abe48ef5806b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  문자열의 구현 방식, 불변성 string의 내부 구현은 실제 문자열 데이터(UTF-8로 인코딩된 []byte, 해당 배열을 가리키는 포인터)와 해당 배열의 길이를 나타내는 길이로 표현하고 있다.\n그리고 StringHeader 구조체를 통해 해당 string의 내부를 엿볼수 있다.\n문자열을 복사할 때는 메모리 관리를 효율적으로 하기 위해 해당 배열을 가리키는 포인터와 배열의 길이만 복사한다.\n그리고 문자열의 데이터는 불변이기 때문에 임의로 코드에서 변경할 수 없다.\n임의로 문자열의 데이터를 변경하려면 []byte와 같이 자료형을 변환하고 해당 slice에서 수정해야 한다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { str := \u0026#34;Hello world\u0026#34; stringHeader := (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;str)) fmt.Println(stringHeader) slice := []byte(str) slice[2] = \u0026#39;a\u0026#39; fmt.Printf(\u0026#34;%s\\n\u0026#34;, slice) sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;slice)) fmt.Println(sliceHeader) newStr := string(slice) fmt.Println(newStr) newStrHeader := (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;newStr)) fmt.Println(newStrHeader) }    \r$ ./go_string_internals \u0026amp;{4343664238 11} Healo world \u0026amp;{1374389641488 11 16} Healo world \u0026amp;{1374389641520 11}  \r  'use strict'; var containerId = JSON.parse(\"\\\"83b43d03b2f02766\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  실행 결과를 보고 예측할 수 있는 점은 아래와 같다.\n 초기 사용된 str의 값은 상수 값으로 하드코딩된 값으로 들어간다. 문자열을 slice로 동적 변환했으므로, 해당 변수는 힙에 할당된다. 변경된 slice에서 다시 문자열로 변환하면 불변성을 유지해야 하기 때문에 새로운 주소에 해당 내용을 복사한다.  저자 강의   ","description":"","id":27,"section":"posts","tags":["golang","문자열 처리","인코딩"],"title":"Tucker의 Go 언어 프로그래밍 15장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch15/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n14장. 포인터 포인터의 Go 언어에서의 특징만 확인해보자.\n 빈 포인터의 표기는 null이 아니라 nil로 표현한다. 구조체를 가리키는 포인터에서 해당 구조체의 필드 접근은 -\u0026gt;이 아니라 .으로 가능하다. call-by-address를 통해 함수의 인자를 전달, 수정할 수 있다. new()를 사용하여 인스턴스를 생성할 수 있다. 인스턴스를 가리키는 포인터가 없으면 가비지 컬렉터가 메모리를 회수한다. go 컴파일러에서 탈출 분석을 확인하여, 지역변수가 콜 스택이 아니라 힙 영역에 존재할 수 있다.  기본적인 포인터 사용 go 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package main import \u0026#34;fmt\u0026#34; type Data struct { value int data [10]int } func main() { var data1 Data var pData1 *Data = \u0026amp;data1 var pData2 *Data = \u0026amp;Data{}\t// Create instance with indirect addressing \tvar pData3 *Data = new(Data) // Create with new()  fmt.Printf(\u0026#34;\u0026amp;data1: %p\\n\u0026#34;, \u0026amp;data1) fmt.Printf(\u0026#34;pData1: %p,\\t\u0026amp;pData1: %p\\n\u0026#34;, pData1, \u0026amp;pData1) fmt.Printf(\u0026#34;pData2: %p,\\t\u0026amp;pData2: %p\\n\u0026#34;, pData2, \u0026amp;pData2) fmt.Printf(\u0026#34;pData3: %p,\\t\u0026amp;pData3: %p\\n\u0026#34;, pData3, \u0026amp;pData3) CallByValue(data1, 10) fmt.Println(data1) CallByAddress(\u0026amp;data1, 10) fmt.Println(data1) CallByValue(*pData1, 20) fmt.Println(pData1) CallByAddress(pData1, 20) fmt.Println(pData1) var pData4 *Data = nil pData4.value = 40\t// Trigger segfault } func CallByValue(data Data, n int) { data.value = n data.data[0] = n / 10 fmt.Printf(\u0026#34;Call-by-value \u0026amp;data: %p\\n\u0026#34;, \u0026amp;data) } func CallByAddress(data *Data, n int) { data.value = n data.data[0] = n / 10 fmt.Printf(\u0026#34;Call-by-address \u0026amp;data: %p\\n\u0026#34;, data) }    \r$ ./go_pointer_basics \u0026amp;data1: 0x140000b2000 pData1: 0x140000b2000, \u0026amp;pData1: 0x140000ac018 pData2: 0x140000b2060, \u0026amp;pData2: 0x140000ac020 pData3: 0x140000b20c0, \u0026amp;pData3: 0x140000ac028 Call-by-value \u0026amp;data: 0x140000b2120 {0 [0 0 0 0 0 0 0 0 0 0]} Call-by-address \u0026amp;data: 0x140000b2000 {10 [1 0 0 0 0 0 0 0 0 0]} Call-by-value \u0026amp;data: 0x140000b2240 \u0026amp;{10 [1 0 0 0 0 0 0 0 0 0]} Call-by-address \u0026amp;data: 0x140000b2000 \u0026amp;{20 [2 0 0 0 0 0 0 0 0 0]} panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x2 addr=0x0 pc=0x10044fe78] goroutine 1 [running]: main.main() /Workspace/go/src/musthavego/ch14/go_pointer_basics.go:32 +0x408  \r  'use strict'; var containerId = JSON.parse(\"\\\"9953b5467f616fb5\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  가비지 컬렉터 순환 참조 각 인스턴스를 가리키는 포인터가 없을때 해당 변수는 가비지 컬렉션에 의해 메모리가 회수될 수 있다고 한다.\n그렇다면 순환 참조를 해서 각 인스턴스를 가리키는 포인터는 존재하지만, 해당 순환을 가리키는 변수가 없는 경우에도 가비지 컬렉션이 잘 동작하는지 확인해봤다.\ngo 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main type List struct { value int next *List } func main() { var pLists [100]*List for i := 0; true; i++{ var l1 List var l2 List var l3 List l1.next = \u0026amp;l2 l2.next = \u0026amp;l3 l3.next = \u0026amp;l1 l1.value = 1 l1.next.value = l1.value + 1 l1.next.next.value = l1.next.value + 1 pLists[i % 100] = \u0026amp;l1 } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"0bef8aaef0581fe3\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  직접 실행해 본 결과, 딱히 메모리 누수가 발생하지 않는 것으로 보였다. 하지만 컴파일러가 최적화 과정에서 해당 요소를 미리 차단했는지는 확실하지 않아서, 이 부분은 컴파일 옵션, 메모리 누수 확인 툴을 좀 더 공부해서 다시 확인해봐야 할 것 같다.\n탈출 분석 go 컴파일러는 탈출 분석을 하여 지역 변수의 주소를 return해도 오류가 나지 않는다. (해당 변수를 heap에 할당한다.)\n해당 부분을 검증하기 위해 직접 실험해보았다. 실험 결과 모든 변수는 자체적인 goroutine의 heap에 저장되는 것 같다.\ngo 코드 디버거 출력 메모리 레이아웃 확인  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package main import \u0026#34;fmt\u0026#34; type Data struct{ value int data [10]int } func main() { var data1 Data var data2 Data = *new(Data) var pData1 *Data = \u0026amp;data1 var pData2 *Data = \u0026amp;data2 var pData3 *Data = new(Data) var pData4 *Data = newData() var pData5 *Data n := 10 if n % 5 == 0 { // force variable allocation unpredictable \tpData5 = new(Data) } fmt.Printf(\u0026#34;pData1: %p\\n\u0026#34;, pData1) fmt.Printf(\u0026#34;pData2: %p\\n\u0026#34;, pData2) fmt.Printf(\u0026#34;pData3: %p\\n\u0026#34;, pData3) fmt.Printf(\u0026#34;pData4: %p\\n\u0026#34;, pData4) fmt.Printf(\u0026#34;pData5: %p\\n\u0026#34;, pData5) for { // Force infinite loop to check in /proc/**/maps \t} } func newData() *Data { var d Data = Data{} return \u0026amp;d }    \r$ dlv exec ./go_mem_layout_struct Type \u0026#39;help\u0026#39; for list of commands. (dlv) b go_mem_layout_struct.go:32 Breakpoint 1 (enabled) set at 0x499278 for main.main() ./go_mem_layout_struct.go:32 (dlv) continue pData1: 0xc000102060 pData2: 0xc0001020c0 pData3: 0xc000102120 pData4: 0xc000102180 pData5: 0xc0001021e0 \u0026gt; main.main() ./go_mem_layout_struct.go:32 (hits goroutine(1):1 total:1) (PC: 0x499278) Warning: debugging optimized function 29:\tfmt.Printf(\u0026#34;pData4: %p\\n\u0026#34;, pData4) 30:\tfmt.Printf(\u0026#34;pData5: %p\\n\u0026#34;, pData5) 31: =\u0026gt; 32:\tfor { 33:\t// Force infinite loop to check in /proc/**/map 34:\t} (dlv) regs Rip = 0x0000000000499278 Rsp = 0x000000c000108eb0 Rax = 0x0000000000000000 Rbx = 0x000000c00011e000 Rcx = 0x0000000000000000 Rdx = 0x0000000000000000 Rsi = 0x0000000000000000 Rdi = 0x0000000000000000 Rbp = 0x000000c000108f78 R8 = 0x0000000000000000 R9 = 0x0000000000000000 R10 = 0xfffff80000000001 R11 = 0x0000000000000212 R12 = 0x000000c0000161b0 R13 = 0x000000000000003b R14 = 0x0000000000000013 R15 = 0xffffffffffffffff Rflags = 0x0000000000000202 [IF IOPL=0] Es = 0x0000000000000000 Cs = 0x0000000000000033 Ss = 0x000000000000002b Ds = 0x0000000000000000 Fs = 0x0000000000000000 Gs = 0x0000000000000000 Fs_base = 0x000000000054e5b0 Gs_base = 0x0000000000000000  \r$ cat /proc/70871/maps 00400000-0049a000 r-xp 00000000 08:01 4456778 /Workspace/go/src/musthavego/ch14/go_mem_layout_struct 0049a000-00538000 r--p 0009a000 08:01 4456778 /Workspace/go/src/musthavego/ch14/go_mem_layout_struct 00538000-0054e000 rw-p 00138000 08:01 4456778 /Workspace/go/src/musthavego/ch14/go_mem_layout_struct 0054e000-00581000 rw-p 00000000 00:00 0 c000000000-c004000000 rw-p 00000000 00:00 0 7fc392bef000-7fc394fa0000 rw-p 00000000 00:00 0 7fc394fa0000-7fc3a5120000 ---p 00000000 00:00 0 7fc3a5120000-7fc3a5121000 rw-p 00000000 00:00 0 7fc3a5121000-7fc3b6fd0000 ---p 00000000 00:00 0 7fc3b6fd0000-7fc3b6fd1000 rw-p 00000000 00:00 0 7fc3b6fd1000-7fc3b93a6000 ---p 00000000 00:00 0 7fc3b93a6000-7fc3b93a7000 rw-p 00000000 00:00 0 7fc3b93a7000-7fc3b9820000 ---p 00000000 00:00 0 7fc3b9820000-7fc3b9821000 rw-p 00000000 00:00 0 7fc3b9821000-7fc3b98a0000 ---p 00000000 00:00 0 7fc3b98a0000-7fc3b9900000 rw-p 00000000 00:00 0 7fff8d006000-7fff8d027000 rw-p 00000000 00:00 0 [stack] 7fff8d08f000-7fff8d093000 r--p 00000000 00:00 0 [vvar] 7fff8d093000-7fff8d095000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall] $ objdump -h go_mem_layout_struct go_mem_layout_struct: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 0009828a 0000000000401000 0000000000401000 00001000 2**5 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .rodata 00044167 000000000049a000 000000000049a000 0009a000 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 2 .typelink 00000734 00000000004de300 00000000004de300 000de300 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 3 .itablink 00000050 00000000004dea40 00000000004dea40 000dea40 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .gosymtab 00000000 00000000004dea90 00000000004dea90 000dea90 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 5 .gopclntab 00058ab8 00000000004deaa0 00000000004deaa0 000deaa0 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 6 .go.buildinfo 00000020 0000000000538000 0000000000538000 00138000 2**4 CONTENTS, ALLOC, LOAD, DATA 7 .noptrdata 0000e2c4 0000000000538020 0000000000538020 00138020 2**5 CONTENTS, ALLOC, LOAD, DATA 8 .data 00007790 0000000000546300 0000000000546300 00146300 2**5 CONTENTS, ALLOC, LOAD, DATA 9 .bss 0002d750 000000000054daa0 000000000054daa0 0014daa0 2**5 ALLOC 10 .noptrbss 00005310 000000000057b200 000000000057b200 0017b200 2**5 ALLOC 11 .zdebug_abbrev 000001e6 0000000000581000 0000000000581000 0014e000 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 12 .zdebug_line 00032ac5 0000000000581119 0000000000581119 0014e119 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 13 .zdebug_frame 00010144 000000000059daa3 000000000059daa3 0016aaa3 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 14 .debug_gdb_scripts 0000002d 00000000005a3643 00000000005a3643 00170643 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 15 .zdebug_info 0007d8a7 00000000005a3670 00000000005a3670 00170670 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 16 .zdebug_loc 00087fc6 00000000005d6e41 00000000005d6e41 001a3e41 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 17 .zdebug_ranges 00032a70 00000000005eeb07 00000000005eeb07 001bbb07 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 18 .note.go.buildid 00000064 0000000000400f9c 0000000000400f9c 00000f9c 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA  \r  'use strict'; var containerId = JSON.parse(\"\\\"b0bd5bb535b723bf\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  프로세스의 메모리 레이아웃 확인, 스택 포인터 레지스터의 값(Rsp), 각 변수의 주소를 확인해 본 결과 아래와 같은 사실을 알 수 있다.\n 현재 go 코드가 실행되고 있는 위치는 전통적인 스택 세그먼트가 아니다.\n아마 go runtime이 스택 세그먼트 위에서 동작하며, 실제 go 코드를 수행하는 goroutine이 다른 세그먼트에서 동작하는 것으로 보인다.  procfs의 stack 세그먼트는 0x00007fff8d006000 ~ 0x00007fff8d027000 현재 스택 포인터 레지스터 값은 0x000000c000108eb0 변수들의 주소 값은 0x000000c000102060 ~ 0x000000c0001021e0 즉, 현재 goroutine이 사용중인 세그먼트는 0x000000c000000000 ~ 0x000000c004000000로 볼 수 있다.   변수들은 지역변수, 동적할당 변수 관계 없이 자체적인 힙 영역에 할당하는 것으로 보인다.  현재 스택 포인터 레지스터 값은 0x000000c000108eb0 변수들의 주소 값은 0x000000c000102060 ~ 0x000000c0001021e0 변수들의 주소값과 스택 포인터의 값이 약 0x6000 이상의 차이를 보이고 있다. 변수들이 지역변수, 동적할당 변수, 탈출분석에 의한 변수 관계없이 모두 같은 간격으로 배치되어있다. (0x60) 일반적으로 콜 스택이 큰 값에서 작은 값으로 자라고, 변수들이 선언 순서에 따라 주소 값이 커지는 것으로 보아\n변수는 내부적으로 콜 스택에 저장된다고 보기 힘들 수 있다.    혹시 접근하는 변수 타입이 struct라서 무조건 heap을 사용하는 것이고, 기본 자료형을 사용하면 stack에 값이 들어가는지 추가로 확인해봤다.\ngo 코드 디버거 출력  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package main import \u0026#34;fmt\u0026#34; func main() { var num1 int var num2 int = *new(int) var pInt1 *int = \u0026amp;num1 var pInt2 *int = \u0026amp;num2 var pInt3 *int = new(int) var pInt4 *int = newint() var pInt5 *int n := 10 if n % 5 == 0 { // force variable allocation unpredictable \tpInt5 = new(int) } fmt.Printf(\u0026#34;pInt1: %p\\n\u0026#34;, pInt1) fmt.Printf(\u0026#34;pInt2: %p\\n\u0026#34;, pInt2) fmt.Printf(\u0026#34;pInt3: %p\\n\u0026#34;, pInt3) fmt.Printf(\u0026#34;pInt4: %p\\n\u0026#34;, pInt4) fmt.Printf(\u0026#34;pInt5: %p\\n\u0026#34;, pInt5) for { // Force infinite loop to check in /proc/**/maps \t} } func newint() *int { var d int = 0 return \u0026amp;d }    \r$ dlv exec ./go_mem_layout_int Type \u0026#39;help\u0026#39; for list of commands. (dlv) b go_mem_layout_int.go:27 Breakpoint 1 (enabled) set at 0x499245 for main.main() ./go_mem_layout_int.go:27 (dlv) continue pInt1: 0xc00001a0f0 pInt2: 0xc00001a0f8 pInt3: 0xc00001a100 pInt4: 0xc00001a108 pInt5: 0xc00001a110 \u0026gt; main.main() ./go_mem_layout_int.go:27 (hits goroutine(1):1 total:1) (PC: 0x499245) Warning: debugging optimized function 24: fmt.Printf(\u0026#34;pInt4: %p\\n\u0026#34;, pInt4) 25: fmt.Printf(\u0026#34;pInt5: %p\\n\u0026#34;, pInt5) 26: =\u0026gt; 27: for { 28: // Force infinite loop to check in /proc/**/map 29: } (dlv) regs Rip = 0x0000000000499245 Rsp = 0x000000c000108eb0 Rax = 0x0000000000000000 Rbx = 0x000000c00011e000 Rcx = 0x0000000000000000 Rdx = 0x0000000000000000 Rsi = 0x0000000000000000 Rdi = 0x0000000000000000 Rbp = 0x000000c000108f78 R8 = 0x0000000000000000 R9 = 0x0000000000000000 R10 = 0xfffff80000000001 R11 = 0x0000000000000212 R12 = 0x000000c0000161b0 R13 = 0x000000000000003b R14 = 0x0000000000000013 R15 = 0xffffffffffffffff Rflags = 0x0000000000000202 [IF IOPL=0] Es = 0x0000000000000000 Cs = 0x0000000000000033 Ss = 0x000000000000002b Ds = 0x0000000000000000 Fs = 0x0000000000000000 Gs = 0x0000000000000000 Fs_base = 0x000000000054e5b0 Gs_base = 0x0000000000000000  \r  'use strict'; var containerId = JSON.parse(\"\\\"391b31b44194a9df\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  int의 크기인 8 byte 간격으로 떨어진 것을 보아 기본 자료형이던, struct정의 자료형이던 비슷한 증상이 나타나는 것을 확인할 수 있었다.\n나와 같은 질문에 대해 Go언어 문서 FAQ에서는 변수가 스택에 저장되는지, 힙에 저장되는지 알 필요가 없다고 한다. 위 코드의 증상에 대한 설명을 추가하자면, 주소를 사용하는 변수는 힙에 할당될 가능성이 높다고 볼 수 있다.\nGo의 메모리 할당에 대한 설명을 읽어보면, Go runtime에서는 전통적인 OS의 스택이 아닌, goroutine만의 콜 스택을 생성하고, 콜 스택이 overflow가 일어나기 전에 더 큰 콜 스택으로 복사하는 작업을 수행한다고 한다. 이 상황에서 지역변수를 포인터로 접근하게 되면, 콜 스택이 복사될 때 해당 포인터들이 댕글링 포인터가 될 수도 있기 때문에 해당 변수들을 힙에 할당할 후보가 되는 것 같다.\n해당 글에서 알려준 빌드 옵션 -m -l을 추가해서 컴파일러의 탈출 분석 과정을 확인하면, 모든 인스턴스를 탈출로 판단하여 heap에 넣는 것을 확인할 수 있다.\n구조체 버전 탈출 분석 결과 int 버전 탈출 분석 결과  $ go build -gcflags \u0026#39;-m -l\u0026#39; go_mem_layout_struct.go # command-line-arguments ./go_mem_layout_struct.go:38:6: moved to heap: d ./go_mem_layout_struct.go:11:6: moved to heap: data1 ./go_mem_layout_struct.go:12:6: moved to heap: data2 ./go_mem_layout_struct.go:12:23: new(Data) does not escape ./go_mem_layout_struct.go:16:24: new(Data) escapes to heap ./go_mem_layout_struct.go:23:15: new(Data) escapes to heap ./go_mem_layout_struct.go:26:12: ... argument does not escape ./go_mem_layout_struct.go:27:12: ... argument does not escape ./go_mem_layout_struct.go:28:12: ... argument does not escape ./go_mem_layout_struct.go:29:12: ... argument does not escape ./go_mem_layout_struct.go:30:12: ... argument does not escape  \r$ go build -gcflags \u0026#39;-m -l\u0026#39; go_mem_layout_int.go # command-line-arguments ./go_mem_layout_int.go:33:6: moved to heap: d ./go_mem_layout_int.go:6:6: moved to heap: num1 ./go_mem_layout_int.go:7:6: moved to heap: num2 ./go_mem_layout_int.go:7:21: new(int) does not escape ./go_mem_layout_int.go:11:22: new(int) escapes to heap ./go_mem_layout_int.go:18:14: new(int) escapes to heap ./go_mem_layout_int.go:21:12: ... argument does not escape ./go_mem_layout_int.go:22:12: ... argument does not escape ./go_mem_layout_int.go:23:12: ... argument does not escape ./go_mem_layout_int.go:24:12: ... argument does not escape ./go_mem_layout_int.go:25:12: ... argument does not escape  \r  'use strict'; var containerId = JSON.parse(\"\\\"b4c358387bfb5529\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  저자 강의   ","description":"","id":28,"section":"posts","tags":["golang","메모리 구조"],"title":"Tucker의 Go 언어 프로그래밍 14장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch14/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n13장. 구조체 구조체의 Go 언어에서의 특징만 확인해보자.\n class가 없이, struct만 존재한다. 상속의 is-a 관계가 아닌 has-a 관계로만 구조체 관계를 정의한다. 구조체 속의 구조체 사용에서, 내부 구조체 필드 이름을 제외하면 구조체 확장과 비슷하게 사용할 수 있다. 메서드의 선언, 정의는 구조체 밖에서 이루어진다.  이 중 메서드 관련 내용은 추후 책에서 다루므로 여기에선 간단하게 무슨 의미인지 언급만 하고 지나가도록 하겠다.\n구조체의 선언 책에서는 무조건적으로 struct 타입 선언 시, 타입 명을 같이 선언해야 하는 것 처럼 표현되어있지만, 타입 이름이 없는 익명 구조체 타입을 선언할 수 있다. (물론 활용도가 이름 있는 타입에 비해 떨어지기 때문에 없다고 생각해도 무방할 것으로 보인다.)\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import \u0026#34;fmt\u0026#34; func main() { var contact1 struct { Name\tstring Id\tint Cell\tstring } fmt.Println(contact1) contact1.Id = 1 contact1.Name = \u0026#34;John Doe\u0026#34; contact1.Cell = \u0026#34;1 234-567-890\u0026#34; // Copy anonymous struct into the other variable \tcontact2 := contact1 contact2.Name = \u0026#34;Jane Doe\u0026#34; contact2.Id = 2 fmt.Println(contact1) fmt.Println(contact2) }    \r$ ./go_anonymous_struct { 0 } {John Doe 1 1 234-567-890} {Jane Doe 2 1 234-567-890}  \r  'use strict'; var containerId = JSON.parse(\"\\\"26c87d6e61367e1c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  구조체를 포함하는 구조체 먼저 다른 구조체를 일반 타입처럼 포함하는 방식으로 실험해보자. 추가로 내부 구조체를 변수로 선언한 뒤, 바로 복사가 가능한지, 구조체 내부 필드 중 일부만 초기화하는 것도 확인해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type User struct { Name\tstring Id\tint Age\tint } type VipUser struct { UserInfo\tUser Level\tint Since\ttime.Time } func main() { var john User = User{\u0026#34;John Doe\u0026#34;, 1, 30} var johnVip VipUser = VipUser{UserInfo: john, Level: 1} janeVip := VipUser{User{\u0026#34;Jane Doe\u0026#34;, 2, 32}, 2, time.Now()} fmt.Println(johnVip) fmt.Println(janeVip) fmt.Printf(\u0026#34;VIP user %s became VIP since %v\u0026#34;, janeVip.UserInfo.Name, janeVip.Since) }    \r$ ./go_struct_in_struct {{John Doe 1 30} 1 0001-01-01 00:00:00 +0000 UTC} {{Jane Doe 2 32} 2 2021-05-31 13:06:28.78326 +0900 KST m=+0.000120543} VIP user Jane Doe became VIP since 2021-05-31 13:06:28.78326 +0900 KST m=+0.000120543  \r  'use strict'; var containerId = JSON.parse(\"\\\"a719b4a4d9c98738\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이제 포함된 필드(Embedded field) 방식으로 다시 실험해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type User struct { Name\tstring Id\tint Age\tint } type VipUser struct { User Level\tint Since\ttime.Time } func main() { var john User = User{\u0026#34;John Doe\u0026#34;, 1, 30} var johnVip VipUser = VipUser{User: john, Level: 1} janeVip := VipUser{User{\u0026#34;Jane Doe\u0026#34;, 2, 32}, 2, time.Now()} fmt.Println(johnVip) fmt.Println(janeVip) fmt.Printf(\u0026#34;VIP user %s became VIP since %v\u0026#34;, janeVip.Name, janeVip.Since) }    \r$ ./go_embedded_struct {{John Doe 1 30} 1 0001-01-01 00:00:00 +0000 UTC} {{Jane Doe 2 32} 2 2021-05-31 13:13:14.075062 +0900 KST m=+0.000131959} VIP user Jane Doe became VIP since 2021-05-31 13:13:14.075062 +0900 KST m=+0.000131959  \r  'use strict'; var containerId = JSON.parse(\"\\\"db22e342d2be2a53\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  구조체 패딩 go에서도 구조체 내 멤버 접근 속도를 빠르게 하기 위해 메모리 패딩을 수행한다. 확실한 비교를 위해 책에 나온 예제에서 주소 값까지 찍어보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type Unoptimized struct { A\tint8 B\tint C int8 D int E int8 } type Optimized struct { A int8 C int8 E int8 B int D int } func main() { var1 := Unoptimized{} var2 := Optimized{} fmt.Printf(\u0026#34;sizeof Unoptimized: %d, Optimized: %d\\n\u0026#34;, unsafe.Sizeof(var1), unsafe.Sizeof(var2)) fmt.Printf(\u0026#34;\\nUnoptimized\\n\\tA: %p\\n\\tB: %p\\n\\tC: %p\\n\\tD: %p\\n\\tE: %p\\n\u0026#34;, \u0026amp;var1.A, \u0026amp;var1.B, \u0026amp;var1.C, \u0026amp;var1.D, \u0026amp;var1.E) fmt.Printf(\u0026#34;\\nOptimized\\n\\tA: %p\\n\\tB: %p\\n\\tC: %p\\n\\tD: %p\\n\\tE: %p\\n\u0026#34;, \u0026amp;var2.A, \u0026amp;var2.B, \u0026amp;var2.C, \u0026amp;var2.D, \u0026amp;var2.E) }    \r$ ./go_struct_padding sizeof Unoptimized: 40, Optimized: 24 Unoptimized A: 0x140000b2030 B: 0x140000b2038 C: 0x140000b2040 D: 0x140000b2048 E: 0x140000b2050 Optimized A: 0x140000ba000 B: 0x140000ba008 C: 0x140000ba001 D: 0x140000ba010 E: 0x140000ba002  \r  'use strict'; var containerId = JSON.parse(\"\\\"a8d6d69b37dfc9b9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  구조체의 메서드 비슷하게 struct만 사용할 수 있는 C언어와 비교해보자.\nC언어 Go  // struct 선언 struct MyStr { uint capacity; uint length; char *storage; // method 목록 선언 (함수 포인터)  int (*GetLength)(struct MyStr *ms); void (*Append)(struct MyStr *ms, struct MyStr *follow); }; // method 구현 (함수 정의) int _getLength(struct MyStr *ms) { // Implemenation... }; void _append(struct MyStr *ms, struct MyStr *follow) { // Implemenation... }; // struct 변수 초기화 struct MyStr str1 = {0, 0, NULL}; str1.GetLength = _getLength; // 함수 포인터 매핑 str1.Append = _append; // 함수 포인터 매핑  // struct method 사용 int length = str1.GetLength(\u0026amp;str1); str1.Append(\u0026amp;str1, \u0026amp;str2);  \r// struct 선언 type MyStr struct { capacity uint length uint storage *byte; } // method 선언, 정의 func (ms *MyStr) Length() int { // Implementation... } func (ms *MyStr) Append(MyStr *follow) { // Implementation... } // struct 변수 초기화 var str1 MyStr = MyStr {0, 0, nil} // struct method 사용 length := str1.GetLength(); str1.Append(\u0026amp;str2);  \r  'use strict'; var containerId = JSON.parse(\"\\\"25f28e8b55e39e91\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위 예시에서 보듯 method 목록 선언이 구조체 밖에서 이루어진다. 더 자세한 부분은 추후 메서드를 다루는 장에서 자세히 보도록 하겠다.\n저자 강의   ","description":"","id":29,"section":"posts","tags":["golang","객체 지향"],"title":"Tucker의 Go 언어 프로그래밍 13장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch13/"},{"content":"iamroot 17기 스터디를 다행히 아직 참여하고 있다. 요새 진도 내용을 잘 못 따라가고 있기도 하고, 이전 스터디에 대한 복습이 필요한 것 같아, 내용을 정리하려 한다.\n이전보다는 리눅스 커널 소스도 직접 읽어보고, 추가적으로 공부한 지식이 있으니, 당시 있던 의문에 더 정확한 결론을 내릴 수 있을 것 같다.\n스터디 초기에는 커널의 내부 구성, 역할 등에 대한 이론을 이해하기 위해 리눅스 커널 내부 구조를 참고해 이론 스터디를 진행했다.\n2주차 진도는 Chapter.4 (p96 ~ p127)이었다.\nChapter.4 메모리 관리 Q. 가상주소보다 물리주소공간이 더 큰 경우 어떻게 해결하는가? (p96) 가상 메모리 개념을 도입해서 얻는 효과에는 어떤 것이 있을까?\n 물리 메모리의 크기가 일정하지 않아도 (실행하려는 프로그램의 메모리 크기보다 작아도) 호환 가능하다. 여러 프로그램을 동시에 구동하는 데 있어 다른 프로그램의 메모리 주소 영역을 고민하지 않아도 된다.  이 중 기술 발달에 의해 가상 메모리의 크기보다 물리 메모리보다 큰 경우가 일반화 될 수 있는 세상이 왔다. (32-bit 기준 2^32인 4GB 이상의 RAM을 쉽게 구매할 수 있다.)\n이런 경우 PAE(Physical Address Extension) 기술을 사용하여 물리 주소 접근을 위한 주소 공간의 크기를 늘린다. 좀 더 쉬운 설명은 여기를 참고하면 좋을 것 같다.\nPAE 기술을 대략 요약하자면 다음과 같다.\n 원래 접근 가능한 물리 주소의 범위는 2^32인데, 이를 늘린다. (32bit -\u0026gt; 36bit) Page frame의 크기가 4KB(2^12)일때, Page directory / Page table은 4 bytes(2^2) 크기 entry를 1024(2^10)개 가리킬 수 있었다. Page directory / Page table의 entry를 8 bytes(2^3) 크기 entry를 512(2^9)개 가리키게 변경한다. 기존에는 Page directory (2^10) + Page table (2^10) 방식의 2단계 paging으로 2^32 주소 공간의 Page frame을 가리킨다. PAE 적용시 Page directory pointer (2^2) + Page directory (2^9) + Page table (2^10) 방식의 3단계 paging으로 2^36(2^64로 표현됨) 주소 공간의 Page frame을 가리킨다.  여기서 물리 주소 공간의 크기가 늘어나는 핵심은 paging level이 증가해서가 아니라, 가리키는 Page frame의 주소 공간이 커졌기 때문이다.\nNUMA에서의 메모리 뱅크 접근 방식 변경 (p97) 책에서 기록된 커널 버전까지는 메모리 모델 중 FLATMEM, DISCONTIGMEM만을 다루고 있다. 최근에는 SPARSEMEM 메모리 모델이 사용된다. 자세한 설명은 문c블로그 글을 참고하자.\nQ. watermark와 vm_stat은 무엇인가? (p100)  watermark: 메모리 할당 상태를 알려주는 지표 vm_stat: 현재 zone의 통계 값을 기록 (다양한 정보를 기록)  watermark는 현재 가상메모리가 얼마나 할당되었는지를 간략하게 나타내서, 페이지 프레임 회수가 얼마나 급한지 결정하게 한다.\nvm_stat은 watermark의 상태 기준, 어떤 페이지 프레임을 회수할 지 결정하기 위한 통계 값을 기록하는 것으로 보인다.\n좀 더 자세한 정보는 여기를 참고하자.\nQ. Lazy Buddy에서 비트맵 대신 nr_free로 계산은 어떻게 진행하는 것인가? (p108) 현재 명확한 답을 찾지 못함, 커널 코드 리딩 시 확인 가능할 듯.\nBuddy의 free_area 계산 타이밍은 앞에서 설명한 watermark에 따라 페이지 프레임 회수가 필요함을 판단하고 계산을 시작하는 것으로 예상된다.\nQ. 커널 주소공간이 가상 주소와 물리주소가 1:1 매핑되어있다는 것이 무슨 뜻인가? (p124) 32-bit의 경우, (가상주소-3GiB) == 물리주소라고 하는데, 그렇다면 32-bit system은 물리 메모리가 무조건 1GiB 이상 있어야 한다는 것인가? (ZONE_HIGHMEM 을 제외하더라도 896MiB 이상 필요한 것으로 보임)\n개념적으로 헷갈리는데, 커널 자체가 가지는 주소공간을 의미하는것인지, 각 Task의 커널 영역 주소공간을 말하는 것인지? 그리고 각 Task의 커널 영역 주소공간인데, 물리 주소가 같다는 것은 이 영역이 모두 공유가 된다는 것인지?\n","description":"","id":30,"section":"posts","tags":["커널"],"title":"[iamroot] 2주차 스터디 회고 (리눅스 커널 내부구조)","uri":"https://devlog.jsyoo5b.net/ko/posts/linux-kernel/iamroot/week2-lki/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n12장. 배열 배열의 Go 언어에서의 특징만 확인해보자.\n 배열의 길이는 상수로 되어있다. 가변 배열은 slice를 써야 한다. [...]으로 길이를 자동 완성할 수 있다. range로 배열을 순회할 수 있다. len()으로 배열의 길이를 알 수 있다. =으로 배열을 복사할 수 있다.  range를 통한 배열 순회 Go에서 range를 통해 배열을 순회하는 방식은 python에 비해 index를 쉽게 접근할 수 있다는 장점이 있다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \u0026#34;fmt\u0026#34; func main() { var nums [5]int = [...]int{2, 3, 5, 8, 13} for i, val := range nums { fmt.Printf(\u0026#34;nums[%d] = %d\\n\u0026#34;, i, val) } fmt.Println() for i := 0; i \u0026lt; len(nums); i++ { fmt.Printf(\u0026#34;nums[%d] = %d\\n\u0026#34;, i, nums[i]) } }    \r$ ./go_array_loop_with_range nums[0] = 2 nums[1] = 3 nums[2] = 5 nums[3] = 8 nums[4] = 13 nums[0] = 2 nums[1] = 3 nums[2] = 5 nums[3] = 8 nums[4] = 13  \r  'use strict'; var containerId = JSON.parse(\"\\\"31f642c9834ac92b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  배열의 복사 C계열의 언어는 memcpy()나 배열 순회를 통해 배열을 복사해야 하지만, go에서는 =로 바로 복사가 가능하다.\n만약 복사하려는 배열의 길이가 다른 경우, copy()를 통해 복사할 수 있다. go에서는 배열 변수의 타입 검사 시 배열 길이도 비교하기 때문이다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package main import \u0026#34;fmt\u0026#34; func main() { var arrX [5]int var arr3 = [3]int{3, 4, 5} var arr5 = [5]int{10, 20, 4:50} var arr8 = [8]int{7, 6, 5, 4, 3, 2, 1, 0} fmt.Println(arrX) // go vet: Cannot use \u0026#39;arr3\u0026#39; (type [3]int) as the type [5]int \t// arrX = arr3 \tcopy(arrX[0:3], arr3[:]) fmt.Println(arrX) arrX = arr5 fmt.Println(arrX) // src length can exceed dst length \tcopy(arrX[:], arr8[1:7]) fmt.Println(arrX) }    \r$ ./go_array_copy [0 0 0 0 0] [3 4 5 0 0] [10 20 0 0 50] [6 5 4 3 2]  \r  'use strict'; var containerId = JSON.parse(\"\\\"48e72f998b647624\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  저자 강의   ","description":"","id":31,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 12장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch12/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n11장. for문 for문의 Go 언어에서의 특징만 확인해보자.\n Go에서 반복문은 for문만 제공된다. for를 while처럼 사용하기 위한 문법을 제공한다. (초기문이나 후처리 생략)  초기문, 후처리 생략 초기문과 후처리를 생략할 수 있다. 모두 생략하는 경우 사실상 while문과 다름이 없다.\n일반 for문 초기문 생략 후처리 생략 모두 생략  1 2 3  for i := 1; i \u0026lt;= 9; i++ { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, 2, i, 2 * i) }    \r1 2 3 4  i := 1 for ; i \u0026lt;= 9; i++ { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, 2, i, 2 * i) }    \r1 2 3 4  for i := 1; i \u0026lt;= 9; { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, 2, i, 2 * i) i++ }    \r1 2 3 4 5  i := 1 for i \u0026lt;= 9 { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, 2, i, 2 * i) i++ }    \r  'use strict'; var containerId = JSON.parse(\"\\\"594ecc8b6861b1cc\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  초기문과 후처리를 모두 생략한 경우는 사실상 while문이나 다름이 없다.\n레이블을 활용한 break 다중 for문에서 레이블을 선언하고, break 뒤에 레이블을 입력하면 해당 레이블에서 가장 가까운 for에서 break하는 효과가 있는데, 사실상 goto의 응용이라고 볼 수 있다.\n대부분 프로그래밍 언어에서는 goto계열의 기능 사용을 자제하라고 권고하고 있다. 만약 goto를 사용할 수 밖에 없는 경우에는 뒤쪽 레이블로만 사용할 것을 권고하고 있다. 대부분 임베디드 계열 코드나, 커널 코드를 보면 성능 향상이나 코드 크기 문제로 인해 어쩔 수 없이 goto를 사용하기 때문이다.\n그런데 여기서 사용하는 break의 활용 예시는 앞쪽 레이블을 인자로 사용하며, 해당 레이블에서 가까운 for문을 확인해야 하므로, 좋은 접근법은 아니다. 일반적으로 사용하지 말고, 어쩌다 코드 리딩 중에 발견할때 이해하는 수준으로 넘어가자.\n저자 강의   ","description":"","id":32,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 11장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch11/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n10장. switch문 switch문의 Go 언어에서의 특징만 확인해보자.\n 각 조건 단위의 종료를 위해 break를 쓸 필요가 없다. 대신 기존의 break 생략을 fallthrough 키워드로 대체한다. case에서 값 비교 뿐만 아니라 조건문 검사가 가능하다. 대상 값 선언 전에 초기문을 사용할 수 있다.  break 생략과 fallthrough go 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import \u0026#34;fmt\u0026#34; func main() { switch age := getMyAge(); age { case 9: fallthrough case 10: fallthrough case 11: fmt.Println(\u0026#34;You need to be at least 12-years-old to sign up.\u0026#34;) case 12: fallthrough case 13: fmt.Println(\u0026#34;You need parent\u0026#39;s approval to sign up.\u0026#34;) default: fmt.Println(\u0026#34;You\u0026#39;re ok to sign up.\u0026#34;) } } func getMyAge() int { return 9 }    \r$ ./go_switch_fallthrough You need to be at least 12-years-old to sign up.  \r  'use strict'; var containerId = JSON.parse(\"\\\"b1dc658a5422ac49\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  case에서 조건 검사 위에서는 fallthrough 사용 예시를 보여주기 위해 11세 이하 조건을 간략하게 9, 10, 11만 선택하게 했다. default가 14세 이상이기 때문에 입력 값이 0~8이 들어오면 버그가 발생한다. Go에서는 case에서 조건 검사가 가능하니, 이를 활용해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  package main import \u0026#34;fmt\u0026#34; func main() { switch age := getMyAge(); true { case age \u0026lt; 12: fmt.Println(\u0026#34;You need to be at least 12-years-old to sign up.\u0026#34;) case 12 \u0026lt;= age \u0026amp;\u0026amp; age \u0026lt; 14: fmt.Println(\u0026#34;You need parent\u0026#39;s approval to sign up.\u0026#34;) default: fmt.Println(\u0026#34;You\u0026#39;re ok to sign up.\u0026#34;) } } func getMyAge() int { return 8 }    \r$ ./go_switch_case_cond You need to be at least 12-years-old to sign up.  \r  'use strict'; var containerId = JSON.parse(\"\\\"c4dbf30b60d908ca\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  저자 강의   ","description":"","id":33,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 10장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch10/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n9장. if문 if문의 Go 언어에서의 특징만 확인해보자.\n문법적 특징  if 옆의 조건문에 괄호()가 필수가 아니다. One True Brace Style을 따르는 들여쓰기, 대괄호 사용 초기문을 조건문 바로 앞에서 사용할 수 있다.  if 초기문; 조건문 책에서 보면 알 수 있듯, if 옆의 조건 검사 이전에 초기문을 넣을 수 있다. 혹시 이게 else if에도 적용되는지 확인해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import \u0026#34;fmt\u0026#34; func main() { if age := getMyAge(); age \u0026gt; 14 { fmt.Println(\u0026#34;You\u0026#39;re ok to sign up.\u0026#34;) } else if approve := getParentApprove(); age \u0026gt;= 12 \u0026amp;\u0026amp; approve { fmt.Println(\u0026#34;Your parent approved you to sign up.\u0026#34;) } else if age \u0026lt; 12 { fmt.Println(\u0026#34;You need to be at least 12-years-old to sign up.\u0026#34;) } else { fmt.Println(\u0026#34;Your parent didn\u0026#39;t approved you to sign up.\u0026#34;) } } func getMyAge() int { return 12 } func getParentApprove() bool { return false }    \r$ go build $ ./go_else_if_init Your parent didn\u0026#39;t approved you to sign up.  \r  'use strict'; var containerId = JSON.parse(\"\\\"b9669c0a08424890\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  else if에도 초기문과 조건문을 같이 넣을 수 있는 것을 확인할 수 있다.\n저자 강의   ","description":"","id":34,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 9장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch09/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n8장. 상수 상수의 필요성, 상수 등은 이미 알고 있으니, Go 언어에서의 특징만 확인해보자.\n타입 있는 vs 타입 없는 타입 있는 상수는 C/C++에서 const으로 정의된 형태의 상수와 같은 효과라고 볼 수 있다.\n 상수를 사용할 때 타입 검사가 이루어진다. 메모리 위에 해당 상수가 존재한다.  타입 없는 상수는 C/C++에서 #define으로 정의된 형태의 상수와 같은 효과라고 볼 수 있다.\n 해당 상수는 문자열 값 그대로 치환된다. 메모리 위에 해당 상수가 존재하지 않을 수도 있다.  iota C/C++의 enum과 비슷한 용도로 사용하는데, 수식에 활용될 수 있어서 좀 더 간편하게 다양한 형태의 상수 정의에 활용될 수 있다.\ngo 코드 C 코드  1 2 3 4 5 6 7 8 9 10 11 12 13  package main import \u0026#34;fmt\u0026#34; const ( FLAG_ALPHA = 1 \u0026lt;\u0026lt; iota FLAG_BRABO FLAG_CHARLIE ) func main() { fmt.Println(FLAG_ALPHA, FLAG_BRABO, FLAG_CHARLIE) }    \r1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt; enum { FLAG_ALPHA = 1 \u0026lt;\u0026lt; 1, FLAG_BRABO = 1 \u0026lt;\u0026lt; 2, FLAG_CHARLIE = 1 \u0026lt;\u0026lt; 3 }; int main(void) { printf(\u0026#34;%d %d %d\\n\u0026#34;, FLAG_ALPHA, FLAG_BRABO, FLAG_CHARLIE); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"bfeaf01103c0c197\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  저자 강의   ","description":"","id":35,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 8장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch08/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n7장. 함수 함수의 필요성, 효율 등은 이미 알고 있으니, Go 언어에서의 특징만 확인해보자.\nGo는 절차형 프로그래밍 언어 일단 Go는 함수형 프로그래밍 언어가 아니다. 확인해보니 익명 함수 등의 함수형 프로그래밍에서 사용할 기법을 제공하긴 하지만, 기본적으로 절차형 프로그래밍 언어에 맞게 함수를 작성해야 한다.\n관련된 부분은 추후 언급되는 것으로 보이니 이번에는 생략하도록 하겠다.\n다중 반환 함수 이전 ch05에서 언급했듯, Go에서는 함수가 여러 값을 한 번에 반환하는 기능을 제공한다.\n또한 Go의 경우 함수의 선언/정의가 C/C++과 달리 어느 위치에나 존재해도 된다.\n예시로 나온 나누기 함수에서 특정 요소들을 수정해봤다.\n func Divide()의 위치를 뒤로 옮겨서 함수의 선언/정의 위치 관계를 확인 3개 이상의 값을 반환하도록 수정 변수명 지정 반환시에도 같은 타입의 반환 값의 타입 생략이 가능한지 확인 함수의 인자 개수가 길어질 때, 강제로 줄바꿈을 해도 아무 문제 없는지 확인  go 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import \u0026#34;fmt\u0026#34; func main() { dividend := 16 divisor := 5 quot, remain, valid := Divide(dividend, divisor) if valid { fmt.Printf(\u0026#34;The quotient of %d divided by %d is %d with a remainder of %d\u0026#34;, dividend, divisor, quot, remain) } } func Divide(dividend, divisor int) (quotient, remainder int, validity bool) { if divisor == 0 { return 0, 0, false } quotient = dividend / divisor remainder = dividend % divisor validity = true return }    \r$ ./go_func_divide The quotient of 16 divided by 5 is 3 with a remainder of 1 # 0으로 나누고, 예외처리를 하지 않도록 수정한 경우 $ ./go_func_divide_by_zero panic: runtime error: integer divide by zero goroutine 1 [running]: main.Divide(...) /Workspace/go/src/test/go_func_divide_by_zero.go:19 main.main() /Workspace/go/src/test/go_func_divide_by_zero.go:8 +0x12  \r  'use strict'; var containerId = JSON.parse(\"\\\"76c237c013c3a824\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  모두 정상적으로 돌아가는 것을 확인할 수 있다.\n그리고 나누는 값에 대한 예외처리를 하지 않으면 panic이 발생하는데, 이 부분은 추후 언급되는 것으로 보이니 생략하도록 하겠다.\n재귀 호출과 Tail call 재귀 호출에 대한 개념이 나와서 Tail Call 최적화가 됐는지 궁금했다.\n찾아보니 Go에서는 TCO가 적용되지 않았고, Go 2에서 지원하는 것을 제안했으나 거부당한 것으로 보인다.\n저자 강의   ","description":"","id":36,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 7장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch07/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n6장. 연산자 사실 연산자 대부분이 어느 프로그래밍 언어나 다 비슷해서 딱히 다룰 거리는 없어 보이는데, Go 언어에서 발견한 특이한 부분만 다뤄보려 한다.\nXOR 연산자 특이하게도 Go에서는 비트 단위의 NOT 연산이 존재하지 않는다. 대신 XOR을 단독 연산자로 사용하여 NOT 연산을 대체한다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9  package main import \u0026#34;fmt\u0026#34; func main() { var uint8Max uint8 = ^uint8(0) fmt.Printf(\u0026#34;%b\\n\u0026#34;, uint8Max) }     $ ./go_xor_not 11111111     'use strict'; var containerId = JSON.parse(\"\\\"1b0fcb1be226f5f2\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Bit clear 연산자 비트 연산에서 A ∧ ¬B(A AND NOT B)를 수행하면 A에서 B에 선택된 비트들만 0으로 clear한다. Go 언어에서는 \u0026amp;^(AND-NOT)을 연산자 단위로 취급, 제공한다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12  package main import \u0026#34;fmt\u0026#34; func main() { var flags uint8 = 0b_11001100 var clears uint8 = 0b_01100110 fmt.Printf(\u0026#34;%b\\n\u0026#34;, flags) flags \u0026amp;^= clears fmt.Printf(\u0026#34;%b\\n\u0026#34;, flags) }     $ ./go_bit_clear 11001100 10001000     'use strict'; var containerId = JSON.parse(\"\\\"7d288623749f8839\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Shift 연산자 Shift 연산이 2의 제곱에 대한 곱셈, 나눗셈 역할을 하는 것은 알고 있었다. 하지만 오른쪽 shift시 채워지는 값이 양수/음수에 따라 다르다는 것은 처음 알았다.\nGo 언어만 그런 것인지, 다른 언어에서도 당연한 것인지 확인해보자.\ngo 코드 C 코드 Java 코드 실행 결과  1 2 3 4 5 6 7 8 9 10  package main import \u0026#34;fmt\u0026#34; func main() { var num1 uint8 = 0b_11001100 fmt.Printf(\u0026#34;0x%X\\n\u0026#34;, num1 \u0026gt;\u0026gt; 2) fmt.Printf(\u0026#34;0x%X\\n\u0026#34;, uint8(int8(num1) \u0026gt;\u0026gt; 2)) }     1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt; int main(void) { u_int8_t num1 = 0xCC; printf(\u0026#34;0x%X\\n\u0026#34;, num1 \u0026gt;\u0026gt; 2); printf(\u0026#34;0x%X\\n\u0026#34;, (u_int8_t)((int8_t)num1 \u0026gt;\u0026gt; 2)); }     1 2 3 4 5 6 7 8  public class java_shr { public static void main(String[] args) { char num1 = 0xCC; System.out.printf(\u0026#34;0x%X\\n\u0026#34;, num1 \u0026gt;\u0026gt; 2); System.out.printf(\u0026#34;0x%X\\n\u0026#34;, ((byte)num1 \u0026gt;\u0026gt; 2)); } }     $ ./go_shr 0x33 0xF3 $ ./c_shr 0x33 0xF3 $ java java_shr 0x33 0xFFFFFFF3     'use strict'; var containerId = JSON.parse(\"\\\"b374e8904b12b402\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Go 언어만이 아니라 모든 언어에서 동일한 결과가 확인되었다.\nNextAfter 컴퓨터에서 실수 연산 처리에는 오차가 수반된다. 해당 문제를 해결할 수 있도록 Go에서는 다음 비트 값의 실수를 얻는 NextAfter() 함수를 제공한다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { var num1 float64 = 0.0 fmt.Printf(\u0026#34;%g\\n\u0026#34;, num1) fmt.Printf(\u0026#34;%g\\n\u0026#34;, math.Nextafter(num1, 1)); }     $ ./go_next_after 0 5e-324     'use strict'; var containerId = JSON.parse(\"\\\"d4b174be25704a43\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  저자 강의   ","description":"","id":37,"section":"posts","tags":["golang","비트 연산자"],"title":"Tucker의 Go 언어 프로그래밍 6장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch06/"},{"content":"iamroot 17기 스터디를 다행히 아직 참여하고 있다. 요새 진도 내용을 잘 못 따라가고 있기도 하고, 이전 스터디에 대한 복습이 필요한 것 같아, 내용을 정리하려 한다.\n이전보다는 리눅스 커널 소스도 직접 읽어보고, 추가적으로 공부한 지식이 있으니, 당시 있던 의문에 더 정확한 결론을 내릴 수 있을 것 같다.\n스터디 초기에는 커널의 내부 구성, 역할 등에 대한 이론을 이해하기 위해 리눅스 커널 내부 구조를 참고해 이론 스터디를 진행했다.\n1주차 진도는 Chapter.0 ~ Chapter.3 (p10 ~ p93)이었다.\nChapter.0 운영체제 이야기 Q. 디스크 블록의 크기는 (일반적으로 4KB) 무엇을 기준으로 결정되었는가? (p12) 해당 부분의 맥락으로 보았을 때, 운영체제가 디스크 사용 시 이미 지정된 단위를 기준으로 OS가 제공한다는 점이 핵심이라고 본다. 이와 다른 경우로는 실제 파일의 크기만큼만 디스크를 제공하는 경우다.\n컴퓨터 내에서는 특정 단위를 기준으로 자르는 것이 속도 관점에서 더 효율적이며, 여기 디스크 블록을 제외한 다른 자원의 단위도 특정 단위를 기준으로 자른다. 이와 비슷한 예로 페이지, 패킷, CPU time 등이 존재한다.\n굳이 4KB를 표기한 것은 일반적으로 페이지 크기가 4KB이기 때문에 언급된 것으로 보인다.\nChapter.2 리눅스 커널 구조 Q. 파일 시스템을 사용자가 일관된 인터페이스로 접근한다는 것이 무슨 뜻인가? (p38) 물리적으로 실제 데이터를 기록하는 파일 시스템은 fat32, ext4 등이 존재한다. 그리고 논리적으로 존재하는 proc, sysfs, devfs 등이 존재한다. 참고로 여기서 내가 의미하는 물리적/논리적의 구분은 기록이 비휘발성인지, 휘발성인지를 기준으로 잡고 있다. (nfs의 경우 물리적으로 실제 데이터를 기록할 때 사용되지만, 파일 시스템의 역할상으로는 논리적으로 수행된다고 볼 수도 있다.)\n이들은 모두 리눅스 파일시스템에 마운트 되어 있다.\n /boot, /bin, /etc 등은 ext4 등으로 포맷된 디스크에 실제로 존재한다. 모든 프로세스와 커널의 정보를 담은 /proc은 procfs 파일시스템으로 정의되어있다. 연결된 IO장치에 접근하기 위한 /dev는 devfs 파일시스템으로 정의되어있다.\n게다가 /dev/에는 /dev/sda, /dev/hda, /dev/ttyUSB 같은 물리적인 장치 뿐만 아니라,\n/dev/null, /dev/zero, /dev/random 같이 실제 물리적인 장치가 아니지만 자주 사용되는 논리적인 장치가 있다. 연결된 CPU, RAM, IO장치 등의 정보, 커널의 설정 값을 확인하고 변경할 수 있는 /sys는 sysfs 파일시스템으로 정의되어있다.  이들이 모두 일관된 인터페이스로 접근할 수 있는 예시를 확인해보자.\n 물리적인 디스크 내에 존재하는 파일의 읽기/쓰기는 다양한 프로그램의 소스 코드에서 확인할 수 있다.\n대표적으로 C에서 fopen(), fprintf(), fread() 등을 사용할 수 있다. 물리적인 파일이 아님에도 위와 같이 파일 읽기/쓰기를 활용하여 프로그래밍을 할 수 있다.\nC에서 fprintf(stdout, ...)을 통해 printf와 같이 콘솔로 출력할 수 있다. 커널의 설정을 실행 중 변경할 때는 굳이 텍스트 에디터 등을 사용하지 않고 shell에서 명령어를 통해 변경한다.\n(일반적으로 echo한 내용을 pipe로 write하거나, cat으로 파일의 내용을 읽는다.)\n# echo nop \u0026gt; /sys/kernel/tracing/current_tracer # 커널의 tracer를 끌 때 (nop) 사용\n# cat /sys/kernel/tracing/trace # 커널의 trace 내용을 확인하려 할 때 사용 어떤 실행 파일을 실행시키고, 그 출력 결과에는 관심이 없을 때, /dev/null로 pipe시켜 내용을 버린다.\n또한 무작위 값을 입력받기 위해 /dev/random을 사용하기도 한다.\n# time ./bench_primes 1 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 # ./bench_primes의 stdout, stderr를 출력하지 않게 한다.\n# dd if=/dev/random of=rand bs=1K count=2 # diskdump할 때 무작위 입력을 위해 /dev/random 파일을 사용한다.  위의 예시에서 확인할 수 있듯, 물리적/논리적인 파일시스템이 여러개 존재하며 모두 /(root filesystem) 아래 하위 디렉터리로 존재한다. 그리고 모든 파일들은 creat(), open(), read(), write(), close() 등의 system call을 통해 접근하게 된다.\nVFS(Virtual File System)은 물리적/논리적으로 다른 파일시스템에서의 syscall을 수행할 수 있게 호환시켜주는 역할을 한다.\n리눅스의 전신인 유닉스 시절부터 모든 것은 파일이다 철학에 따라 개발되었으므로, 운영체제가 사용자에게 제공하는 모든 기능은 파일의 형태를 이루어 제공되게 되었고, 이에 따라 가상 파일 시스템이 필수적이었던 것으로 예상된다.\nQ. 커널 컴파일 과정에서 objcopy가 하는 역할, 의미는 무엇인가? (p43) 컴파일 과정에서 생긴 vmlinux는 virtual memory가 적용된 linux 커널 실행 파일이란 뜻이다.\nobjcopy 과정을 거치기 위해 사용된 Makefile과 관련 명령어, 결과를 먼저 비교해보자.\narch/arm64/boot/Makefile Shell 확인  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  # # arch/arm64/boot/Makefile # # This file is included by the global makefile so that you can add your own # architecture-specific flags and dependencies. # # This file is subject to the terms and conditions of the GNU General Public # License. See the file \u0026#34;COPYING\u0026#34; in the main directory of this archive # for more details. # # Copyright (C) 2012, ARM Ltd. # Author: Will Deacon \u0026lt;will.deacon@arm.com\u0026gt; # # Based on the ia64 boot/Makefile. #  OBJCOPYFLAGS_Image :=-O binary -R .note -R .note.gnu.build-id -R .comment -S targets := Image Image.bz2 Image.gz Image.lz4 Image.lzma Image.lzo $(obj)/Image: vmlinux FORCE $(call if_changed,objcopy) $(obj)/Image.bz2: $(obj)/Image FORCE $(call if_changed,bzip2) $(obj)/Image.gz: $(obj)/Image FORCE $(call if_changed,gzip) $(obj)/Image.lz4: $(obj)/Image FORCE $(call if_changed,lz4) $(obj)/Image.lzma: $(obj)/Image FORCE $(call if_changed,lzma) $(obj)/Image.lzo: $(obj)/Image FORCE $(call if_changed,lzo) install: $(CONFIG_SHELL) $(srctree)/$(src)/install.sh $(KERNELRELEASE) \\ \t$(obj)/Image System.map \u0026#34;$(INSTALL_PATH)\u0026#34; zinstall: $(CONFIG_SHELL) $(srctree)/$(src)/install.sh $(KERNELRELEASE) \\ \t$(obj)/Image.gz System.map \u0026#34;$(INSTALL_PATH)\u0026#34;     $ aarch64-linux-gnu-objcopy --help Usage: aarch64-linux-gnu-objcopy [option(s)] in-file [out-file] Copies a binary file, possibly transforming it in the process The options are: -I --input-target \u0026lt;bfdname\u0026gt; Assume input file is in format \u0026lt;bfdname\u0026gt; -O --output-target \u0026lt;bfdname\u0026gt; Create an output file in format \u0026lt;bfdname\u0026gt; : -j --only-section \u0026lt;name\u0026gt;\tOnly copy section \u0026lt;name\u0026gt; into the output --add-gnu-debuglink=\u0026lt;file\u0026gt; Add section .gnu_debuglink linking to \u0026lt;file\u0026gt; -R --remove-section \u0026lt;name\u0026gt; Remove section \u0026lt;name\u0026gt; from the output --remove-relocations \u0026lt;name\u0026gt; Remove relocations from section \u0026lt;name\u0026gt; -S --strip-all\tRemove all symbol and relocation information : -V --version\tDisplay this program\u0026#39;s version number -h --help\tDisplay this output --info\tList object formats \u0026amp; architectures supported aarch64-linux-gnu-objcopy: supported targets: elf64-littleaarch64 elf64-bigaarch64 elf32-littleaarch64 elf32-bigaarch64 elf32-littlearm elf32-bigarm elf64-little elf64-big elf32-little elf32-big srec symbolsrec verilog tekhex binary ihex plugin Report bugs to \u0026lt;http://www.sourceware.org/bugzilla/\u0026gt; # 커널 컴파일을 통해 얻은 리눅스 커널 실행파일 vmlinux가 어떤 파일인지 확인해보자. $ file vmlinux vmlinux: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), statically linked, BuildID[sha1]=33523a2bcbaf40ff140171d6169def75f68aadcd, with debug_info, not stripped # 보다시피 ELF 형식의 파일이다. # 커널 컴파일 과정에서 objcopy로 생성된 Image를 확인해보자. $ file arch/arm64/boot/Image arch/arm64/boot/Image: MS-DOS executable PE32+ executable (EFI application) Aarch64 (stripped to external PDB), for MS Windows # 현재 커널 config에 EFI 지원이 있어, MS-DOS 실행파일의 결과물로 나타난다. # arch/arm64/boot/Makefile 내에 있는 objcopy 플래그를 그대로 사용하여 Image를 직접 생성해보자. $ aarch64-linux-gnu-objcopy -O binary -R .note -R .note.gnu.build-id -R .comment -S vmlinux Image # 직접 명령어로 생성한 Image와 커널 컴파일의 결과로 나온 Image와 비교해보자. $ diff Image arch/arm64/boot/Image # 동일한 바이너리 파일이므로 특별한 결과가 출력되지 않는다.     'use strict'; var containerId = JSON.parse(\"\\\"04d3fb6aaf774710\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  실행된 objcopy 명령의 옵션을 확인해보면, binary 형식으로 obj(컴파일 과정에서 설명하는 그 목적 코드)들을 복사하는데, 이 때 .note, .comment 등의 섹션은 완전히 지우고, strip을 하게 되는데, 이 과정에서 실제 실행에 불필요한 모든 정보를 지우게 된다.\n즉 커널을 실행하기 위해 필요한 순수한 기계어만 남기는 과정이라 볼 수 있다.\nChapter.3 태스크 관리 Q. execl()을 통해 기존 프로세스의 수행 이미지가 바뀌는 과정에서 내부적으로 do_fork()가 일어나는 것이 아닐까? (p57) execl() 함수가 호출될 때, struct task_struct의 관계(PID, 부모 task 등)는 그대로 유지되지만 새로운 이미지를 실행하기 위한 부분(.text, .data, .stack, \u0026hellip;)만 변경된다.\n직접 예시로 나온 코드를 수정해서 확실한 관계를 확인해보자. 어떤 실행 파일이 출력을 하고 있는 것인지, PID가 몇 번인지 매번 확인할 수 있게 수정했다.\nfork_exec.c fork.c 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(int argc, char* argv[]) { pid_t pid; int exit_status; printf(\u0026#34;%s (%d): Before fork\\n\u0026#34;, argv[0], getpid()); if((pid=fork())\u0026lt;0){ perror(\u0026#34;fork error\u0026#34;); exit(1); } else if(pid == 0) { printf(\u0026#34;%s (%d): Before exec\\n\u0026#34;, argv[0], getpid()); execl(\u0026#34;./fork\u0026#34;, \u0026#34;fork\u0026#34;, (char *)0); printf(\u0026#34;%s (%d): After exec\\n\u0026#34;, argv[0], getpid()); } else { pid = wait(\u0026amp;exit_status); } printf(\u0026#34;%s (%d): Parent\\n\u0026#34;, argv[0], getpid()); return 0; }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int g = 2; int main(int argc, char* argv[]) { pid_t pid; int l = 3; int exit_status; printf(\u0026#34;%s (%d): Parent g=%d, l=%d\\n\u0026#34;, argv[0], getpid(), g, l); if((pid=fork())\u0026lt;0){ perror(\u0026#34;fork error\u0026#34;); exit(1); } else if(pid == 0) { g++; l++; } else { pid = wait(\u0026amp;exit_status); } printf(\u0026#34;%s (%d): g=%d, l=%d\\n\u0026#34;, argv[0], getpid(), g, l); return 0; }     # 각 소스 코드들을 컴파일한다. $ gcc fork.c -o fork $ gcc fork_exec.c -o fork_exec $ ./fork_exec ./fork_exec (3319361): Before fork ./fork_exec (3319362): Before exec fork (3319362): Parent g=2, l=3 fork (3319363): g=3, l=4 fork (3319362): g=2, l=3 ./fork_exec (3319361): Parent     'use strict'; var containerId = JSON.parse(\"\\\"5981cc1365697527\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }   fork_exec에서 fork() 함수를 호출하기 전의 프로세스(3319361)애서 \u0026ldquo;Before fork\u0026quot;를 출력한다. fork_exec에서 fork() 함수가 호출되었고, 그 중 자식 프로세스(3319362)에서 \u0026ldquo;Before exec\u0026quot;를 출력한다. fork_exec의 자식 프로세스(3319362)가 execl() 함수를 통해 다른 실행파일인 fork를 실행한다.\n(새로 실행시키는 것이 아닌, 실행 이미지를 교체한다.) 여전히 같은 프로세스 ID(3319362)를 가지는 것을 확인할 수 있다. 교체된 fork 프로세스(3319362)가 fork() 함수를 호출했고, 그 새로운 자식인 fork 프로세스 (3319363)가 생성되었다. 교체된 fork 프로세스(3319362)는 자신의 자식 프로세스 (3319363)이 종료되는 것을 기다린 뒤 출력하고 종료된다. 교체된 fork 프로세스(3319362)의 부모 프로세스 (3319361)는 자식 프로세스가 종료된 것을 확인한 뒤 \u0026ldquo;Parent\u0026quot;를 출력한다. 교체된 fork 프로세스(3319362)는 이미지가 fork_exec에서 fork로 교체되었기 때문에 \u0026ldquo;After exec\u0026quot;는 출력되지 않는다.  이 결과를 통해 이미지가 바뀌는 과정에서 do_fork()는 호출되지 않는 것을 확인할 수 있다. (더 정확한 실험을 하려면 trace를 해서 do_fork()가 호출되지 않았음을 증명하면 되지만, 일단 do_fork()의 결과로 PID가 바뀐다는 것을 통해 증명했다.)\n사실 이 질문이 생긴 원인은 하필 execl()로 교체하는 프로그램이 fork()를 호출하는 프로그램이라 헷갈리기 쉬웠던 것 같다.\nQ. 리눅스가 지원한다는 Linux exec 도메인, BSD나 SVR4 exec 도메인은 무슨 뜻인가? (p69) 해당 내용은 Understanding the linux kernel 내용을 참고하여 설명하도록 하겠다.\n리눅스는 다른 운영체제 용으로 컴파일 된 실행파일을 실행해 줄 수도 있다. (단, 같은 아키텍쳐라서 동일한 기계어를 실행할 수 있을 때를 기준으로 한다.)\n여기서 다른 운영체제라고 무조건 실행할 수 있는 것이 아니다.\n 에뮬레이션 된 실행: POSIX 호환되지 않는 시스템 콜이 있을 경우, 이에 대한 에뮬레이션을 지원해야 한다. Native 실행: 모든 시스템 콜이 POSIX 호환되어, 그대로 실행할 수 있다.  MS-DOS나 Windows의 경우, API 자체가 리눅스와 다르다. (당연히 UNIX를 뿌리로 두지 않기 때문에) 그래서 이를 에뮬레이션 하기 위해 Wine이나 DOSemu 등을 통해 API를 리눅스 환경에 맞게 변환해 주는 작업이 필요하다. (ex. WinAPI -\u0026gt; Syscall)\npersonality에 대한 설명을 읽어보면 해당 실행 파일이 (다른 운영체제 용으로 컴파일된) 커널의 기능을 얼마나 지원할 수 있는지에 대한 flag 형식으로 표현되는 것을 확인할 수 있다.\n이 부분은 리눅스 커널 분석 과정에서 중요한 부분이라기 보단, 이런 기능도 리눅스 커널에서 제공된다라고 하고 넘어갈 수 있을 것 같다. (해당 부분에 관심 있는 사람이라면 모를까)\nQ. n개의 CPU를 갖는 시스템에서는 임의의 시점에 최대 n개의 task라는 것이 Physical core인가? Logical processor인가? (p70) 하드웨어 제조사들마다 다른 용어를 쓰는 바람에 조금 헷갈릴 수도 있는데, 아래와 같이 정의해보겠다. (좀 더 정확한 정의는 추후 시도해 보도록 하겠다.)\n Physical core: 물리적으로 구별되는 CPU,\n일반적으로 제품 소개에 core라고 표기됨 (ex. Dual core -\u0026gt; Physical core 2개) Logical processor: 논리적으로 구별되는 CPU, 하이퍼쓰레드나 SMT 기술로 구현된 CPU 단위,\n최근 제품들의 경우 1개 physical core 당 2개의 logical processor가 지원되며, 전체 개수는 physical core의 개수보다 작을 수 없다.\n일반적으로 제품 소개에 thread라고 표기됨  추후 책에서 runqueue를 다룰 때, Logical processor를 뜻하는 것으로 예측된다. (p77)\n리눅스에서 $ cat /proc/cpuinfo를 해보면 Logical processor의 개수만큼 나타난다. 즉 리눅스 커널에서는 Logical processor를 CPU 단위로 취급하는 것으로 보인다.\nQ. EXIT_ZOMBIE 상태가 유지되는 경우(시스템에 불필요한 부하를 주는 상태)는 어떤 경우인가? (p71) 일반적인 프로세스의 경우, 부모 프로세스가 wait() 함수를 호출하여 자식 프로세스의 상태가 EXIT_DEAD로 바뀌게 허가해준다. 이 개념대로라면 부모가 wait() 함수를 호출하지 못하고 죽으면(ex. SEGFAULT) 자식 프로세스는 좀비 프로세스 상태가 계속 유지되는 것이라 생각하고 있었다.\n하지만 wait() 시스템 콜의 설명에서 아래와 같은 설명이 있다. (man 2 wait에서 NOTES 부분을 확인해 보면 자세한 설명이 나와있다.)\n A child that terminates, but has not been waited for becomes a \u0026ldquo;zombie\u0026rdquo;. The kernel maintains a minimal set of information about the zombie process (PID, termination status, resource usage information) in order to allow the parent to later perform a wait to obtain information about the child. As long as a zombie is not removed from the system via a wait, it will consume a slot in the kernel process table, and if this table fills, it will not be possible to create further processes. If a parent process terminates, then its \u0026ldquo;zombie\u0026rdquo; children (if any) are adopted by init(1), (or by the nearest \u0026ldquo;subreaper\u0026rdquo; process as defined through the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation); init(1) automatically performs a wait to remove the zombies.\n 해석하면 아래와 같다.\n 자식 프로세스가 종료되었지만 부모 프로세스로부터 wait을 호출받지 못하면 좀비 프로세스가 된다. 커널은 좀비 프로세스에 대한 최소한의 정보(PID, 종료 상태, 자원 사용 정보)를 유지하여, 추후 부모 프로세스가 나중에 wait을 했을 때 이 정보들을 얻을 수 있게 한다. 좀비 프로세스가 wait으로 제거되지 않는 상태로 유지된다면, 커널의 프로세스 테이블의 한 칸을 계속 소모하고 있는 것이며, 해당 테이블이 꽉 찰 경우 추후 새로운 프로세스를 생성할 수 없게 된다. 만약 부모 프로세스가 종료되면, 그 프로세스에 딸려 있던 좀비 자식 프로세스들은 init 프로세스에게 입양된다. (혹은 prctl 시스템콜의 PR_SET_CHILD_SUBREAPER 동작을 수행한 가장 가까운 subreaper에게 입양된다.) init은 자동으로 wait을 수행하여 좀비 프로세스들을 삭제한다.\n 좀비 프로세스가 되는 데 가장 중요한 것은 wait()의 호출이 이루어 지지 않는 것이었다.\n직접 내가 생각했던 방법과, wait의 설명에서 한 내용을 실험해보자.\nparent_segfault.c no_wait.c parent_segfault 실행 no_wait 실행  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt; int main(void) { pid_t pid; int status; if ((pid = fork()) \u0026lt; 0) { perror(\u0026#34;fork\u0026#34;); exit(1); } if (pid == 0) { /* Child waits 50 second and terminate */ sleep(50); exit(0); } else { /* Parent will be terminated before the child\u0026#39;s termination */ char *msg = \u0026#34;Test\u0026#34;; msg[0] = \u0026#39;S\u0026#39;; /* triggering segfault */ } return 0; }   #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt; int main(void) { pid_t pid; int status; if ((pid = fork()) \u0026lt; 0) { perror(\u0026#34;fork\u0026#34;); exit(1); } /* Child */ if (pid == 0) { /* Child terminate immediately */ exit(0); } else { /* Parent waits 50 second and terminate */ sleep(50); } return 0; }   # 실행파일로 컴파일한다. $ gcc parent_segfault.c -o parent_segfault # parent_segfault 실행한다. (ps로 결과를 확인해야 하므로 \u0026amp;을 붙여 백그라운드 실행시킨다.) $ ./parent_segfault \u0026amp; [1] 1244753 [1] + 1244753 segmentation fault (core dumped) ./parent_segfault # 바로 ps 명령으로 ./parent_segfault의 자식 프로세스 상태를 조회해 보자. $ ps -ef | grep parent_segfault jsyoo5b 1244755 1 0 13:40 pts/2 00:00:00 ./parent_segfault jsyoo5b 1245371 4116883 0 13:40 pts/2 00:00:00 grep ... # grep 명령의 process # 50초 뒤에 다시 조회하여 zombie상태인지 확인해보자. $ ps -ef | grep parent_segfault jsyoo5b 1247619 4116883 0 13:42 pts/2 00:00:00 grep ... # grep 명령의 process # 아무 결과도 나타나지 않는다.   # 실행파일로 컴파일한다. $ gcc no_wait.c -o no_wait # no_wait 실행한다. (ps로 결과를 확인해야 하므로 \u0026amp;을 붙여 백그라운드 실행시킨다.) $ ./no_wait \u0026amp; [1] 1257718 # 바로 ps 명령으로 ./no_wait의 자식 프로세스 상태를 조회해 보자. $ ps -ef | grep no_wait jsyoo5b 1257718 4116883 0 13:47 pts/2 00:00:00 ./no_wait jsyoo5b 1257720 1257718 0 13:47 pts/2 00:00:00 [no_wait] \u0026lt;defunct\u0026gt; jsyoo5b 1257956 4116883 0 13:47 pts/2 00:00:00 grep ... # grep 명령의 process # 50초 뒤에 다시 조회하여 zombie상태인지 확인해보자. $ ps -ef | grep no_wait jsyoo5b 1264140 4116883 0 13:51 pts/2 00:00:00 grep ... # grep 명령의 process # 아무 결과도 나타나지 않는다.     'use strict'; var containerId = JSON.parse(\"\\\"37c794b3161c6f75\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위의 실험에서 parent_segfault는 부모 프로세스가 강제 종료될 수 있도록 강제로 SEGFAULT를 일으켰다. 부모 프로세스가 강제 종료되면 부모 프로세스가 1(init 프로세스)으로 변경된 것을 볼 수 있다.\n반대로 자식이 먼저 종료되도록 부모가 wait()을 호출하지 않는 경우, 자식 프로세스는 \u0026lt;defunct\u0026gt; 상태가 되는데, 이 상태가 좀비 프로세스 상태임을 의미한다. 자식 프로세스는 50초동안 부모 프로세스에서 wait()를 호출하길 기다리며 좀비 프로세스 상태였지만, 부모 프로세스는 그냥 종료되었고, 아마 1(init 프로세스)에게 입양되어, wait() 처리를 통해 종료되었을 것이다.\nQ. SIGKILL이 발생하는 경우는 어떤 경우인가? (p72) 스터디 당시 Ctrl+C로 발생시키는 것이 아니냐고 했는데, Ctrl+C는 SIGKILL이 아니라 SIGINT(Interrupt Signal)다. 아마 Ctrl+C를 통해 실행 중이던 프로세스를 종료시키기 때문에 그런 것으로 생각할텐데, 정확하게 설명하자면 SIGINT의 기본 핸들러가 해당 프로세스의 종료기 때문이다.\nSIGINT의 핸들러를 직접 정의하는 예제를 간단하게 짜 보았다. 참고로 signal()을 사용하는 것은 좋지 않으며, sigaction()을 사용하는 것이 좋다고 알고 있으나, 이 부분은 추후 제대로 공부하고 글을 쓰도록 하겠다. (게다가 간단한 예제라서 공을 들이지 않은 것도 있다.)\nsigint_hndl.c 실행 결과  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;signal.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #define SIGINT_THRESHOLD 3  void sigint_hndl(int signo) { static int sigint_cnt = 0; if (signo == SIGINT) { sigint_cnt++; if (sigint_cnt \u0026lt; SIGINT_THRESHOLD) { printf(\u0026#34; Send %d more SIGINT to terminate\\n\u0026#34;, (SIGINT_THRESHOLD - sigint_cnt)); } else { exit(0); } } } int main(void) { signal(SIGINT, sigint_hndl); while(1) sleep(1); return 0; }   # 실행파일로 컴파일한다. $ gcc sigint_hndl.c -o sigint_hndl # sigint_hndl을 실행하고 Ctrl+C를 3번 입력하여 종료시킨다. $ ./sigint_hndl ^C Send 2 more SIGINT to terminate ^C Send 1 more SIGINT to terminate ^C # Ctrl+C를 3번째 입력받고 나서야 종료된다. (signal handler에 작성한 대로 동작함)     'use strict'; var containerId = JSON.parse(\"\\\"48efb7e60e3af1e1\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  다시 본론으로 돌아와서, SIGKILL은 명시적으로 호출했을 때만 발생한다. 대표적인 경우로 kill -9 $PID와 같은 명령어를 통해 종료시키는 방법이 있다. (여기서 9는 SIGKILL의 portable number다.)\n프로세스를 종료시키는 시그널 종류는 SIGTERM, SIGINT, SIGQUIT, SIGKILL, SIGHUP이 존재한다.\n SIGTERM은 종료 요청으로, kill 명령이 보내는 기본 시그널이다.\nGUI에서 종료버튼을 누르거나, Task Manager에서 종료 요청을 보낼 때와 비슷하다고 볼 수 있다.\n문서 작업 프로그램의 경우 종료 요청 시 저장하겠냐고 다시 물어보는 동작을 하듯, 사용자가 작성한 핸들러를 동작시킬 수 있다. SIGINT는 위에서 설명했듯 Program interrupt를 보내는 것이다. INTR 글자의 가장 일반적인 예가 우리가 아는 Ctrl+C이다. SIGQUIT는 SIGINT와 비슷하지만 다른 QUIT 글자 (Ctrl+\\)로 발생되며, core dump를 발생시킨다.\n사용자가 직접 프로그램 에러를 발생시키며 종료시키는 경우라 볼 수 있다. (다른 예시로는 SEGFAULT 등의 오류로 인해 프로그램에서 에러 시그널을 발생하는 경우가 있다.) SIGHUP는 hang-up 신호로, 사용자 터미널의 연결이 끊긴 경우 이를 알려 동작중이던 프로세스들이 종료되라고 알리는 것이다. (네트워크 연결 끊김 등)  위 예시된 시그널등과 달리 SIGKILL은 해당 프로세스의 의사와 관계 없이 (핸들러를 등록하지 못하고) 강제 종료할 때 사용된다.\n시스템을 종료시키는 shutdown의 경우, SIGTERM과 SIGKILL의 용도를 확실히 알 수 있게 해 준다.\n 먼저 모든 프로세스에 SIGTERM을 보내, 자발적으로 종료되길 기다린다. 혹시나 SIGTERM에도 종료되지 않은 프로세스들을 강제 종료시키기 위해 SIGKILL을 보낸다.  일부 시스템 관리 프로그램의 경우, lock을 잡고 있거나, db를 수정하고 있는 데 SIGKILL만으로 종료하면 프로그램의 상태가 이상해진 상태로 종료되므로, 기본적으로는 SIGTERM으로 종료시키는 것이 적합하다.\n","description":"","id":38,"section":"posts","tags":["커널"],"title":"[iamroot] 1주차 스터디 회고 (리눅스 커널 내부구조)","uri":"https://devlog.jsyoo5b.net/ko/posts/linux-kernel/iamroot/week1-lki/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n5장. fmt 패키지를 이용한 텍스트 입출력 GUI나 웹 서버 등 다른 interface를 사용하는 app이 아니라면 기본적으로 console로 입출력이 이루어진다. go에서는 fmt 패키지를 통해 콘솔의 입출력을 처리한다.\n줄바꿈 (CR, LF) fmt.Println() 함수는 인자로 들어온 내용을 출력하고, 이후 줄바꿈을 진행한다. 이 때 줄바꿈에 대한 ASCII 코드는 플랫폼에 따라 다르다. 그런데 go에서는 compile시 알아서 해당 플랫폼에 대한 줄바꿈 ASCII 코드를 사용한다. go에서는 무조건 LF만 출력한다.\n줄바꿈에 대한 ASCII 코드는 LF(Line Feed, 0x0A), CR(Carrige Return, 0x0D)가 있는데, 이는 타자기 시절의 줄바꿈 행동과 관계가 있다.\nLF는 타자기의 커서 위치에서 줄(세로 방향)을 하나 아래로 내리는 행위를 의미했으며, CR은 타자기의 커서 위치를 해당 줄의 시작 부분으로 옮기는(가로 방향) 행위를 의미한다.\nCR LF를 둘 다 쓰는 유명한 예외인 Windows에서 해당 문제에 대한 이슈가 제기되었다. 해당 이슈를 확인해 본 결과 CR LF 출력 문제를 지원하지 않겠다고 했다.\n하지만 실제 Windows에서 실행해보면, 무조건 CR LF를 같이 출력하는 것을 확인할 수 있다.\nGo 코드 실행 결과  1 2 3 4 5 6 7 8  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Println\u0026#34;) fmt.Print(\u0026#34;Print with \\\\n\\n\u0026#34;) }     PS \u0026gt; .\\go_newline.exe | xxd 00000000: 5072 696e 746c 6e0d 0a50 7269 6e74 2077 Println..Print w 00000010: 6974 6820 5c6e 0d0a ith \\n..     'use strict'; var containerId = JSON.parse(\"\\\"14f348296760e30b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  보다시피 Println()을 호출할 때나, Print()에서 \\n을 호출할 때나 무조건 CR LF를 출력하는 것을 확인할 수 있다.\nGo 언어에서 구현된 Println()의 내역을 확인해보면 그냥 \\n만 마지막에 출력하는 것으로 확인할 수 있다.\n즉 go에서는 무조건 줄바꿈에 LF만 사용하는 것을 확인할 수 있다. 아마 CR LF 문제는 Windows에서 처리하도록 변경된 것으로 보인다. 해당 부분에 대한 조사가 필요할 것 같다.\nPrintf의 formatter Printf()는 각 변수를 형식에 맞춰 출력시키는 함수다. 그리고 해당 형식을 표현하는 formatter 종류는 다양하게 존재한다.\ngo는 강 타입 언어로, 명시적으로 타입 변환을 해야하는데, Printf()의 인자로 들어가는 경우에는 타입을 강제로 지정하지 않는다. (interface를 인자로 받는데, 이게 타입 검사를 강제화 하지 않는 것으로 보인다.) 억지로 type에 맞지 않는 formatter를 사용해보자.\nGo 코드 실행 결과  1 2 3 4 5 6 7 8 9  package main import \u0026#34;fmt\u0026#34; func main() { var num int = 1010; fmt.Printf(\u0026#34;%d %t %f %s\u0026#34;, num, num, num, num); }     $ ./go_printf 1010 %!t(int=1010) %!f(int=1010) %!s(int=1010) # 빌드 과정에서 에러로 취급되지 않은 경고문을 확인 $ go vet go_printf.go # command-line-arguments ./go_printf.go:8:2: Printf format %t has arg num of wrong type int     'use strict'; var containerId = JSON.parse(\"\\\"d8688fad50d1668a\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  자체적으로 잘못된 formatter를 사용했음을 Printf()의 결과로 알린다.\n입력 scan 과정의 오류 fmt.Scan() 등의 함수를 통해 입력을 받을 수 있는데, 여기도 C처럼 address를 전달한다. Call by address 방식만 지원되는 것으로 보인다.\nScan() 과정에서 원하는 타입대로 입력하지 않으면 오류가 발생한다. 이때 Error 처리를 stderr로 출력하지 않고, 해당 함수의 인자로 에러 알림을 변수로 받을 수 있다.\nGo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \u0026#34;fmt\u0026#34; func main() { var num1 int var num2 int fmt.Print(\u0026#34;Enter 2 numbers: \u0026#34;) n, err := fmt.Scanln(\u0026amp;num1, \u0026amp;num2) if err != nil { fmt.Println(err) } else { fmt.Printf(\u0026#34;%d numbers entered, num1: %d, num2: %d\u0026#34;, n, num1, num2) } }     $ ./go_scan Enter 2 numbers: 3 4 2 numbers entered, num1: 3, num2: 4 # 일부러 잘못된 값을 입력해보자. $ ./go_scan Enter 2 numbers: hello expected integer     'use strict'; var containerId = JSON.parse(\"\\\"16188fc95ab2c2b6\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  추가적으로 fmt.Scanln()에서 return값을 할당하는 과정에서 볼 수 있듯, go에서는 함수에서 여러 값을 반환할 수 있는 것으로 보인다.\n사용되지 않는 변수에 대한 오류 go에서는 선언하고 사용되지 않는 (reference되지 않는) 변수를 허용하지 않는다. fmt.Scanln()과 같이 여러 값을 반환하는 함수에서 일부 값만 사용하고, 나머지를 버리기 위해서는 _(blank identifier)를 사용하면 된다.\nGo 코드 (unref.go) Go 코드 (blank.go) 빌드 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \u0026#34;fmt\u0026#34; func main() { var num1 int var num2 int fmt.Print(\u0026#34;Enter 2 numbers: \u0026#34;) n, err := fmt.Scanln(\u0026amp;num1, \u0026amp;num2) if err != nil { fmt.Println(err) } else { fmt.Printf(\u0026#34;num1: %d, num2: %d\u0026#34;, num1, num2) } }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \u0026#34;fmt\u0026#34; func main() { var num1 int var num2 int fmt.Print(\u0026#34;Enter 2 numbers: \u0026#34;) _, err := fmt.Scanln(\u0026amp;num1, \u0026amp;num2) if err != nil { fmt.Println(err) } else { fmt.Printf(\u0026#34;num1: %d, num2: %d\u0026#34;, num1, num2) } }     # unref.go를 빌드 $ go build # unref ./unref.go:10:2: n declared but not used # blank.go를 빌드 (문제 없음) $ go build     'use strict'; var containerId = JSON.parse(\"\\\"9138c09454556b59\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  저자 강의   ","description":"","id":39,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 5장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch05/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n4장. 변수 일단 이 책에서는 내가 생각하는 컴퓨터공학의 핵심이라 생각하는 타입의 개념에 대해 충실히 설명하고 있다.\n예를 들어 1과 1.0은 다르고, 숫자 1234와 전화번호 1234가 다른 것 처럼 적절한 타입으로 표현하는 것(프로그래머의 추상화 관점)과, 이를 통해 컴퓨터가 메모리의 값을 적절한 방식으로 해석하게 됨(하드웨어 구현 관점)을 설명하고 있다.\nint의 크기 go언어에서는 int의 크기가 시스템의 크기에 따라 결정된다고 한다. 책에 나온 정의가 약간 부정확해 보여서 직접 실험해봤다. 컴파일 환경의 비트에 따라 달라진다가 좀 더 정확한 표현인 것 같다.\ngo 코드 32bit 실행 64bit 실행  1 2 3 4 5 6 7 8 9  package main import \u0026#34;fmt\u0026#34; func main() { var intMax uint = ^uint(0) fmt.Println(intMax) }     # 명시적으로 x86 32bit로 컴파일 하려면 앞에 환경변수를 변경한다. $ GOARCH=386 GO386=softfloat go build # 32bit 실행파일 확인 $ file go_intmax go_intmax: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, Go BuildID=whcf5YULQAGTt7WJw_Bi/_S-7XiOp74YDhMdaR-XW/kAzTzAYBcTiwIMmaKgmI/NcdUi1SXls08b19JVtIc, not stripped $ ./go_intmax 4294967295   # 명시적으로 x86 64bit로 컴파일 하려면 앞에 환경변수를 변경한다. $ GOARCH=amd64 go build # 64bit 실행파일 확인 $ file go_intmax go_intmax: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=WUYerYNB9m74ls69fi0P/-XlxGK553eA5t4u4wzct/aa8a3tMsB8mwewlWCl3k/P0xI5AHDRcm1sthL6TCV, not stripped $ ./go_intmax 18446744073709551615     'use strict'; var containerId = JSON.parse(\"\\\"44f40410b25496ae\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  참고로 C의 경우 int 크기의 정의가 해당 프로세서가 가장 효율적으로 사용할 수 있는 크기로 정의되어 있다.\n일반적으로 32bit 환경이거나 64bit 환경이거나 모두 32bit를 사용하고 있으며 (과거 16bit 시절에는 16bit를 사용했음.) 실질적인 32~64의 적용은 long type에 적용되거나, pointer의 크기에만 적용된다.\n실제 C에서 적용되는 자료형 크기 정보는 C language data type model를 참고하기 바란다.\nstring, rune go에서는 모든 문자열을 UTF-8로 인코딩해서 나타내며, 모든 문자를 표현하기 위한 타입을 rune 타입이라 정의했다. rune이 int32의 별칭이라는 것으로 보아, UCS를 모두 표현하는 것으로 보인다.\n실제 문자열이 utf-8로 인코딩 되어 있는지 확인해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import \u0026#34;fmt\u0026#34; func main() { var multilingual string = \u0026#34;English와 한글이 섞인\u0026#34; fmt.Println(multilingual) multiLingRunes := []rune(multilingual) multiLingBytes := []byte(multilingual) fmt.Println(multiLingRunes) fmt.Println(multiLingBytes) }     $ ./go_multilingual English와 한글이 섞인 [69 110 103 108 105 115 104 50752 32 54620 44544 51060 32 49438 51064] [69 110 103 108 105 115 104 236 153 128 32 237 149 156 234 184 128 236 157 180 32 236 132 158 236 157 184]     'use strict'; var containerId = JSON.parse(\"\\\"a14f54c504dfd494\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  var의 명시적 표기 필요성 go에서 변수 선언에는 var 키워드를 사용하는데, := 할당자를 통해 묵시적으로 변수 선언이 가능하다. 묵시적인 표기로도 선언이 가능한데 왜 굳이 var라는 키워드가 필요할까?\n혹시 kotlin처럼 var와 val의 차이가 있는 건가 싶었는데, go에서는 const 키워드로 상수를 표현한다고 한다.\n굳이 var 키워드가 꼭 필요한가 싶어서 확인해보니, 전역변수 선언에서는 묵시적 선언이 불가능 한 것으로 보인다.\ngo 코드 빌드 결과  1 2 3 4 5 6 7 8 9 10 11  package main import \u0026#34;fmt\u0026#34; var testVar1 int = 10 testVar2 := 10 func main() { fmt.Println(testVar1) fmt.Println(testVar2) }     $ go build # go_var ./go_var.go:6:1: syntax error: non-declaration statement outside function body     'use strict'; var containerId = JSON.parse(\"\\\"4a2c4e4f0e184cb0\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  저자 강의   ","description":"","id":40,"section":"posts","tags":["golang","프로그래밍 철학"],"title":"Tucker의 Go 언어 프로그래밍 4장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch04/"},{"content":"리눅스 커널 소스에 첫 기여를 한 기념으로 어떻게 기여하게 되었는지 그 과정을 공유한다. 사실 코드를 수정한 것도 아니고, 고작 1줄에 불과하기때문에 그렇게 대단한 것은 아니라고 생각하지만, 그 기여를 위해 어떤 판단을 했고, 어떻게 자료 조사를 했는지에 대한 경험을 공유하고자 한다.\n어떻게 기여할 만한 것을 찾았는가? 리눅스 커널에서는 관련 문서를 Documentation/ 에서 관리하고 있다. 보통 *.rst나 *.txt로 각 주제에 대한 글을 작성해 놓은 상태다.\n물론 해당 문서 파일들을 더 효과적인 방식으로 변환하는 기능도 제공한다. 예를 들어 make pdfdocs, make htmldocs 등이 있다. 말 그대로 pdf문서로 변환해주거나, HTML로 변환하여 웹에서 제공할 수 있게 해준다.\n현재 iamroot 커널 스터디를 진행하고 있는데, 추후 개념 관련 정리를 rst로 작성하여 웹으로 배포하면 좋겠다는 생각이 들어서 htmldocs로 변환하는 부분을 실험해봤다. 그런데 오류 메시지만으로는 해결할 수 없는 상태가 발생했고, 이를 수정하는 과정을 기여할 수 있었다.\n커널의 make htmldocs 커널에서 문서를 HTML로 변환할 때 sphinx라는 도구를 사용한다.\nhtmldocs 빌드 시도  $ make htmldocs Documentation/Makefile:30: The \u0026#39;sphinx-build\u0026#39; command was not found. Make sure you have Sphinx installed and in PATH, or set the SPHINXBUILD make variable to point to the full path of the \u0026#39;sphinx-build\u0026#39; executable. Detected OS: Ubuntu 20.04.1 LTS. Warning: better to also install \u0026#34;convert\u0026#34;. Warning: better to also install \u0026#34;dot\u0026#34;. Warning: better to also install \u0026#34;dvipng\u0026#34;. Warning: better to also install \u0026#34;fonts-noto-cjk\u0026#34;. Warning: better to also install \u0026#34;latexmk\u0026#34;. Warning: better to also install \u0026#34;rsvg-convert\u0026#34;. You should run: sudo apt-get install imagemagick graphviz dvipng fonts-noto-cjk latexmk librsvg2-bin Warning: It is recommended at least Sphinx version 1.7.9. If you want pdf, you need at least 2.4.4. Note: It is recommended at least Sphinx version 2.4.4 if you need PDF support. Can\u0026#39;t build as 1 mandatory dependency is missing at ./scripts/sphinx-pre-install line 853. /usr/bin/python3 -m venv sphinx_2.4.4 . sphinx_2.4.4/bin/activate pip install -r ./Documentation/sphinx/requirements.txt If you want to exit the virtualenv, you can use: deactivate make[1]: *** [Documentation/Makefile:32: htmldocs] Error 2 make: *** [Makefile:1658: htmldocs] Error 2     'use strict'; var containerId = JSON.parse(\"\\\"29e16958c5645352\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  만약 sphinx가 설치되어 있지 않다면 위와 같이 에러문이 출력된다. 각 OS에 따라 sphinx, 기타 관련 추천 패키지를 설치하기 위한 명령을 알려준다. 참고로 sphinx는 python 패키지로 설치되기 때문에 효과적인 관리를 위해 virtualenv를 생성하고, 그 위에서 pip를 통해 문서 생성에 필요한 패키지를 자동으로 설치시킨다. 필요한 패키지는 requirements.txt 안에 정의되어 있다.\nSphinx 설치 후 재시도 위의 명령과 비슷하게 virtualenv를 설정하고 필요 패키지를 설치한 다음 다시 make htmldocs를 시도해보자. (나는 git 관리의 편의를 위해 virtualenv 디렉토리를 .sphinx로 변경했다.)\nSphinx 설치 후 재시도  $ /usr/bin/python3 -m venv .sphinx $ . .sphinx/bin/activate $ pip install -r ./Documentation/sphinx/requirements.txt Collecting docutils Downloading docutils-0.16-py2.py3-none-any.whl (548 kB) |████████████████████████████████| 548 kB 1.9 MB/s Collecting Sphinx==2.4.4 Downloading Sphinx-2.4.4-py3-none-any.whl (2.7 MB) |████████████████████████████████| 2.7 MB 11.2 MB/s Collecting sphinx_rtd_theme Downloading sphinx_rtd_theme-0.5.0-py2.py3-none-any.whl (10.8 MB) |████████████████████████████████| 10.8 MB 11.6 MB/s : # (다른 설치 기록은 생략함) Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Pygments-2.7.3 Sphinx-2.4.4 alabaster-0.7.12 babel-2.9.0 certifi-2020.12.5 chardet-3.0.4 docutils-0.16 idna-2.10 imagesize-1.2.0 packaging-20.7 pyparsing-2.4.7 pytz-2020.4 requests-2.25.0 snowballstemmer-2.0.0 sphinx-rtd-theme-0.5.0 sphinxcontrib-applehelp-1.0.2 sphinxcontrib-devhelp-1.0.2 sphinxcontrib-htmlhelp-1.0.3 sphinxcontrib-jsmath-1.0.1 sphinxcontrib-qthelp-1.0.3 sphinxcontrib-serializinghtml-1.1.4 urllib3-1.26.2 $ make htmldocs SPHINX htmldocs --\u0026gt; file:///home/jsyoo5b/Workspace/Kernel/iamroot/Documentation/output PARSE include/uapi/linux/dvb/audio.h PARSE include/uapi/linux/dvb/ca.h PARSE include/uapi/linux/dvb/dmx.h PARSE include/uapi/linux/dvb/frontend.h PARSE include/uapi/linux/dvb/net.h PARSE include/uapi/linux/dvb/video.h PARSE include/uapi/linux/videodev2.h PARSE include/uapi/linux/media.h PARSE include/uapi/linux/cec.h PARSE include/uapi/linux/lirc.h Running Sphinx v2.4.4 Extension error: Could not import extension kfigure (exception: No module named \u0026#39;six\u0026#39;) enabling CJK for LaTeX builder make[1]: *** [Documentation/Makefile:82: htmldocs] Error 2 make: *** [Makefile:1658: htmldocs] Error 2     'use strict'; var containerId = JSON.parse(\"\\\"2423e612531d1468\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  문서를 생성하던 도중 에러가 발생한다. 하지만 어떻게 해결해야 하는지에 대한 해결법은 나오지 않는다. 이 부분이 내가 기여한 이슈의 시작점이다.\nSphinx 문서 생성의 문제점 분석 위의 make htmldocs에서 에러가 난 부분만 다시 집중해보자.\nhtmldocs 빌드 실패 로그  $ make htmldocs SPHINX htmldocs --\u0026gt; file:///home/jsyoo5b/Workspace/Kernel/iamroot/Documentation/output PARSE include/uapi/linux/dvb/audio.h PARSE include/uapi/linux/dvb/ca.h PARSE include/uapi/linux/dvb/dmx.h PARSE include/uapi/linux/dvb/frontend.h PARSE include/uapi/linux/dvb/net.h PARSE include/uapi/linux/dvb/video.h PARSE include/uapi/linux/videodev2.h PARSE include/uapi/linux/media.h PARSE include/uapi/linux/cec.h PARSE include/uapi/linux/lirc.h Running Sphinx v2.4.4 Extension error: Could not import extension kfigure (exception: No module named \u0026#39;six\u0026#39;) enabling CJK for LaTeX builder make[1]: *** [Documentation/Makefile:82: htmldocs] Error 2 make: *** [Makefile:1658: htmldocs] Error 2     'use strict'; var containerId = JSON.parse(\"\\\"628a2d851a96ca7f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  kfigure라는 extension을 import할수 없는데, 그 이유는 six란 모듈을 찾을수 없기 때문이라고 한다. 일단 kfigure가 뭔지 확인해보자.\nshell  $ ls Documentation/sphinx/ automarkup.py kernel_include.py load_config.py parse-headers.pl cdomain.py kernellog.py maintainers_include.py requirements.txt kerneldoc.py kfigure.py parallel-wrapper.sh rstFlatTable.py     'use strict'; var containerId = JSON.parse(\"\\\"d5187be37c038f35\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  kfigure는 Documentation/sphinx/에 작성된 모듈로, rst에서 그린 그림을 이미지로 변환해주는 모듈이다. 그럼 해당 파일의 내용에서 six가 사용되는 부분을 확인해보자.\nDocumentation/sphinx/kfigure.py (상단 import 부분) Documentation/sphinx/kfigure.py (하단 사용 부분)  57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  from docutils.parsers.rst.directives import images import sphinx from sphinx.util.nodes import clean_astext from six import iteritems import kernellog PY3 = sys.version_info[0] == 3 if PY3: _unicode = str else: _unicode = unicode # Get Sphinx version major, minor, patch = sphinx.version_info[:3] if major == 1 and minor \u0026gt; 3: # patches.Figure only landed in Sphinx 1.4 from sphinx.directives.patches import Figure # pylint: disable=C0413 else: Figure = images.Figure __version__ = \u0026#39;1.0.0\u0026#39;     528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557  def add_kernel_figure_to_std_domain(app, doctree): \u0026#34;\u0026#34;\u0026#34;Add kernel-figure anchors to \u0026#39;std\u0026#39; domain. The ``StandardDomain.process_doc(..)`` method does not know how to resolve the caption (label) of ``kernel-figure`` directive (it only knows about standard nodes, e.g. table, figure etc.). Without any additional handling this will result in a \u0026#39;undefined label\u0026#39; for kernel-figures. This handle adds labels of kernel-figure to the \u0026#39;std\u0026#39; domain labels. \u0026#34;\u0026#34;\u0026#34; std = app.env.domains[\u0026#34;std\u0026#34;] docname = app.env.docname labels = std.data[\u0026#34;labels\u0026#34;] for name, explicit in iteritems(doctree.nametypes): if not explicit: continue labelid = doctree.nameids[name] if labelid is None: continue node = doctree.ids[labelid] if node.tagname == \u0026#39;kernel_figure\u0026#39;: for n in node.next_node(): if n.tagname == \u0026#39;caption\u0026#39;: sectname = clean_astext(n) # add label to std domain labels[name] = docname, labelid, sectname break       'use strict'; var containerId = JSON.parse(\"\\\"c40c96c5d71634ae\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  확인해보니 six에서 iteritem 함수를 사용하는데, 현재 virtualenv에서 설치한 패키지 중에는 six가 존재하지 않는 것 같다.\n문제의 six 패키지에 대한 정보를 검색해보니 python2와 python3 사이의 호환성을 유지하기 위해 사용하는 모듈이라 한다. 그런데 왜 six는 자동으로 설치되지 않았을까?\nrequirements.txt 확인 일단 Sphinx를 실행시키는 환경의 requirements.txt의 내용을 확인해보자.\nDocumentation/sphinx/requirements.txt  docutils Sphinx==2.4.4 sphinx_rtd_theme     'use strict'; var containerId = JSON.parse(\"\\\"153d63e588103837\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  설치 목록에 six가 없는 것을 알 수 있다. 하지만 지금 증상을 다른 사람들이 눈치채지 못했다는 것은, 저기 목록에 있는 패키지 중에 하나가 원래는 six를 자동으로 설치했을 것이다.\n이전 설치기록을 보면 알 수 있듯이, 위 3가지 패키지를 설치하기 위해 그 패키지들이 필요로 하는 하위 의존성 있는 패키지들을 같이 설치한 것을 볼 수 있다.\npip로 설치한 결과  $ pip install -r ./Documentation/sphinx/requirements.txt Collecting docutils Downloading docutils-0.16-py2.py3-none-any.whl (548 kB) |████████████████████████████████| 548 kB 1.9 MB/s Collecting Sphinx==2.4.4 Downloading Sphinx-2.4.4-py3-none-any.whl (2.7 MB) |████████████████████████████████| 2.7 MB 11.2 MB/s Collecting sphinx_rtd_theme Downloading sphinx_rtd_theme-0.5.0-py2.py3-none-any.whl (10.8 MB) |████████████████████████████████| 10.8 MB 11.6 MB/s Collecting Pygments\u0026gt;=2.0 Downloading Pygments-2.7.3-py3-none-any.whl (950 kB) |████████████████████████████████| 950 kB 6.4 MB/s Collecting babel!=2.0,\u0026gt;=1.3 Downloading Babel-2.9.0-py2.py3-none-any.whl (8.8 MB) |████████████████████████████████| 8.8 MB 11.8 MB/s Requirement already satisfied: setuptools in ./.sphinx/lib/python3.8/site-packages (from Sphinx==2.4.4-\u0026gt;-r ./Documentation/sphinx/requirements.txt (line 2)) (44.0.0) Collecting requests\u0026gt;=2.5.0 Downloading requests-2.25.0-py2.py3-none-any.whl (61 kB) |████████████████████████████████| 61 kB 8.1 MB/s Collecting sphinxcontrib-serializinghtml Downloading sphinxcontrib_serializinghtml-1.1.4-py2.py3-none-any.whl (89 kB) |████████████████████████████████| 89 kB 8.1 MB/s Collecting sphinxcontrib-jsmath Downloading sphinxcontrib_jsmath-1.0.1-py2.py3-none-any.whl (5.1 kB) Collecting sphinxcontrib-htmlhelp Downloading sphinxcontrib_htmlhelp-1.0.3-py2.py3-none-any.whl (96 kB) |████████████████████████████████| 96 kB 6.3 MB/s Collecting packaging Downloading packaging-20.7-py2.py3-none-any.whl (35 kB) Collecting alabaster\u0026lt;0.8,\u0026gt;=0.7 Downloading alabaster-0.7.12-py2.py3-none-any.whl (14 kB) Collecting sphinxcontrib-devhelp Downloading sphinxcontrib_devhelp-1.0.2-py2.py3-none-any.whl (84 kB) |████████████████████████████████| 84 kB 2.9 MB/s Collecting sphinxcontrib-qthelp Downloading sphinxcontrib_qthelp-1.0.3-py2.py3-none-any.whl (90 kB) |████████████████████████████████| 90 kB 8.9 MB/s Collecting snowballstemmer\u0026gt;=1.1 Downloading snowballstemmer-2.0.0-py2.py3-none-any.whl (97 kB) |████████████████████████████████| 97 kB 7.4 MB/s Collecting imagesize Downloading imagesize-1.2.0-py2.py3-none-any.whl (4.8 kB) Collecting Jinja2\u0026gt;=2.3 Downloading Jinja2-2.11.2-py2.py3-none-any.whl (125 kB) |████████████████████████████████| 125 kB 12.3 MB/s Collecting pytz\u0026gt;=2015.7 Downloading pytz-2020.4-py2.py3-none-any.whl (509 kB) |████████████████████████████████| 509 kB 12.2 MB/s Collecting chardet\u0026lt;4,\u0026gt;=3.0.2 Downloading chardet-3.0.4-py2.py3-none-any.whl (133 kB) |████████████████████████████████| 133 kB 12.1 MB/s Collecting idna\u0026lt;3,\u0026gt;=2.5 Downloading idna-2.10-py2.py3-none-any.whl (58 kB) |████████████████████████████████| 58 kB 7.7 MB/s Collecting urllib3\u0026lt;1.27,\u0026gt;=1.21.1 Downloading urllib3-1.26.2-py2.py3-none-any.whl (136 kB) |████████████████████████████████| 136 kB 13.2 MB/s Collecting certifi\u0026gt;=2017.4.17 Downloading certifi-2020.12.5-py2.py3-none-any.whl (147 kB) |████████████████████████████████| 147 kB 12.4 MB/s Collecting pyparsing\u0026gt;=2.0.2 Downloading pyparsing-2.4.7-py2.py3-none-any.whl (67 kB) |████████████████████████████████| 67 kB 6.4 MB/s Collecting MarkupSafe\u0026gt;=0.23 Downloading MarkupSafe-1.1.1-cp38-cp38-manylinux1_x86_64.whl (32 kB) Installing collected packages: docutils, sphinxcontrib-applehelp, Pygments, pytz, babel, chardet, idna, urllib3, certifi, requests, sphinxcontrib-serializinghtml, sphinxcontrib-jsmath, sphinxcontrib-htmlhelp, pyparsing, packaging, alabaster, sphinxcontrib-devhelp, sphinxcontrib-qthelp, snowballstemmer, imagesize, MarkupSafe, Jinja2, Sphinx, sphinx-rtd-theme Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Pygments-2.7.3 Sphinx-2.4.4 alabaster-0.7.12 babel-2.9.0 certifi-2020.12.5 chardet-3.0.4 docutils-0.16 idna-2.10 imagesize-1.2.0 packaging-20.7 pyparsing-2.4.7 pytz-2020.4 requests-2.25.0 snowballstemmer-2.0.0 sphinx-rtd-theme-0.5.0 sphinxcontrib-applehelp-1.0.2 sphinxcontrib-devhelp-1.0.2 sphinxcontrib-htmlhelp-1.0.3 sphinxcontrib-jsmath-1.0.1 sphinxcontrib-qthelp-1.0.3 sphinxcontrib-serializinghtml-1.1.4 urllib3-1.26.2     'use strict'; var containerId = JSON.parse(\"\\\"607a57a8e51d1d85\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  하지만 위의 상황에서 설명했듯, six는 설치되지 않았다. 혹시 다른 패키지나 six가 설치 목록에 있었는데 삭제된 것은 아닌지 확인해보자.\nrequirements.txt 관련 로그 확인  $ git --no-pager log --stat Documentation/sphinx/requirements.txt commit d5afc9640a6d4596e57a2c4906f903ab1c83ada5 Author: Mauro Carvalho Chehab \u0026lt;mchehab+huawei@kernel.org\u0026gt; Date: Tue Apr 14 18:48:30 2020 +0200 docs: update recommended Sphinx version to 2.4.4 There are some docs that have nested tables. While this was always part of the spec, only Sphinx version 2.4.x can translate it to LaTeX. In other words, if someone is using a Sphinx version \u0026lt; 2.4, the LaTeX and PDF output won\u0026#39;t work for some of the docs. So, it seems that it is time to raise the bar again for the recommented version. The Sphinx check script is already smart enough to keep working, with older versions, warning the users that an upgrade is recommended (and explaining how): Sphinx version 1.7.9 Warning: It is recommended at least Sphinx version 2.4.4. Detected OS: Fedora release 31 (Thirty One). To upgrade Sphinx, use: /usr/bin/virtualenv sphinx_2.4.4 . sphinx_2.4.4/bin/activate pip install -r ./Documentation/sphinx/requirements.txt Signed-off-by: Mauro Carvalho Chehab \u0026lt;mchehab+huawei@kernel.org\u0026gt; Link: https://lore.kernel.org/r/498f701c618f7d0cf5f0a37e5889ee926f7c8bf4.1586881715.git.mchehab+huawei@kernel.org Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/requirements.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) commit a700767a7682d9bd237e927253274859aee075e7 Author: Mauro Carvalho Chehab \u0026lt;mchehab+samsung@kernel.org\u0026gt; Date: Wed May 29 20:09:32 2019 -0300 docs: requirements.txt: recommend Sphinx 1.7.9 As discussed at the linux-doc ML, while we\u0026#39;ll still support version 1.3, it is time to recommend a more modern version. So, let\u0026#39;s switch the minimal requirements to Sphinx 1.7.9, as it has the \u0026#34;-jauto\u0026#34; flag, with makes a lot faster when building documentation. Signed-off-by: Mauro Carvalho Chehab \u0026lt;mchehab+samsung@kernel.org\u0026gt; Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/requirements.txt | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) commit fb947f3f472303d54759bf898cf92fd8c2dc9bdf Author: Mauro Carvalho Chehab \u0026lt;mchehab@kernel.org\u0026gt; Date: Mon Jul 17 18:46:38 2017 -0300 sphinx-pre-install: use a requirements file Instead of using 3 commands to install a virtualenv, use a single one, reading the requirements from this file: Documentation/sphinx/requirements.txt Signed-off-by: Mauro Carvalho Chehab \u0026lt;mchehab@s-opensource.com\u0026gt; Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/requirements.txt | 3 +++ 1 file changed, 3 insertions(+)     'use strict'; var containerId = JSON.parse(\"\\\"8b1c16fba43a89f3\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  다행히 requirements.txt의 변화 기록도 많지 않고, 변화분도 적어서 쉽게 확인할 수 있다. 시간순으로 각 commit에 대해 요약하자면 아래와 같다.\n 원래는 virtualenv에서 각 패키지들 설치 명령을 직접 입력하던 것을 간소화(fb947f3f472303d54759bf898cf92fd8c2dc9bdf) 문서 생성 속도를 빠르게 하기 위해 Sphinx의 버전을 1.7.9로 변경함(a700767a7682d9bd237e927253274859aee075e7) 다른 문서 생성하는 부분에 Sphinx 1.7.9는 부적합해서 버전을 2.4.4로 변경함(d5afc9640a6d4596e57a2c4906f903ab1c83ada5)  딱히 six가 지워질 이유는 없었던 것 같다. 그렇다면 혹시 six를 사용하는 kfigure.py에서 갑자기 six를 사용하기 시작했는데 requirements.txt에 추가하는 것을 빼먹었을 수도 있지 않을까? kfigure.py의 수정 기록을 찾아보자.\nkfigure.py에서 six 부분 기록 확인하기 kfigures.py 관련 로그 확인  $ git --no-pager log --stat Documentation/sphinx/kfigure.py commit 93431e0607e58a3c997a134adc0fad4fdc147dab Author: Alexander A. Klimov \u0026lt;grandmaster@al2klimov.de\u0026gt; Date: Tue May 26 08:05:44 2020 +0200 Replace HTTP links with HTTPS ones: documentation Rationale: Reduces attack surface on kernel devs opening the links for MITM as HTTPS traffic is much harder to manipulate. Deterministic algorithm: For each file: For each line: If doesn\u0026#39;t contain `\\bxmlns\\b`: For each link, `\\bhttp://[^# \\t\\r\\n]*(?:\\w|/)`: If both the HTTP and HTTPS versions return 200 OK and serve the same content: Replace HTTP with HTTPS. Signed-off-by: Alexander A. Klimov \u0026lt;grandmaster@al2klimov.de\u0026gt; Link: https://lore.kernel.org/r/20200526060544.25127-1-grandmaster@al2klimov.de Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/kfigure.py | 6 +++--- 1 file changed, 3 insertions(+), 3 deletions(-) commit 096ea522e84ea68f8e6c41e5e7294731a81e29bc Author: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Date: Tue May 21 14:23:43 2019 -0600 doc: Cope with Sphinx logging deprecations Recent versions of sphinx will emit messages like: Documentation/sphinx/kerneldoc.py:103: RemovedInSphinx20Warning: app.warning() is now deprecated. Use sphinx.util.logging instead. Switch to sphinx.util.logging to make this unsightly message go away. Alas, that interface was only added in version 1.6, so we have to add a version check to keep things working with older sphinxes. Cc: stable@vger.kernel.org Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/kfigure.py | 40 +++++++++++++++++++++++----------------- 1 file changed, 23 insertions(+), 17 deletions(-) commit ae17a87dd7c79fa742ef5dcf06d1095eec4e1925 Author: Masanari Iida \u0026lt;standby24x7@gmail.com\u0026gt; Date: Thu Jan 11 20:00:28 2018 +0900 linux-next: docs-rst: Fix typos in kfigure.py This patch fixes some spelling typos found in kfigure.py Signed-off-by: Masanari Iida \u0026lt;standby24x7@gmail.com\u0026gt; Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/kfigure.py | 6 +++--- 1 file changed, 3 insertions(+), 3 deletions(-) commit db6ccf23e8ba40fc2e8914ec9c0eb950df71d9fe Author: Markus Heiser \u0026lt;markus.heiser@darmarit.de\u0026gt; Date: Mon Mar 6 14:09:27 2017 +0100 docs-rst: automatically convert Graphviz and SVG images This patch brings scalable figure, image handling and a concept to embed *render* markups: * DOT (http://www.graphviz.org) * SVG For image handling use the \u0026#39;image\u0026#39; replacement:: .. kernel-image:: svg_image.svg :alt: simple SVG image For figure handling use the \u0026#39;figure\u0026#39; replacement:: .. kernel-figure:: svg_image.svg :alt: simple SVG image SVG image example Embed *render* markups (or languages) like Graphviz\u0026#39;s **DOT** is provided by the *render* directive.:: .. kernel-render:: DOT :alt: foobar digraph :caption: Embedded **DOT** (Graphviz) code. digraph foo { \u0026#34;bar\u0026#34; -\u0026gt; \u0026#34;baz\u0026#34;; } The *render* directive is a concept to integrate *render* markups and languages, yet supported markups: * DOT: render embedded Graphviz\u0026#39;s **DOT** * SVG: render embedded Scalable Vector Graphics (**SVG**) Cc: Jani Nikula \u0026lt;jani.nikula@linux.intel.com\u0026gt; Cc: Laurent Pinchart \u0026lt;laurent.pinchart@ideasonboard.com\u0026gt; Tested-by: Mauro Carvalho Chehab \u0026lt;mchehab@s-opensource.com\u0026gt; Tested-by: Daniel Vetter \u0026lt;daniel.vetter@ffwll.ch\u0026gt; Signed-off-by: Daniel Vetter \u0026lt;daniel.vetter@intel.com\u0026gt; (v2 - v5) Signed-off-by: Markus Heiser \u0026lt;markus.heiser@darmarit.de\u0026gt; (v1, v6) Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/kfigure.py | 551 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1 file changed, 551 insertions(+)     'use strict'; var containerId = JSON.parse(\"\\\"3c266c8bcb8d7ac4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  commit 기록이 많은 것은 아니지만, 딱히 six를 언급하는 부분은 찾을 수 없다. 그렇다면 git log보단 git blame으로 해당 라인의 기록을 찾는 것이 더 효율적이다.\n관련 파일에 대한 git blame  $ git --no-pager blame -L48,62 Documentation/sphinx/kfigure.py db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 48) import os db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 49) from os import path db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 50) import subprocess db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 51) from hashlib import sha1 db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 52) import sys db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 53) db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 54) from docutils import nodes db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 55) from docutils.statemachine import ViewList db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 56) from docutils.parsers.rst import directives db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 57) from docutils.parsers.rst.directives import images db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 58) import sphinx db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 59) db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 60) from sphinx.util.nodes import clean_astext db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 61) from six import iteritems db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 62)     'use strict'; var containerId = JSON.parse(\"\\\"aa9ce324f938b27d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위에서 확인했던 commit 기록과 비교해봤을 때(db6ccf23e8ba40fc2e8914ec9c0eb950df71d9fe), six는 kfigure.py를 처음 작성했을 때 부터 계속 사용해 왔음을 알 수 있다. 그렇다면 다시 requirements.txt의 기록을 다시 찾아봐야 한다.\nrequirements.txt의 하위 의존성 패키지 찾아보기 지금까지 분석한 것을 보고 평소 python으로 개발을 해 본 사람으로 생각했다면, 아쉽게도 나는 python을 아주 가끔 쓰기 때문에 전문적으로 아는 것은 아니다. 각 패키지 설치의 하위 의존성을 확인하는 방법을 검색해봤는데 나는 찾지 못했다. (키워드를 잘 모르는 것일 가능성이 높아보임)\n현재로선 requirements.txt에 작성된 패키지를 직접 찾아 들어가서 하위 호환성을 확인해 보는 수밖에 없겠다. (사실 3가지 commit 버전을 모두 requirements.txt로 설치해보고 언제부터 six가 설치 목록에서 사라졌는지 확인하는 것이 제일 쉽다.)\nrequirements.txt의 기록을 보면 Sphinx의 버전이 2번 변경되었고, docutils가 1번 변경되었다. 변경 횟수가 더 많은 Sphinx가 더 의심스러워서 Sphinx를 먼저 찾아봤다. Sphinx의 소스에서 하위 의존성 패키지 설치 목록이 정의된 파일은 setup.py인 것 같다. 코드의 install_requires 리스트에서 하위 의존성 패키지를 선언하고 있고, 제일 아래 setup의 인자로 전달되는 것을 확인할 수 있다.\n다행히 requirements.txt에서 Sphinx의 버전이 명시되어 있으므로, 일단은 각 버전 별로 setup.py를 비교해보자. Sphinx는 각 버전을 배포할 때마다 버전 이름으로 tag를 달아놨으므로, tag를 기반으로 각 버전을 찾아가면 되겠다.\n각 tag에 들어가면 tag가 연결된 commit id를 알아낼 수 있다. 해당 commit id를 클릭하면 그 commit 당시의 소스 코드를 확인할 수 있다. 각 버전, 해당 commit id, 그때 당시의 setup.py를 링크로 정리하면 다음과 같다.\n   태그 commit id 해당 파일 상태     v2.4.4 72ad5f2 setup.py   v1.7.9 1cd87a1 setup.py    분명 v1.7.9에는 install_requires에 six가 있지만, v2.4.4에는 존재하지 않는 것을 확인할 수 있다. 결국 Sphinx 버전이 올라가면서 six가 하위 의존성에서 제외되면서 자동으로 설치되지 않게 되었음을 알 수 있다.\n참고로 six는 2.x부터 하위 의존성에서 제외된 것을 확인할 수 있다.\n왜 이 문제를 발견하지 못했을까? Sphinx 버전을 2.4.4로 올린 commit의 로그를 다시 확인해보자.\nSphinx 버전 변경 commit  commit d5afc9640a6d4596e57a2c4906f903ab1c83ada5 Author: Mauro Carvalho Chehab \u0026lt;mchehab+huawei@kernel.org\u0026gt; Date: Tue Apr 14 18:48:30 2020 +0200 docs: update recommended Sphinx version to 2.4.4 There are some docs that have nested tables. While this was always part of the spec, only Sphinx version 2.4.x can translate it to LaTeX. In other words, if someone is using a Sphinx version \u0026lt; 2.4, the LaTeX and PDF output won\u0026#39;t work for some of the docs. So, it seems that it is time to raise the bar again for the recommented version. The Sphinx check script is already smart enough to keep working, with older versions, warning the users that an upgrade is recommended (and explaining how): Sphinx version 1.7.9 Warning: It is recommended at least Sphinx version 2.4.4. Detected OS: Fedora release 31 (Thirty One). To upgrade Sphinx, use: /usr/bin/virtualenv sphinx_2.4.4 . sphinx_2.4.4/bin/activate pip install -r ./Documentation/sphinx/requirements.txt Signed-off-by: Mauro Carvalho Chehab \u0026lt;mchehab+huawei@kernel.org\u0026gt; Link: https://lore.kernel.org/r/498f701c618f7d0cf5f0a37e5889ee926f7c8bf4.1586881715.git.mchehab+huawei@kernel.org Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/requirements.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)     'use strict'; var containerId = JSON.parse(\"\\\"983be5ed31336495\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  여기에서는 Sphinx 검사 스크립트가 버전 업그레이드 필요 여부에 대한 경고 및 설치법을 잘 설명하고 있다고만 언급하고 있다.\n즉, 해당 패치를 작성할 때는 Sphinx 버전을 업그레이드하는 경우만 고려하고, 처음부터 설치하는 경우는 고려하지 않은 상태였음을 알 수 있다. 1.7.9에서 2.4.4로 업그레이드하는 경우는 이미 1.7.9 설치 과정에서 six가 설치되어 있기 때문에 이런 문제를 확인하지 못한 것으로 보인다.\n문제 해결 및 commit 일단 six가 없는 문제는 six를 설치하면 된다. 위에서 requirements.txt를 사용했으니 여기에 six를 추가하면 된다.\n그리고 혹시 다른 모듈에서도 설치되지 않은 패키지가 있는지 확인해보자.\n다른 import 내역 확인  $ grep -r \u0026#34;import\u0026#34; Documentation/sphinx Documentation/sphinx/automarkup.py:from docutils import nodes Documentation/sphinx/automarkup.py:from sphinx import addnodes Documentation/sphinx/automarkup.py:from sphinx.environment import NoUri Documentation/sphinx/automarkup.py:import re Documentation/sphinx/load_config.py:import os Documentation/sphinx/load_config.py:import sys Documentation/sphinx/load_config.py:from sphinx.util.pycompat import execfile_ Documentation/sphinx/kernel_include.py:# imports Documentation/sphinx/kernel_include.py:import os.path Documentation/sphinx/kernel_include.py:from docutils import io, nodes, statemachine Documentation/sphinx/kernel_include.py:from docutils.utils.error_reporting import SafeString, ErrorString Documentation/sphinx/kernel_include.py:from docutils.parsers.rst import directives Documentation/sphinx/kernel_include.py:from docutils.parsers.rst.directives.body import CodeBlock, NumberLines Documentation/sphinx/kernel_include.py:from docutils.parsers.rst.directives.misc import Include Documentation/sphinx/kerneldoc.py:import codecs Documentation/sphinx/kerneldoc.py:import os Documentation/sphinx/kerneldoc.py:import subprocess Documentation/sphinx/kerneldoc.py:import sys Documentation/sphinx/kerneldoc.py:import re Documentation/sphinx/kerneldoc.py:import glob Documentation/sphinx/kerneldoc.py:from docutils import nodes, statemachine Documentation/sphinx/kerneldoc.py:from docutils.statemachine import ViewList Documentation/sphinx/kerneldoc.py:from docutils.parsers.rst import directives, Directive Documentation/sphinx/kerneldoc.py:import sphinx Documentation/sphinx/kerneldoc.py: from sphinx.util.docutils import switch_source_input Documentation/sphinx/kerneldoc.py: from sphinx.ext.autodoc import AutodocReporter Documentation/sphinx/kerneldoc.py:import kernellog Documentation/sphinx/kernellog.py:import sphinx Documentation/sphinx/kernellog.py: from sphinx.util import logging Documentation/sphinx/rstFlatTable.py:# imports Documentation/sphinx/rstFlatTable.py:import sys Documentation/sphinx/rstFlatTable.py:from docutils import nodes Documentation/sphinx/rstFlatTable.py:from docutils.parsers.rst import directives, roles Documentation/sphinx/rstFlatTable.py:from docutils.parsers.rst.directives.tables import Table Documentation/sphinx/rstFlatTable.py:from docutils.utils import SystemMessagePropagation Documentation/sphinx/kfigure.py:import os Documentation/sphinx/kfigure.py:from os import path Documentation/sphinx/kfigure.py:import subprocess Documentation/sphinx/kfigure.py:from hashlib import sha1 Documentation/sphinx/kfigure.py:import sys Documentation/sphinx/kfigure.py:from docutils import nodes Documentation/sphinx/kfigure.py:from docutils.statemachine import ViewList Documentation/sphinx/kfigure.py:from docutils.parsers.rst import directives Documentation/sphinx/kfigure.py:from docutils.parsers.rst.directives import images Documentation/sphinx/kfigure.py:import sphinx Documentation/sphinx/kfigure.py:from sphinx.util.nodes import clean_astext Documentation/sphinx/kfigure.py:from six import iteritems Documentation/sphinx/kfigure.py:import kernellog Documentation/sphinx/kfigure.py: from sphinx.directives.patches import Figure # pylint: disable=C0413 Documentation/sphinx/cdomain.py:from docutils import nodes Documentation/sphinx/cdomain.py:from docutils.parsers.rst import directives Documentation/sphinx/cdomain.py:import sphinx Documentation/sphinx/cdomain.py:from sphinx import addnodes Documentation/sphinx/cdomain.py:from sphinx.domains.c import c_funcptr_sig_re, c_sig_re Documentation/sphinx/cdomain.py:from sphinx.domains.c import CObject as Base_CObject Documentation/sphinx/cdomain.py:from sphinx.domains.c import CDomain as Base_CDomain     'use strict'; var containerId = JSON.parse(\"\\\"0ce7ea252137fbcf\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  일단 import를 기준으로 검색해 본 결과 six만 없는 것으로 판단했다. 이제 수정하고 commit을 작성하자. 앞에서 조사했던 내용을 포함하여 왜 six가 requirements.txt에 추가되어야 하는지 설명하자.\n전송한 patch commit log 번역  From eb48c1fd1092cdd0c1636ea0275ab3a48101e483 Mon Sep 17 00:00:00 2001 From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; Date: Mon, 7 Dec 2020 23:35:09 +0900 Subject: [PATCH] docs: update requirements to install six module On the update of Sphinx version to 2.4.4, the \u0026#34;six\u0026#34; library won\u0026#39;t be installed automatically. (which is required by kfigure.py) Main reason of this issue were occurred by the requirements changed from the sphinx library. In Sphinx v1.7.9, six was listed on the install_requires, but it has been removed since 2.x The kfigure.py uses six library explicitly, adding six to requirements.txt seems reasonable Signed-off-by: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; ---  Documentation/sphinx/requirements.txt | 1 + 1 file changed, 1 insertion(+) diff --git a/Documentation/sphinx/requirements.txt b/Documentation/sphinx/requirements.txt index 489f6626de67..5030d346d23b 100644 --- a/Documentation/sphinx/requirements.txt +++ b/Documentation/sphinx/requirements.txt @@ -1,3 +1,4 @@  docutils Sphinx==2.4.4 sphinx_rtd_theme +six -- 2.25.1   Sphinx 버전을 2.4.4로 올리면서, \u0026#34;six\u0026#34; 라이브러리가 더 이상 자동으로 설치가 되지 않는다. (kfigure.py에서 필요함) 이 문제의 주요 원인은 sphinx 라이브러리의 요구사항이 변경되었기 때문이다. Sphinx v1.7.9까지는 six가 install_requires에 있었는데, 2.x부터는 삭제되었다. kfigure.py에서 six 라이브러리를 명시적으로 사용하니깐, six를 requirements.txt에 추가하는 것이 좋겠다.     'use strict'; var containerId = JSON.parse(\"\\\"05fe45ef339dc7df\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  해당 패치를 커널에 반영하기 위해서는 메일로 패치를 전송해야 하는데, 그건 내용이 복잡하기도 하고, 주제를 따로 빼는 것이 좋을 것 같아 다음 글에서 설명하도록 하겠다.\n결과 해당 patch를 메일로 전송했고, 마지막으로 requirements.txt를 수정했던 사람으로부터 답장이 왔다. 사실 1줄밖에 안되는 데다가 간단한 문제기 때문에 특별한 review가 없다.\n이후 실제 Documentation의 maintainer가 나한테 patch가 적용되었다고 답장을 보냈다. Python2 하위 호환성을 그만 제공하는 것이 제일 최선이지만, 그 전까지는 six를 설치하는 것이 맞으니 일단 적용하도록 하겠다고 한다. 마침 sphinx 분석 과정에서 현재 버전이 더 이상 python2를 지원하지 않으니, 아예 그냥 python3로 변경시키면 안되는지 물어봤고, 메일을 주고 받은 결과 일단은 더 수정할 거리는 없이 여기서 마무리 하기로 했다.\n최종적으로 commit이 mainline에 등록되었다.\n","description":"","id":41,"section":"posts","tags":["커널","git","sphinx"],"title":"내 첫 리눅스 커널 기여","uri":"https://devlog.jsyoo5b.net/ko/posts/linux-kernel/my-first-commit/"},{"content":"본 리뷰는 조엘 온 소프트웨어 책에 대한 리뷰입니다.\n이 책은 지식전달 목적의 교재보다는 개발자의 에세이에 가까운 책이므로 특별히 장단점 분석을 하지 않습니다. 또한 본 글에서 책의 내용과 설명 부분은 제 주관적인 해석이 포함되어 있으므로 저자의 의도와 일치하지 않을 수 있습니다.\n읽은 계기 나는 이 책을 약 7~8년 전에 처음 접했었다. 그때 당시에는 1부 중간을 읽다가 말았던 것 같은데, 최근 이 책을 끝까지 읽었다. 7~8년 전이면 학부 4학년~대학원생(+회사 파트타임 근무 기간)일 때였는데, 당시에는 이 책이 코드 작성법에 대한 조언을 위주로 하는 책인줄 알았다. 왜냐하면 가장 인상깊은 내용이 러시아 페인트공 문제였기 때문이다. (참고로 원문에서는 Shlemiel the painter\u0026rsquo;s algorithm이라고 되어있는데, 의미로 해석한다면 실수가 잦은 페인트공의 알고리즘이라고 해석할 수 있겠다. 왜 실수가 잦은 사람이 러시아인으로 번역되었는지는 잘 모르겠다.)\n그리고 이런 글로 시작한다는 것은, 드디어 끝까지 읽어봤기 때문이다. 끝까지 읽어보니 이 책을 지금 읽은 것이 가장 적절했다고 생각했다. 왜냐하면 책의 중반부터 다루는 내용은 코드를 잘 짜는 법보단 개발자로서 일을 잘 하는 법에 가깝기 때문이다. 학생때나 초급 개발자 시기에는 실제 프로젝트를 수행하며 생기는 경험이 부족하기 때문에 같은 내용을 읽었어도 느끼는 바가 적었을 것이다.\n레거시 코드를 활용해야하는 이유에 대한 합리적 설득 이번에 읽으면서 제일 큰 깨달음을 얻은 부분이라면 레거시 코드를 활용해야 하는 이유에 대해 합리적인 설득 부분이다. 회사에서 참고한 기존 코드 뿐만 아니라 내가 이전 프로젝트에서 작성한 코드조차 싹 다 밀어버리고 처음부터 다시 작성하고 싶다는 생각이 강렬하게 들었다. 실제로 일부는 직접 다시 작성하는 경우가 있었는데 내 나름대로 합리적인 이유는 있었다. 기존 코드가 특정 환경에 너무 의존적이거나, 해당 코드를 라이브러리화 했을 때 라이브러리의 장점을 살리지 못하는 경우라던가, 안 좋은 설계로 구현한 코드임을 알게 되었을때 등의 이유였다. (모두 설계가 좋지 않았기 때문으로 수렴한다.)\n최근 프로젝트는 핵심은 유지하고 API만 변경하거나, 가독성만 발전시키는 방향으로 리팩토링하는 식으로 최대한 레거시 코드를 활용하긴 했다. 하지만 \u0026ldquo;시간적 여유만 더 있었더라면 저 레거시 코드와 타협하지 않고 더 깨끗하게 작성할 수 있을텐데\u0026quot;같은 미련이 없진 않았다. 그런데 이 책에서는 코드를 새로 작성하는 것은 결코 해선 안될 일이라고 말한다. 핵심적인 근거는 3가지이다.\n기본적으로 코드는 작성보다 읽는것이 더 어렵다 나는 이 부분을 내가 예전에 짰던 코드를 보며 공감할 수 있었다. 물론 과거에 비해 나는 조금 더 경험이 생기고, 지식이 쌓이고, 다른 코드도 많이 봤을테니 예전에 짰던 코드가 구려보이는 것은 당연할 것이다. 하지만 남이 짠것도 아니고 내가 짠 코드인데 \u0026ldquo;그땐 이걸 몰랐지, 이렇게 고치자\u0026rdquo; 수준이 아니라 \u0026ldquo;도대체 과거의 나는 코드에 뭔 짓을 한거지?\u0026rdquo; 같은 생각이 든다는 것이다. 남이 짠 코드가 구려보이면 그 사람 실력이 모자라다고 거만한 생각을 했겠지만, 고작 3개월 사이에 다시 읽어본 코드에서 이런 생각이 든다는 것은 읽는 입장에서는 모든 코드가 다 구려 보인다고 볼 수 있을 것 같다.\n프로그램을 숲으로 비유하자면, 숲을 만들기 위해 묘목을 한번에 심고 다 같이 키워서 울창하게 하는 것이 아니라, 묘목 하나를 나무로 만들고, 그 나무를 기준으로 묘목을 추가로 심는 것을 반복해서 만들게 될 것이다. 당연히 나무 하나하나에 집중하면서 작성하다 보니 큰 숲의 관점으로 보기 힘든 것은 당연하다. 미래의 내가 엿먹으라고 이렇게 작성한게 아니라 이게 그때 당시에 최선이었을 것이라는 것이다. 글을 잘 쓰기 위해선 다 쓰고 읽어봐야 하는 것과 같은 이야기다. 하지만 보통 빌드한 프로그램을 돌려보고 동작을 확인하는 것에서 끝난다. 읽을 것을 고민하는 시간은 설계하는 시간이 거의 전부다. 작성하다 보면 당연하다 생각해서 주석도 쓰지 않는 경우도 많다.\n물론 레거시 코드에는 기술부채도 분명 존재할 것이다. 마감이 급할 때 버그 수정을 위해 하드코딩한다던가, 바로 다음 프로젝트가 급해서 기술부채를 해결하지 못하고 프로젝트를 종료하는 등 레거시 코드의 품질 저하에는 여러 원인이 있을 수 있다. 하지만 이 상황은 나만 겪는 것이 아닐것이다. 나, 내 후임, 내 동료, 내 사수 모두 이런 저런 이유로 읽기 힘든 레거시 코드를 생성했을 것이다.\n기존 코드는 여러 에러에 대처한 훌륭한 코드 다른 이유는 어느정도 간접적으로 눈치채고 있었다. 머리로 알겠는 것과 마음까지 완전히 바뀌는 것은 별개다보니 여전히 코드를 새로 작성하고 싶다는 욕구가 생기곤 했다. 하지만 이 설명을 보고 나니 체크메이트 당한 기분이었다. 버그 수정을 위해 급하게 작성한 코드는 가독성은 안 좋지만, 소프트웨어의 목적성이나 정확성은 보장한다. 여러 핑계를 대면서 코드를 처음부터 다시 작성한다면 똑같은 실수를 반복하게 될 것이다.\n비슷한 관점에서 연상되는 글이 있다. 정확히 내가 생각하던 글은 아닌 것 같은데, 핵심은 코드를 변경할 때 테스트 코드는 안전을 보장하진 못해도 없을 때 생길 위험을 많이 줄여준다는 주장이었다. 그런데 코드를 처음부터 다시 작성하면 테스트 코드도 활용하지 못할 가능성이 높다. 위험을 줄여주는 테스트 코드조차 활용할 수 없으니, 기술 부채를 없애기 위해 시작한 작업이 오히려 다른 관점의 기술 부채를 생성할 수도 있다.\n코드를 다시 작성하는 것은 민첩성이 떨어져 시장 지배력이 낮아질 수 있다 책에서는 넷스케이프가 코드를 갈아엎고 새로 짜다가 시장 점유를 놓친 이야기로 이 이유에 대한 설명을 보충한다. 위에서 내가 한 생각처럼 시간적 여유만 더 있었더라면은 개발자의 기준일 뿐, 그러다 제품 출시가 미뤄지고, 시장 점유율을 놓치는 이야기는 마치 상업성과 예술성에서 고민하는 예술가 모습을 보는 것 같다. 최소한 예술가는 예술성에 집중하면 이를 알아주고 가치를 높여주는 평론가라도 있지만, 프로그래머는 제품으로 내놓을 뿐 코드를 내놓지 않는다. (오픈소스 이야기는 바로 아래에서 할 것이다.) 취미로 코드를 작성한다면 몰라도 일하고 사업하는 입장에선 장인정신이 매번 옳은 마음가짐이 아닐 수도 있다.\n물론 오픈소스 프로젝트들은 사업성과 거리가 멀어보인다. 하지만 자세히 보면 오픈소스들 간에도 경쟁하고, 도태되고, 살아남는 현상은 존재한다. 내가 생각하는 대표적인 예시는 jQuery와 YUI다. (내가 웹 개발을 전문적으로 하지 않으므로 좋은 예시가 아닐수도 있다.) 내 기억으론 둘 다 JavaScript를 보조하기 위한 라이브러리로 사용되었고, 지원하는 기능의 범위도 비슷하다. 지금은 jQuery도 구시대 기술로 취급받을 만큼 웹 개발 환경도 바뀐 상태지만, jQuery와 YUI의 인지도를 비교해보면 jQuery가 압도적일 것이다. jQuery는 2020년에도 업데이트가 되고 있지만, YUI는 2014년에 프로젝트가 종료되었다. YUI가 코드를 처음부터 다시 작성해서 도태된 것은 아니지만, 오픈소스들 나름의 경쟁이 있고, 예술성만으로 평가받는 분야가 아님을 이야기하고 싶었다. 오픈소스지만 전혀 인지도가 없다면 그냥 공개해놓은 프로젝트처럼 보일 것이다.\n혹시 YUI에 대한 관심이 있을 사람을 위해 왜 YUI가 도태되고 종료되었는지를 분석한 글도 첨부한다.\n소프트웨어 세계에선 만병통치 디자인도 없다 소프트웨어의 종류를 분야에 따라 다르게 구분을 하면서 각 분야별로 다른 개발 방법론을 적용해야 한다고 했다. 나는 이 중에서도 사용자와 소프트웨어의 관계, 디자인 관련된 설명에서 느끼는 바가 많았다. 이 책에서는 소프트웨어의 종류를 5가지로 분류했다.\n 상품 소프트웨어\n말 그대로 상품으로 판매하는 소프트웨어로, 사용자는 불특정 다수이며, 해당 사용자의 도메인 지식(해당 소프트웨어 사용과 관련된 지식) 수준 또한 예측하기 어렵다. 또한 다른 경쟁 상품/대체재가 존재할 가능성이 높다. 사내 소프트웨어\n회사 내부 \u0026amp; 관련 협력사에서 사용할 소프트웨어로, 사용자는 어느정도 한정된 인원이며, 대부분 도메인 지식을 잘 갖추고 있다고 생각할 수 있다. 임베디드 소프트웨어\n특정 하드웨어에서 구동되도록 제한되어있으며, 최대한 단순화 된 입출력만을 사용하여 사용자와 상호작용한다. 하드웨어에 의존적이다보니 사용자에게 요구하는 도메인 지식의 깊이가 낮은 편이다. (소프트웨어 기준) 품질 기준은 다른 종류 소프트웨어보다 한참 높다. (문제를 고칠 기회조차 오지 않을 가능성이 있기 때문이다.) 성능적 제한으로 인해 우아한 코드보단 빠른 코드가 더 중요하다. 게임 소프트웨어 (주로 패키지 게임을 말하는 듯)\n상품 소프트웨어의 일부지만, 기존 상품 소프트웨어와의 차이점이 있다. 화면, 키보드/마우스부터 내부 하드웨어 자원까지 독점에 가깝게 사용하는 구조로 동작한다. 버전 변화가 버그 수정같은 수준으로 한정적이다. 제품을 지속적으로 사용할 확률이 낮다. 이러한 복합적인 원인에 의해 임베디드 수준의 품질 기준을 요구하게 된다. 일회성 소프트웨어\n귀찮은 일을 반복시키기 위해 급히 작성한 쉘 스크립트, 해당 소프트웨어가 자주 활용되거나 발전시킬 가치가 생기면 사내 소프트웨어의 형태로 변형된다.  특히 여기서 상품 소프트웨어와 사내 소프트웨어를 다루면서 디자인에 관한 관점도 언급한다. 과장해서 사내 소프트웨어는 더럽게 디자인해도 대체재가 없기 때문에 사용된다. 게다가 해당 소프트웨어를 반복적으로 사용할 수록 거기에 몸이 적응해서 시간이 갈수록 그 문제를 못 느끼게 된다.\n나는 전문적인 디자인을 배우지도 않았고, 특히나 배색을 위한 색감은 거의 최악 수준이다. 하지만 내 나름대로의 디자인 철학이 있는데, \u0026ldquo;이거 어떻게 사용하는거에요?\u0026rdquo; 같은 질문을 듣지 말자 였다. 상품 소프트웨어를 개발하는 입장에서는 괜찮은 철학이지만 사내 소프트웨어를 개발할 때는 불필요하게 에너지를 낭비할 수도 있는 철학임을 인지할 수 있었다.\n다른 관점으로 생각해 보면 상품 소프트웨어와 사내 소프트웨어의 관계는 입문용 제품과 전문가용 제품의 관계로 비유해 볼 수 있을 것 같다.\n말단 프로그래머가 할 수 있는 일 말단이면서도 해내기에서는 말단 프로그래머가 회사를 변화시키기 위한 전략을 설명하고 있다. 요약하자면 좋은 향기가 나는 사람이 되라는 것이다.\n회사 내부에서는 매우 오래 된 소스 관리 도구로 버전 관리를 하고 있었다. (보안상 문제가 될 수도 있어 특정하지는 않는다. 상당히 오래 된 소스 관리 도구인데 당신이 생각하는 그것은 아닐 것 같다.) 게다가 직원들도 해당 도구 사용법을 완벽히 숙지하지 못한 것인지, 각종 환장의 콜라보가 터져나오는 소리가 들리곤 했다.\n A가 file.c라는 파일을 보고 있는데, 그거땜에 B라는 사람이 file.c를 수정을 못 하고 있다. 소스의 접근 권한 관리가 실제 파일의 읽기/쓰기 권한과 연동되어서, 다른 에디터로 수정 시 소스 상태가 꼬인다. A가 file.c를 수정하다가 예기치 않게 프로그램이 종료되었는데 서버에 권한이 꼬인 상태가 되어 직접 DB를 수정해줘야 한다. A가 뭔가 수정을 했는데, B가 사용하려니 문제가 있다. 근데 B가 문제를 수정하지 못하고 A가 수정해줘야 한다.  일부는 정확하지 않은 상황일 수도 있다. (일부는 내가 겪었던 상황을 기억을 바탕으로 쓴 것이고, 일부는 직원들끼리 오가는 이야기에서 맥락을 파악한 것이다.) 그리고 글의 정황에서 눈치챘겠지만, 저런 상황이 계속 나오는데도 여전히 그 도구를 사용해왔다. 다행히(?) 나는 그 도구를 사용해야 할 상황이 적었는데, 어쨋든 소스 관리에 대한 대책이 필요해 보였다.\n일단 대세는 git이었다. 대학원때나 파트타임으로 일할때는 SVN도 사용해봤었는데, 전문적으로 사용한 것은 아니었다. 내가 아는 git은 SourceForge처럼 코드를 가져오는 수단 정도였다. 사실상 git == github였다. (물론 둘의 차이는 알고 있었지만, 활용 수준에선 둘을 동일 개념으로 보는 수준이었다.) 나 혼자라도 해봐야겠다는 생각으로 시작했다.\n1년차에는 git의 최소한의 사용법은 익혀서, 날짜 단위로 코드 형상에 대한 스냅샷을 보관하는 수준으로는 활용할 수 있었다. 구글링 하면서 더듬대긴 했지만 어쨋든 과거의 코드 형상을 다시 가져오는 등의 작업은 할 수 있었다.\n2년차에 접어들 때, git을 좀 더 효율적으로 사용하기 위한 방법인 git-flow를 배웠다. Commit의 단위를 깔끔하게 나눈 것은 아니었지만, 내 코드의 흐름이 보이기 시작했다.\n3년차에 접어들 때, 아예 git 관련 전문 강의를 수강했다. 처음엔 \u0026ldquo;인터넷에 뒤지면 튜토리얼부터 시작해서 자료가 많은데 굳이 이걸 돈 주고 들어야 할까?\u0026rdquo; 같은 생각으로 구글링만 갖고 독학하려 했다. 부족한 부분은 있었지만 \u0026ldquo;일단 나 혼자서는 형상 관리가 가능함\u0026rdquo; 수준까지는 된다고 판단했다. 하지만 회사에서 다른 사람한테 가르쳐주기엔 모자라다는 생각을 했고, 협업 관련 지식은 부족했기에 강의를 수강했다. 그 해에는 외부 교육 수강에 대한 지원조차 받지 못했지만, 내 사비로 수강했다. (기업 문화를 발전시키겠다는 대의보단 나라도 살고 봐야겠다는 의욕이 더 정확하지만.)\n내가 git을 통해 편하게 일하는 듯한 향기를 풍기며 간접적으로 홍보했다. 매번 새로운 버전을 배포할 때 git log를 바탕으로 패치노트를 작성해서 전달했고, 버그의 원인 규명이나 수정도 효율적으로 했다. 문제의 그 소스 관리 도구와 연관된 프로젝트는 따로 내가 git 버전으로 포팅해서 보관했고, 그걸로 변경 이력에 대한 분석도 도와줬다.\n마침내 1명은 git을 공부하기 시작했다. 공부할 때 필요한 자료도 찾아서 공유해줬고, 가끔 물어보면 아는대로 대답해줬다. 내가 판단하기에 그 1명정도는 바꾸는데 성공한 것 같았다. 고작 1명이냐 싶겠지만 코드를 수정하는 6명 중 1명을 바꿨다.\n이거 15년 전에 출간된 책인데 간과하기 쉬운 사실은 이 책이 2005년에 출간된 책이라는 것이다. 심지어 이 책은 블로그 글을 잘 편집하고 번역한 것이며 실제 글의 작성 시기를 고려하면 거의 20년 전 글이다. 번역이 지금 보기에 완전 자연스럽진 않아도 읽는데 불편함이 없을 정도로 잘 번역되어있다. 그리고 책에서 언급하는 회사나 인물이 번역 당시에는 독자들이 잘 모를까봐 주석을 달아놨지만, 지금은 주석을 달지 않아도 될 만큼 국내에서도 유명한 존재라는 것도 재밌다. (Amazon의 제프 베조스, 밴엔제리 아이스크림 등) 두 기업을 롤 모델 방향에 관해 정리하면서 언급하는데 글의 작성 시기를 모른다면 그냥 성공한 기업에 본인 편한대로 해석한 느낌이 들 정도다. 성공하는 사람/회사를 알아보는걸까?\n개발자로서 나를 돌아보게 되다 내가 팔랑귀일수도 있겠지만, 책을 보면서 개발자로서의 좌우명이 약간 변경되었다. 장인정신으로 깨끗하게 작성한 코드가 목적이었는데, 때와 상황에 맞게 유기적으로 변할 수 있는 개발자가 되어야겠다는 생각이 들었다. 기존의 좌우명은 정해진 기간, 적당한 상황 단위로 최선을 다 하되 평생 그러고 있다간 오히려 도태될 수도 있겠다는 생각이 들었다.\n약간 안도감도 들었다. 내가 일하는 상황이나 고민이 이상한 것이 아니라 충분히 발생할 수 있다는 것, 해결을 위해 한 문제분석이나 가설, 해결법이 비슷한 것을 보고 \u0026ldquo;최소한 개발 업무는 정상적으로 했구나\u0026rdquo; 같은 생각이 들었다.\n또한 내가 해 온 선택이 매번 옳은 것은 아니었지만, 몇몇 부분에서는 꽤 괜찮은 선택을 해왔음을 인정받는 느낌이 들었다. 솔직히 처음에는 나라도 살아남아야겠다로 시작했지만, 나중에는 사람들을 바꿀 수 없다면 내가 잘해서 바뀌고 싶게 만들자는 생각으로 해왔던 일이 이 책에서도 추천하는 방법일 줄은 몰랐다. (다른 사람들은 어떻게 생각하는지 모르겠지만\u0026hellip;)\n","description":"","id":42,"section":"posts","tags":["조엘 온 소프트웨어"],"title":"[책 리뷰] 조엘 온 소프트웨어","uri":"https://devlog.jsyoo5b.net/ko/posts/review/book-joel-on-software/"},{"content":"라즈베리파이 OS를 설치한 microSD카드를 꽂고 전원을 연결하면 바로 라즈베리파이 OS가 부팅된다. 하지만 해당 장치를 사용하려면 HDMI로 모니터에 연결하고 (혹은 DSI 커넥터에 디스플레이 모듈 연결) 키보드, 마우스를 연결해야 한다. Headless 방식은 위 장치들이 없이 네트워크 혹은 시리얼 케이블로 연결하는 환경을 말한다. (보통 위 3가지 장치를 묶어서 KVM 스위치 등으로 여러 컴퓨터를 동시 제어할 때 쓰기도 한다.)\n본 문서에서는 라즈베리파이를 처음부터 Headless로 사용하기 위해 필요한 설정 방법을 설명할 것이다. 순서는 아래와 같다.\n 네트워크/시리얼 포트로 라즈베리파이와 연결 가능한 환경 확보 SSH 원격 접속을 설정하여 CLI로 접속 가능하게 하기 VNC 원격 접속을 설정하여 GUI로 접속 가능하게 하기  본 문서에서는 처음부터 headless로 사용하기 위해 라즈베리파이 OS가 설치된 microSD의 내용을 변경하는 방법을 설명한다. 라즈베리파이 OS가 설치된 microSD카드는 FAT32로 포맷된 boot 파티션과 ext4로 포멧된 rootfs 파티션이 있을 것이다. 본 문서에서는 boot파티션의 내용 수정을 주로 설명할 것이다.\n라즈베리파이와 연결 가능한 환경 확보하기 WiFi 자동 접속 설정하기 라즈베리파이를 유선랜으로 연결할 수 있다면 가장 좋겠지만, 불가능한 경우 WiFi에 자동 접속하도록 설정해주자. 라즈베리파이는 wpa_supplicant를 사용하므로 해당 설정 파일을 미리 작성해서 넣으면 된다.\nboot 파티션에 wpa_supplicant.conf 파일을 생성하고 WiFi 연결 정보를 작성한다. 아래는 WiFi AP 이름이 \u0026ldquo;testing\u0026rdquo;, 비밀번호가 \u0026ldquo;testingPassword\u0026quot;일 때의 작성 예시다.\nwpa_supplicant.conf  ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=GB network={ ssid=\u0026#34;testing\u0026#34; psk=\u0026#34;testingPassword\u0026#34; }     'use strict'; var containerId = JSON.parse(\"\\\"632bdaa7022852bc\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  country= 부분에는 현재 WiFi의 국가를 설정하는 부분인데, 한국이라서 KR로 입력하면 WiFi 사용에 문제가 있는 경우가 있으므로, 일단은 GB 혹은 US로 설정해 주도록 하자. (링크를 보면 알겠지만, 한국에서 WiFi 사용을 위한 주파수 밴드가 대부분 비활성화 되어 있어 생기는 문제다.)\n비밀번호 없는 WiFi 접속 설정 network={ } 안에 비밀번호 대신 key_mgmt=NONE를 입력하면 된다. 아래는 비밀번호 없는 WiFi AP 이름이 \u0026ldquo;testing\u0026quot;일 때의 작성 예시다.\nwpa_supplicant.conf  network={ ssid=\u0026#34;testing\u0026#34; key_mgmt=NONE }     'use strict'; var containerId = JSON.parse(\"\\\"388f3671cb9c95e8\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  숨겨진 WiFi 접속 설정 network={ } 안에 scan_ssid=1을 추가하면 된다. 아래는 숨겨진 WiFi AP 이름이 \u0026ldquo;hiddenSSID\u0026rdquo;, 비밀번호가 \u0026ldquo;testingPassword\u0026quot;일 때의 작성 예시다.\nwpa_supplicant.conf  network={ ssid=\u0026#34;hiddenSSID\u0026#34; scan_ssid=1 psk=\u0026#34;testingPassword\u0026#34; }     'use strict'; var containerId = JSON.parse(\"\\\"9cb8b0c0a8794701\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  2개 이상의 WiFi 접속 설정 각 WiFi AP에 대한 network={ }를 여러 개 입력하면 된다. 각 WiFi AP간 우선순위는 priority=으로 표기한다. 아래는 WiFi AP 이름이 \u0026ldquo;firstSSID\u0026rdquo;, 비밀번호가 \u0026ldquo;firstPassword\u0026quot;이고 다른 WiFi AP의 이름이 \u0026ldquo;secondSSID\u0026rdquo;, 비밀번호가 \u0026ldquo;secondPassword\u0026quot;이며, \u0026ldquo;firstSSID\u0026quot;를 우선적으로 접속하고 싶을 때의 작성 예시이다.\nwpa_supplicant.conf  network={ ssid=\u0026#34;firstSSID\u0026#34; psk=\u0026#34;firstPassword\u0026#34; priority=1 } network={ ssid=\u0026#34;secondSSID\u0026#34; psk=\u0026#34;secondPassword\u0026#34; priority=2 }     'use strict'; var containerId = JSON.parse(\"\\\"f0c554d493b247be\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  WiFi 비밀번호 암호화하기 이전까지의 설정은 모두 비밀번호가 평문으로 저장된다는 문제점이 있다. 비밀번호를 노출하고 싶지 않다면, 미리 암호화된 비밀번호로 변환하여 저장하는 방법이 있다. (해당 방법은 wpa_supplicant를 직접 사용해야하며, 윈도우즈에서는 일반적으로 설치하기 힘든 것으로 보인다.)\n $ wpa_passphrase $SSID $PASSPHRASE\n wpa_supplicant를 설치하면 wpa_passphrase 명령어도 같이 설치되는데, 위와 같이 명령어의 인자로 WiFi AP의 이름과 비밀번호를 입력하면 사용해야 할 network={ } 내용을 생성해준다. 원문 비밀번호는 앞에 #으로 주석처리되어 있는데, 평문을 노출하지 않고 저장하는 것이 목적이므로 해당 줄만 삭제하면 된다. 아래는 WiFi AP 이름이 \u0026ldquo;testing\u0026rdquo;, 비밀번호가 \u0026ldquo;testingPassword\u0026quot;일 때 평문을 감추는 예시다.\nshell  $ wpa_passphrase testing testingPassword network={ ssid=\u0026#34;testing\u0026#34; #psk=\u0026#34;testingPassword\u0026#34; psk=131e1e221f6e06e3911a2d11ff2fac9182665c004de85300f9cac208a6a80531 }     'use strict'; var containerId = JSON.parse(\"\\\"5fe18d086909bd4d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  wpa_supplicant를 직접 사용할 수 없는 경우에는 Wireshark에서 제공하는 변환 페이지를 사용할 수도 있다.\n라즈베리파이 제로를 USB 이더넷 장치로 사용할 수 있게 설정하기 라즈베리파이 제로의 경우 WiFi가 지원되지 않는다. 하지만 해당 제품에서 USB 연결 설정을 변경하여 PC에서 USB 이더넷 장치로 인식하게 하는 방법이 있다. Addon board나 dongle expansion breakout module kit을 사용한다면 PC에서 라즈베리파이를 마치 이더넷 어댑터에 연결한 것 처럼 사용할 수 있다. 이 방법은 라즈베리파이 제로 W도 적용 가능하다.\nboot 파티션의 cmdline.txt 파일을 아래와 같이 수정한다.\n console=serial0,115200 console=tty1 root=PARTUUID=384c22b9-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait modules-load=dwc2,g_ether quiet splash plymouth.ignore-serial-consoles\n 해당 파일은 1줄짜리로 되어있는데, 내용 중 rootwait 부분과 quiet 사이에 modules_load=dwc2,g_ether를 추가해준다.\n또한 config.txt 파일에 dtoverlay=dwc2를 추가한다.\nconfig.txt  50 51 52 53 54 55 56 57 58  # Uncomment this to enable infrared communication. #dtoverlay=gpio-ir,gpio_pin=17 #dtoverlay=gpio-ir-tx,gpio_pin=18 # Additional overlays and parameters are documented /boot/overlays/README dtoverlay=dwc2 # Enable audio (loads snd_bcm2835) dtparam=audio=on       'use strict'; var containerId = JSON.parse(\"\\\"1416b6d8403bf746\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  라즈베리 파이 제로의 USB controller인 DesignWare Core2의 OTG 설정을 활성화해주고, USB OTG 모듈 중 g_ether 모듈을 사용하게 하는 것이다.\n윈도우즈에서는 이렇게 설정한 라즈베리파이를 연결하면 RNDIS 장치로 인식하게 되는데, 해당 장치 연결 시 컴퓨터가 느려지는 문제가 있다.\n라즈베리파이에게 DHCP로 IP를 할당해 줄 수 없을 때 라즈베리파이 제로를 USB로 연결하거나, 공유기 등에서 DHCP 기능을 사용하지 않는 경우 라즈베리파이는 IP를 할당받지 못하게 된다. 고정IP 설정은 boot 파티션 수정으로 할 수 없기 때문에 rootfs 파티션 내부를 수정하거나, 링크 로컬 주소를 사용해야 한다. 위에서 말한대로 rootfs는 ext4로 포멧되어있으니 윈도우즈만 사용하는 경우에는 고정IP 설정은 바로 할 수 없다고 생각하면 된다.\nrootfs에서 고정 IP 설정하기 rootfs의 /etc/dhcpcd.conf 파일 끝에 아래와 같이 수정한다.\n/etc/dhcpcd.conf  interface $IF_NAME static ip_address=$DEV_IP_ADDR/$PREFIX_BITS static routers=$GATEWAY_IP_ADDR static domain_name_servers=$DNS_IP_ADDR     'use strict'; var containerId = JSON.parse(\"\\\"b44f1196fe8b2885\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }   $IF_NAME은 사용할 네트워크 장치의 이름을 입력한다. (유선랜: eth0, WiFi: wlan0) $DEV_IP_ADDR는 라즈베리파이가 사용할 주소를, $PREFIX_BITS는 서브넷 마스크의 비트 수를 입력하면 된다. $GATEWAY_IP_ADDR는 공유기의 주소를 입력한다. $DNS_IP_ADDR는 DNS의 주소를 입력한다. (대부분 공유기가 DNS요청을 대신 처리해주기 때문에 공유기의 주소를 입력해도 된다.)  유선랜과 WiFi의 설정을 같이 입력해도 된다. 아래는 유선랜이 172.16.1.101, WiFi가 172.16.2.101로 잡히도록 설정한 예시이다. (공유기는 172.16.0.1로 가정)\n/etc/dhcpcd.conf  interface eth0 static ip_address=172.16.1.101/16 static routers=172.16.0.1 static domain_name_servers=172.16.0.1 interface wlan0 static ip_address=172.16.2.101/16 static routers=172.16.0.1 static domain_name_servers=172.16.0.1     'use strict'; var containerId = JSON.parse(\"\\\"1e2162dee9b02106\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  SSH 원격 접속 설정하기 boot 파티션 안에 ssh 혹은 ssh.txt 파일만 생성하면 된다. 해당 파일의 내용은 관계없다. (빈 파일도 상관없다.)\n리눅스의 경우 touch 명령어를 사용하여 생성할 수 있다.\nshell  # touch $RPI_BOOT/ssh     'use strict'; var containerId = JSON.parse(\"\\\"1f653dbdcd93491b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  VNC 원격 접속 설정하기 VNC 서버 설정은 boot 파티션 수정으로 할 수 없다. 원칙적으로 VNC 원격 접속 설정은 라즈베리파이를 부팅하고 나서, raspi-config를 사용하여 Interfacing option에서 VNC 서버 사용 여부를 수정해야한다. 하지만 해당 명령어의 코드를 보면 systemctl을 이용하여 VNC 서비스 데몬을 enable시키는 것을 확인할 수 있다. systemctl enable의 역할은 미리 작성된 서비스 데몬의 파일을 자동 실행되도록 심볼릭 링크를 달아주는 것이므로 rootfs에서 미리 수정할 수 있다. 위에서 말한대로 rootfs는 ext4로 포멧되어있으니 윈도우즈만 사용하는 경우에는 VNC 원격 접속 설정은 바로 할 수 없다고 생각하면 된다.\nshell  # ln -s -f /usr/lib/systemd/system/vncserver-x11-serviced.service $RPI_ROOTFS/etc/systemd/system/multi-user.target.wants/vncserver-x11-serviced.service     'use strict'; var containerId = JSON.parse(\"\\\"f75df27b966c05a9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  chroot를 통해 미리 라즈베리파이 OS의 rootfs 위에서 작업하거나, 혹은 mount된 경로를 고려하여 심볼릭 링크를 생성해주면 된다.\n 원본 VNC 서비스 데몬 스크립트 위치: /usr/lib/systemd/system/vncserver-x11-serviced.service 연결할 자동 실행 위치: /etc/systemd/system/multi-user.target.wants/  원본 VNC 서비스 데몬 스크립트의 경로는 위에 설명한 경로로 고정되어야 한다. (라즈베리파이 안에서 해당 스크립트의 위치를 찾으면 되기 때문이다.)\n참고 링크 [1] boot 파티션 상세 설명(https://www.raspberrypi.org/documentation/configuration/boot_folder.md)\n[2] WiFi 설정을 위한 wpa_supplicant 설명(https://www.raspberrypi.org/documentation/configuration/wireless/headless.md)\n[3] 라즈베리파이 제로의 USB OTG 모드 설정(https://gist.github.com/gbaman/50b6cca61dd1c3f88f41)\n","description":"","id":43,"section":"posts","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"https://devlog.jsyoo5b.net/ko/posts/rpi/headless-config-in-sd/"},{"content":"최근 라즈베리파이 사이트에서는 손쉽게 라즈베리파이 OS설치를 위한 프로그램 Raspberry Pi Imager를 제공하지만, 본 문서에서는 해당 프로그램을 사용하지 않고 직접 설치하는 과정을 설명하려 한다. 당연히 최근의 라즈베리파이는 microSD카드를 사용하지만, 본 글에서는 편의상 SD카드라고 표현하도록 하겠다.\nOS 이미지를 다운받아서 준비해놓자.\n Raspberry Pi OS with desktop and recommended software: 기본적인 GUI 뿐만 아니라 모든 추천 SW가 설치되어 있는 상태 Raspberry Pi OS with desktop: 기본적인 GUI와 최소한의 SW만 설치되어 있는 상태 Raspberry Pi OS Lite: 최소한의 OS 구성요소만 설치됨 (GUI도 설치되어 있지 않음)  윈도우즈에서 SD카드에 OS 설치하기 먼저 SD카드를 포맷해야 한다.\n 윈도우즈의 포맷 기능 사용 SD 그룹의 포맷 도구 사용  SD카드 내에 1개의 파티션으로, FAT32로 포맷하면 된다.\nSD카드의 용량이 64GB이상일 때 (SDXC) SD카드의 용량이 32GB보다 큰 용량이라면 SD카드 포맷 시 추가적으로 수행해야 할 작업이 있다. (보통 용량이 32GB 다음에 64GB이므로 64GB라고 표현하였다.) 문제가 되는 SD카드는 표면에 SDXC 혹은 SDUC라고 써있는 카드들이다. SDUC는 표준상 2TB 이상일텐데, 라즈베리파이에 그만큼 비싼 카드를 사용할 사람은 없으리라 생각하여 SDXC만 고려하도록 하겠다.\n특히 2020년 기준으로는 SD카드의 단가가 많이 내려간 편이라 64GB의 가성비가 32GB의 가성비보다 좋은 경우가 있고, 일부 브랜드의 경우 용량이 더 큰데도 가격이 더 싼 경우가 존재하므로 다루는 것이 좋을 것이라 생각했다.\n문제의 원인은 SDXC에서 기본 파일시스템 형식을 exFAT로 선정했기 때문인데, 일반적인 방법으로는 윈도우즈에서 SDXC 카드를 FAT32로 포맷할 수 없기 때문이다. 라즈베리파이의 부팅 파티션은 FAT32만 가능하기 때문에 이를 수정해줘야 한다.\n FAT32 포맷 GUI 버전 FAT32 포맷 CLI 버전  라즈베리파이 OS 이미지 올리기  Win32DiskImager balenaEtcher Upshift imgFlasher  위 도구 중 하나를 사용하여 다운받았던 OS 이미지를 올리면 된다.\n리눅스에서 터미널로 SD카드에 OS 설치하기 SD카드 블록 장치 이름 확인  $ lsblk -p\n lsblk 명령을 통해 연결된 블록 장치(저장장치)를 확인한다. 사이즈, 마운트 경로 등을 통해 SD카드의 장비 이름을 알아내도록 하자. (만약 블록 장치가 많거나 유사해서 확인하기 힘들다면, SD카드를 연결하기 전의 명령어 결과와 연결한 후의 명령어 결과를 비교하여 유추하도록 하자)\nshell  $ lsblk -p NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 1 60.1G 0 disk ├─/dev/sda1 8:1 1 256M 0 part /mnt/boot └─/dev/sda2 8:2 1 59.8G 0 part /mnt/rootfs /dev/nvme0n1 259:0 0 476.9G 0 disk ├─/dev/nvme0n1p1 259:1 0 512M 0 part /efi ├─/dev/nvme0n1p2 259:2 0 444.4G 0 part / └─/dev/nvme0n1p3 259:3 0 32G 0 part [SWAP]     'use strict'; var containerId = JSON.parse(\"\\\"f0c742495c38d1aa\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  나의 경우는 노트북의 OS가 nvme0에 설치되어있으므로 SD카드는 sda임을 알 수 있다.\n라즈베리파이 OS 이미지 쓰기  # dd bs=4M status=progress if=$RPI_OS_IMG of=$SD_DEVICE\n dd 명령으로 라즈베리파이 OS 이미지를 SD카드에 기록한다. 위 명령어의 $RPI_OS_IMG는 라즈베리파이 OS 이미지 파일을 압축해제한 경로를 넣으면 되고, $SD_DEVICE는 위에서 찾은 SD카드 블록 장치의 경로를 입력한다.\nshell  $ sudo dd bs=4M status=progress if=./2020-08-20-raspios-buster-armhf.img of=/dev/sda 3812622336 bytes (3.8 GB, 3.6 GiB) copied, 209 s, 18.2 MB/s 911+0 records in 911+0 records out 3821010944 bytes (3.8 GB, 3.6 GiB) copied, 537.638 s, 7.1 MB/s     'use strict'; var containerId = JSON.parse(\"\\\"cf1eea2d9c7ef4a6\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  파티션 상태 확인, 확장하기  $ lsblk -p $SD_DEVICE\n 라즈베리파이 OS 이미지가 기록된 SD카드의 파티션 정보를 확인해보자. 이미 우리는 SD카드의 블록 장치 이름을 알고 있으니, 해당 장치 이름만 사용해서 해당 디스크의 상태를 확인하자.\nshell  $ lsblk -p /dev/sda NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 1 60.1G 0 disk ├─/dev/sda1 8:1 1 256M 0 part └─/dev/sda2 8:2 1 3.3G 0 part     'use strict'; var containerId = JSON.parse(\"\\\"9df0c0d0efe5f064\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  결과를 자세히 보면 2개의 파티션으로 나눠져 있는데, sda1은 라즈베리파이 부팅 설정을 위한 파티션으로 FAT32로 포맷되어있다. sda2는 라즈베리파이의 rootfs이다. (부팅 후 \u0026lsquo;/\u0026lsquo;에 마운트되는 파일시스템)\n문제는 두 파티션 용량의 합이 전체 SD카드의 용량에 비해 터무니없이 작다는 것이다. 약 56GB가 낭비되고 있는데, 이 공간을 rootfs가 사용할 수 있게 파티션을 변경해보자. 여기서는 fdisk를 사용하도록 하겠다.\n(참고로 라즈베리파이를 부팅한 이후에도 자체적으로 파티션 확장하는 기능이 제공되긴 한다.)\n # fdisk $SD_DEVICE\n shell  $ sudo fdisk /dev/sda Welcome to fdisk (util-linux 2.36). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): p Disk /dev/sda: 60.06 GiB, 64490569728 bytes, 125958144 sectors Disk model: Storage Device Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x58ce116e Device Boot Start End Sectors Size Id Type /dev/sda1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/sda2 532480 7462911 6930432 3.3G 83 Linux     'use strict'; var containerId = JSON.parse(\"\\\"2be84ea96dea3124\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  SD카드의 장치 이름을 인자로 fdisk를 실행한다. 먼저 p 명령을 입력하여 현재 SD카드의 상세 정보를 출력한다. 여기에서 중요한 값은 Disk의 전체 sector 갯수(예시의 125958144), rootfs(2번째 파티션)의 시작 sector 값(예시의 532480)이다.\nfdisk  Command (m for help): d Partition number (1,2, default 2): 2 Partition 2 has been deleted.     'use strict'; var containerId = JSON.parse(\"\\\"93a607cab8e0a175\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  fdisk에서는 파티션을 바로 확장하는 명령어가 제공되지 않는다. 파티션을 삭제하고 용량을 키워서 다시 할당해야 한다. (해당 파티션의 내용이 삭제되는 것이 아니라, 파티션의 범위 정보만 변경되는 것이다.) d 명령을 입력하여 rootfs 파티션의 정보만 삭제한다.\nfdisk  Command (m for help): n Partition type p primary (1 primary, 0 extended, 3 free) e extended (container for logical partitions) Select (default p): p Partition number (2-4, default 2): 2 First sector (2048-125958143, default 2048): 532480 Last sector, +/-sectors or +/-size{K,M,G,T,P} (532480-125958143, default 125958143): Created a new partition 2 of type \u0026#39;Linux\u0026#39; and of size 59.8 GiB. Partition #2 contains a ext4 signature. Do you want to remove the signature? [Y]es/[N]o: n     'use strict'; var containerId = JSON.parse(\"\\\"e022e3defbef286f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이제 기존 파티션의 위치에 맞춰서 용량을 늘려서 다시 생성하자. n 명령을 입력하여 새로 생성한다. primary type으로 선택, 파티션 번호는 기존의 2번으로 선택하자. (위의 extended 파티션 타입은 해당 파티션이 Logical partition일 때 이를 확장하기 위해 사용되는 파티션이므로 지금 파티션 크기를 확장시키는 것과 다른 것이다.)\n이제 파티션의 시작 sector, 마지막 sector를 설정해줘야 한다. 삭제하기 전의 sda2 파티션의 시작 sector 값을 입력하자. (위에서 확인했던 532480) 자세히 보면 비어있는 공간이 2048번 sector에도 존재하기 때문에 기본값으로 입력하면 의도하지 않은 파티션을 생성할 수도 있다. 마지막 sector의 기본값은 전체 sector의 끝이므로 그냥 사용해도 된다.\nfdisk  Command (m for help): p Disk /dev/sda: 60.06 GiB, 64490569728 bytes, 125958144 sectors Disk model: Storage Device Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x58ce116e Device Boot Start End Sectors Size Id Type /dev/sda1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/sda2 532480 125958143 125425664 59.8G 83 Linux     'use strict'; var containerId = JSON.parse(\"\\\"7d98ebd152922e5d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이후 다시 p 명령을 입력하여 수정된 파티션 테이블을 확인하자. 이번엔 rootfs의 크기가 59.8GB로 늘어난 것을 확인할수 있다. 현재 상태는 이렇게 파티션 테이블을 재구성한다고 한 것이지 아직 반영된 것이 아니다.\nfdisk  Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks.     'use strict'; var containerId = JSON.parse(\"\\\"f3f859f4a36fa5cb\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  w 명령을 입력하여 현재 설정된 파티션 테이블을 실제로 반영하도록 하자. 해당 파티션이 변경되면 fdisk는 자동으로 종료된다.\n파티션 마운트하기 이제 아래에서 라즈베리파이 부팅 설정을 수정하려면 boot 파티션을 마운트해야한다. mount 명령으로 각 파티션을 특정 디렉토리에 마운트하자.\n # mount $SD_DEVICE_PARTITION $MOUNT_PATH\n shell  $ lsblk -p /dev/sda NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 1 60.1G 0 disk ├─/dev/sda1 8:1 1 256M 0 part └─/dev/sda2 8:2 1 59.8G 0 part $ ls -d $PWD/* /mnt/boot /mnt/rootfs $ sudo mount -t vfat /dev/sda1 /mnt/boot $ sudo mount -t ext4 /dev/sda2 /mnt/rootfs     'use strict'; var containerId = JSON.parse(\"\\\"e6acf6e85dee5179\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  일반적으로는 mount 명령시 파일시스템 타입을 입력하지 않아도 알아서 해당 파일시스템 타입에 맞게 알아서 마운트해주지만, 만약 특별히 명시해야 할 필요가 있을 경우에는 FAT32는 vfat로, ext4는 ext4로 입력해주면 된다.\n # mount -t $FS_TYPE $SD_DEVICE_PARTITION $MOUNT_PATH\n 이후 마운트 된 path에 진입하면 파일들이 존재하는 것을 확인할 수 있을 것이다.\n참고 링크 [1] 라즈베리파이 OS 설치 방법(https://www.raspberrypi.org/documentation/installation/installing-images/)\n[2] SD카드 요구사항(https://www.raspberrypi.org/documentation/installation/sd-cards.md)\n[3] SDXC 카드 포맷하기(https://www.raspberrypi.org/documentation/installation/sdxc_formatting.md)\n[4] 윈도우즈에서 설치 방법(https://www.raspberrypi.org/documentation/installation/installing-images/windows.md)\n[5] 리눅스에서 설치 방법(https://www.raspberrypi.org/documentation/installation/installing-images/linux.md)\n","description":"","id":44,"section":"posts","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"https://devlog.jsyoo5b.net/ko/posts/rpi/flash-rpi-os-into-sd/"},{"content":"본 리뷰는 리얼리눅스로부터 어떠한 지원도 받지 않았으며, 제 사비로 수강한 경험에 대한 리뷰입니다.\n리뷰 요약  추천 대상  시스템 분야에 대한 이해가 필요한 초급~중급 수준의 개발자   장점  시스템 \u0026amp; OS 분야를 다루는 강의 이론 이해 \u0026amp; 실습 적용이 적절히 어우러진 밸런스 있는 강의 지식 전달만이 아닌 해결법도 같이 가르치는 강의 수강 이후에도 질문 가능한 Q\u0026amp;A   단점  강의 주제가 한정적 \u0026amp; 매번 강의가 열리지 않는다는 점 저렴한 것은 아닌 수강비용 실습이 완벽하게 진행되지 않을 수도 있음    수강 계기 나는 원래 페스타, 온오프믹스 등 모임 주관 사이트같은 곳에서 강의 등을 찾아보고 괜찮은 강의나 행사에 참여하는 편이다. 내가 모르는 개발 트렌드나 새로운 지식의 범위를 넓히는 방법 중 하나다.\n원래 2019년에 iamroot 커널 스터디에 참여할 예정이었는데, 스터디 시작 일정과 전문연구요원 훈련소 일정이 겹치는 바람에 해당 스터디에는 참여할 수 없었다. 대신 2020년에 스터디 진행하기 전에 커널이나 C언어 심화 공부나 리눅스 커널 관련 책을 독학할 예정이었는데, 이때 페스타에서 리얼리눅스 강의를 발견했다.\n위 사진에서 볼 수 있듯, 나는 5번이나 리얼리눅스 강의를 수강하였으며, 당연히 강의가 만족스러웠기 때문에 여러 번에 걸쳐 다양한 강의를 수강했다. 본 리뷰에서는 Try 오픈소스 컨트리뷰션을 제외한 나머지 리눅스 커널에 관련된 강의들만 리뷰하도록 하겠다. (Try 오픈소스 컨트리뷰션은 따로 글을 할당하여 리뷰할 예정.)\n좋은 점 나는 현재 임베디드 FW 개발 업무를 하고 있는데, 내 업무와 관련된 강의는 정말 찾기 힘든 편이다. 시스템 \u0026amp; OS 관련 강의는 정말 찾기 힘들고, 가끔 있는 강의는 각 회사별 제품 사용에 관련된 강의로 개념적인 부분을 중점적으로 보는 강의는 거의 못 본 것 같다.\n실습 위주의 강의 내가 이전까지 시스템 \u0026amp; OS 공부 할 때 느꼈던 문제는 이런 것들이 있다.\n 내용 자체가 너무 넓고, 복잡하고, 서로 관계가 깊이 얽혀 있고 어렵다.\n(책을 읽어도 머리속에 하나도 들어오지 않는다.) 각 기능이 유기적으로 연결되어있어 적당한 시작점이 존재하지 않는다.\n(공부할 때 임시로 배제하면서 진행하는 수 밖에 없다.) 해당 상황을 겪어 보기 전 까지는 각 기법이 사용되는 이유를 이해하기 힘들다.\n(머리로는 이해한다고 하지만 딱히 문제의 심각성 등을 이해하지 못한다.) 직접 디버깅을 해 보면서 단계적으로 코드 흐름을 따라가기 어렵다.\n(코드가 너무 복잡하거나, 내가 찍을 수 있는 시간 간격보다 너무 짧거나)  각 문제들의 내용을 종합하자면 시스템 \u0026amp; OS 공부는 직접 상황을 맞닥드리지 않는 이상은 Bottom-up 방식으로 공부하게 되는 것이고, 어디부터 건드려야할지 감이 안 온다는 것이다.\n보통 여기서 열리는 강의는 특정 주제에 대한 특강 식으로 진행된다. 각 특강에서는 단계적으로 어떤 기능 하나에 대해서만 직접 확인하는 것을 목적으로 하기 때문에 공부 범위가 발산하는 것을 어느정도 방지할 수 있고, Trace라는 방식으로 실제 커널의 동작 과정을 확인해 볼 수 있기 때문에 위의 문제점을 많이 해결해 주는 편이다.\nuftrace, ftrace, sysfs 등을 통해 이론을 증명하는 실습 실습에는 uftrace, ftrace, sysfs를 사용한다.\n 개념적인 설명이 진행된다. 기능 확인을 위해 작성된 C 프로그램 코드에 대해 간략히 설명한다. 해당 프로그램을 uftrace로 실행하면서 각 함수 실행 흐름을 기록한다. Trace된 함수 흐름을 따라 리눅스 커널의 코드를 읽으면서 예상 흐름을 확인한다.  직접 작성한 코드로 재현하기 힘들거나, 실시간으로 일어나는 현상을 확인할 때는 ftrace나 sysfs 설정을 통해 확인한다.\nftrace는 실제 커널 디버깅 과정에서도 사용하는 것으로 알고 있다. 이런 도구 사용법을 같이 설명하므로 추후 개별적인 문제 해결에서도 도움이 될 수 있다.\n아쉬운 점 물론 아쉬운 점이 없는 것은 아니다. 솔직히 값어치는 하지만 쉽게 수강할 만큼 싼 비용은 아니다. (굳이 비교하자면 다른 현장 강의 가격대와 비교했을 때 비싼 건 아니다.)\n완벽하게 진행되지는 않는 실습 실습을 통해 이론을 실제로 증명하는 것이 이 강의의 핵심인데, 실습이 완벽하게 매번 똑같이 잘 이루어 지는 것은 아니다.\n첫번째 원인은 각 실습 환경이 완전히 동일하지 않기 때문이다. 강의에서는 최대한 동일한 환경을 제공하기 위해 VirtualBox 이미지로 제공하는데, 아무리 가상머신으로 표준화 해도 Host OS에서 문제를 일으키면 답이 안나온다. 최악의 경우 모든 실습이 잘 진행되지 않아 강의 내내 구경만 하는 경우가 생길 수도 있다.\n두번째 원인은 원하는 대로 Trace하는 것이 생각만큼 쉽지 않다는 것이다. Trace 중간에 스케쥴링이 일어나서 생기는 함수도 같이 추적되는 것은 물론이며, 일부 기능을 제대로 확인하려면 매번 cache를 비워줘야 하는 등 원하는 대로 쉽게 Trace되지 않는다.\n이 외에도 사소한 오류로 인해 강의가 잘 진행되지 않는 문제가 가끔 있는데, 이건 강의 횟수가 더 늘어남에 따라 점점 보완될 것이라 생각한다. 강의나 실습 조교 등을 해 본 사람이라면 공감할텐데, 수강생이 일으키는 예외의 범위는 강사의 예상 범위를 뛰어넘는다. 가르치는 입장에서는 당연하다고 생각되는 부분에서도 오류가 발생하기 때문이다.\n수강 대상 강의 정보에 수강대상, 강의 수준이 나와있다. 본인 실력에 대하여 너무 과대평가하거나 과소평가하지 말고 냉정하게 생각해보면 자신이 초급인지, 초급과 중급 사이인지, 중급인지 알 수 있을 것이다. 만약 본인이 해당 강의를 수강하기에 적합할지 잘 모르겠다면 상담을 요청해 보는 것도 괜찮다.\n나는 실제로 초급과 중급 사이라고 생각하고 리눅스 SW 기본반을 들었었는데, 배운게 없는 것은 아니지만 이미 아는 내용을 중복으로 듣는 것 같은 느낌이 있었다. (물론 기본반을 들으면서 OS 중급반을 같이 듣는 것도 원인 중 하나라고 생각한다.)\n위에서 설명한 uftrace, ftrace, sysfs를 통한 디버깅 등을 직접 수행할 수 있는 사람이라면 중급 이상은 된다고 생각하면 될 것 같다. 현재까진 고급 주제를 다루는 완전 심화반은 열리지 않은 것으로 알고있다.\n리뷰 하는 이유 초반에 말했듯 시스템 \u0026amp; OS 관련 강의는 정말 찾아보기 힘들다. 대학교 강의를 제외하고는 기업 내부 초청 강연, 제품 홍보나 관련 협회의 교육이 거의 전부다. (물론 다른 IT관련 학원에도 그나마 관련된 강좌가 있겠지만, 입학생들에게 일단 전화걸고 보는 악명높은 학원은 당연히 고려대상에서 제외했다.) 웹, 모바일 어플리케이션 개발, 요새 뜨는 트렌드 관련 교육은 생활코딩, 인프런 등 무료나 저렴한 가격으로도 수강할 수 있다. 이런 시스템 \u0026amp; OS 관련 분야 강의가 더 많아져서 전체적인 파이가 커 지길 바라는 마음에 리뷰를 작성했다.\n","description":"","id":45,"section":"posts","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"https://devlog.jsyoo5b.net/ko/posts/review/lecture-reallinux-kernels/"},{"content":"GUI 기반으로 작성한 프로그램은 직관적이지만, 해당 기능을 사용하기 위해 마우스를 사용해야 하며, 이로 인해 자동화하기 어렵다는 문제점이 있다. 물론 매크로 등을 활용할 수 있지만, 사람이 직접 수행하지 않을 뿐, 결국 프로그램으로 마우스 클릭 등을 반복하는 것이다.\nGUI 기반으로 개발된 파일을 변환해주는 프로그램들을 CI/CD 과정에 사용하려 한다고 가정해보자.\n GUI를 실행하기 위한 Desktop Environment가 없는 Container/Build server일 수 있다. GUI가 있는 환경이라도, 해당 환경에 맞춰 매크로를 기록해야 한다. 매크로를 사용해도 Build server에 RDP 등으로 접속 시, 해상도 변경, 좌표 변경 등 이슈가 발생한다. 여러 GUI 기반 프로그램들을 실행할 때, 마우스 위치가 점유 자원으로서 병렬성을 방해한다. 해당 프로그램의 실행 결과도 GUI로 나타나므로, 이를 쉽게 확인할 수 없다.  위의 상황은 극단적으로 가정한 것이지만, 최소 1개 이상 실제 문제가 될 것이라 예상한다.\n목표  Window Manager(Windows Explorer, Gnome 등)나 Shell(Bash, Command Prompt 등)에서 실행 시, GUI 환경으로 실행 Shell에서 실행할 때 특정 인자를 입력하면(혹은 Windows Manager의 Shortcut에 인자 추가) GUI를 띄우지 않고,\n해당 인자에 따라 기능을 수행한 뒤 종료. 필요에 따라 진행 과정에 대한 Log를 출력한다. 해당 프로그램의 성공/실패 여부에 따라 확인할 수 있게 Error code를 반환하며 종료한다.  위의 목표를 개발자 기준의 요구사항으로 해석하면 아래와 같다.\n 기존의 GUI 실행에 관련된 코드를 뒤엎지 않고 기능을 추가해야 한다. 해당 프로그램 실행의 인자를 읽고, 특정 조건 시 GUI를 실행시키는 함수를 호출하지 않아야 한다. stdio (특히 stdout, stderr)가 해당 프로그램을 실행시킨 shell과 연결되어 있어야 한다. GUI를 실행시키지 않은 상태에서 원하는 exit code로 프로그램을 종료시켜야 한다. MFC같이 안 좋은 GUI framework에서 개발해야 한다.  진단 이제 MFC 프로그램을 작성하고, Shell에서 실행시켜보자. MFC 응용 프로그램 프로젝트를 ConsoleGuiTool로 가정하겠다. (대화 상자 기반으로 작성하였으나, 다른 종류도 크게 문제되지 않는다.) 빌드하고 Command Prompt에서 실행시켜보면 아래 스크린샷과 같은 상황을 확인할 수 있을 것이다.\n분명 해당 프로그램이 종료되지 않았음에도 Shell과의 연결이 끊어졌다. 요구사항 3, 4의 상황에서 문제가 생길 수 있다. (자세한 설명은 Command Prompt 명령어 설명에서 다루도록 한다.)\nConsole 실행 모드 추가하기 일단 수정해야 할 파일은 현재 MFC 프로그램의 진입점 부분이다. CWinApp을 상속하고 있는 클래스의 소스 코드를 찾자. (특별히 이름을 변경하지 않았다면, 프로젝트 이름과 같은 *.h, *.cpp일 것이다.)\nConsoleGuiTool.h ConsoleGuiTool.cpp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // ConsoleGuiTool.h : main header file for the PROJECT_NAME application //  #pragma once  #ifndef __AFXWIN_H__ \t#error \u0026#34;include \u0026#39;stdafx.h\u0026#39; before including this file for PCH\u0026#34; #endif  #include \u0026#34;resource.h\u0026#34;\t// main symbols // CConsoleGuiToolApp: // See ConsoleGuiTool.cpp for the implementation of this class //  class CConsoleGuiToolApp : public CWinApp { public: CConsoleGuiToolApp(); // Overrides public: virtual BOOL InitInstance(); // Implementation  DECLARE_MESSAGE_MAP() }; extern CConsoleGuiToolApp theApp;     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  // ConsoleGuiTool.cpp : Defines the class behaviors for the application. //  #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;ConsoleGuiTool.h\u0026#34;#include \u0026#34;ConsoleGuiToolDlg.h\u0026#34; #ifdef _DEBUG #define new DEBUG_NEW #endif  // CConsoleGuiToolApp  BEGIN_MESSAGE_MAP(CConsoleGuiToolApp, CWinApp) ON_COMMAND(ID_HELP, \u0026amp;CWinApp::OnHelp) END_MESSAGE_MAP() // CConsoleGuiToolApp construction  CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, \t// Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object  CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization  BOOL CConsoleGuiToolApp::InitInstance() { // InitCommonControlsEx() is required on Windows XP if an application \t// manifest specifies use of ComCtl32.dll version 6 or later to enable \t// visual styles. Otherwise, any window creation will fail. \tINITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // Set this to include all the common control classes you want to use \t// in your application. \tInitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(\u0026amp;InitCtrls); CWinApp::InitInstance(); // Create the shell manager, in case the dialog contains \t// any shell tree view or shell list view controls. \tCShellManager *pShellManager = new CShellManager; // Activate \u0026#34;Windows Native\u0026#34; visual manager for enabling themes in MFC controls \tCMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // Standard initialization \t// If you are not using these features and wish to reduce the size \t// of your final executable, you should remove from the following \t// the specific initialization routines you do not need \t// Change the registry key under which our settings are stored \t// TODO: You should modify this string to be something appropriate \t// such as the name of your company or organization \tSetRegistryKey(_T(\u0026#34;Local AppWizard-Generated Applications\u0026#34;)); CConsoleGuiToolDlg dlg; m_pMainWnd = \u0026amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) { // TODO: Place code here to handle when the dialog is \t// dismissed with OK \t} else if (nResponse == IDCANCEL) { // TODO: Place code here to handle when the dialog is \t// dismissed with Cancel \t} else if (nResponse == -1) { TRACE(traceAppMsg, 0, \u0026#34;Warning: dialog creation failed, so application is terminating unexpectedly.\\n\u0026#34;); TRACE(traceAppMsg, 0, \u0026#34;Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\u0026#34;); } // Delete the shell manager created above. \tif (pShellManager != NULL) { delete pShellManager; } // Since the dialog has been closed, return FALSE so that we exit the \t// application, rather than start the application\u0026#39;s message pump. \treturn FALSE; }       'use strict'; var containerId = JSON.parse(\"\\\"7d7c0dce70fe2926\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  해당 class에 기존 GUI환경의 init을 담당할 InitGuiWindow()와 콘솔모드로 실행할 RunConsole() 함수를 추가한다. 이후 기존의 InitInstance()함수를 InitGuiWindow()로 교체하고, 새로운 InitInstance()를 아래와 같이 작성한다.\nConsoleGuiTool.h ConsoleGuiTool.cpp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // ConsoleGuiTool.h : main header file for the PROJECT_NAME application //  #pragma once  #ifndef __AFXWIN_H__ \t#error \u0026#34;include \u0026#39;stdafx.h\u0026#39; before including this file for PCH\u0026#34; #endif  #include \u0026#34;resource.h\u0026#34;\t// main symbols // CConsoleGuiToolApp: // See ConsoleGuiTool.cpp for the implementation of this class //  class CConsoleGuiToolApp : public CWinApp { public: CConsoleGuiToolApp(); // Overrides public: virtual BOOL InitInstance(); // Implementation  DECLARE_MESSAGE_MAP() BOOL InitGuiWindow(); BOOL RunConsole(); }; extern CConsoleGuiToolApp theApp;     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  // ConsoleGuiTool.cpp : Defines the class behaviors for the application. //  #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;ConsoleGuiTool.h\u0026#34;#include \u0026#34;ConsoleGuiToolDlg.h\u0026#34; #ifdef _DEBUG #define new DEBUG_NEW #endif  // CConsoleGuiToolApp  BEGIN_MESSAGE_MAP(CConsoleGuiToolApp, CWinApp) ON_COMMAND(ID_HELP, \u0026amp;CWinApp::OnHelp) END_MESSAGE_MAP() // CConsoleGuiToolApp construction  CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, \t// Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object  CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() { int nArgCnt = __argc; if (nArgCnt == 1) { return InitGuiWindow(); } else { return RunConsole(); } } BOOL CConsoleGuiToolApp::InitGuiWindow() { // InitCommonControlsEx() is required on Windows XP if an application \t// manifest specifies use of ComCtl32.dll version 6 or later to enable \t// visual styles. Otherwise, any window creation will fail. \tINITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // Set this to include all the common control classes you want to use \t// in your application. \tInitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(\u0026amp;InitCtrls); CWinApp::InitInstance(); // Create the shell manager, in case the dialog contains \t// any shell tree view or shell list view controls. \tCShellManager *pShellManager = new CShellManager; // Activate \u0026#34;Windows Native\u0026#34; visual manager for enabling themes in MFC controls \tCMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // Standard initialization \t// If you are not using these features and wish to reduce the size \t// of your final executable, you should remove from the following \t// the specific initialization routines you do not need \t// Change the registry key under which our settings are stored \t// TODO: You should modify this string to be something appropriate \t// such as the name of your company or organization \tSetRegistryKey(_T(\u0026#34;Local AppWizard-Generated Applications\u0026#34;)); CConsoleGuiToolDlg dlg; m_pMainWnd = \u0026amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) { // TODO: Place code here to handle when the dialog is \t// dismissed with OK \t} else if (nResponse == IDCANCEL) { // TODO: Place code here to handle when the dialog is \t// dismissed with Cancel \t} else if (nResponse == -1) { TRACE(traceAppMsg, 0, \u0026#34;Warning: dialog creation failed, so application is terminating unexpectedly.\\n\u0026#34;); TRACE(traceAppMsg, 0, \u0026#34;Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\u0026#34;); } // Delete the shell manager created above. \tif (pShellManager != NULL) { delete pShellManager; } // Since the dialog has been closed, return FALSE so that we exit the \t// application, rather than start the application\u0026#39;s message pump. \treturn FALSE; } BOOL CConsoleGuiToolApp::RunConsole() { printf(\u0026#34;Program is running in console mode\\n\u0026#34;); Sleep(5000); printf(\u0026#34;It seems program did some job, 5 second passed\\n\u0026#34;); return FALSE; }       'use strict'; var containerId = JSON.parse(\"\\\"416bcbf92a9cf8ca\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  일단 콘솔 모드 진입 조건은 실행파일 뒤에 인자가 하나라도 붙는 것으로 설정했다. 콘솔 모드 진입시, 콘솔 모드로 실행된다는 메시지를 출력하고, 5초 이후 무언가 완료되었다고 하고 종료되게 설정하였다. 빌드하고 Command Prompt에서 실행시켜보면 아래 스크린샷과 같은 상황을 확인할 수 있을 것이다.\n일단 실행 인자 옵션에 따라 기존 GUI 구동을 유지한 상태에서, 콘솔 모드 실행에 성공했다. 하지만 printf()를 통한 메시지 출력이 되지 않는 것을 확인할 수 있다.\n프로그램을 실행시킨 shell과 stdio 연결 해당 증상의 원인은 MFC 프로그램 실행 시, stdio가 기존 shell에서 떨어지기 때문이다. MFC 프로그램을 실행시킨 부모 프로세스(Command Prompt 혹은 PowerShell)의 stdio와 연결해야한다. 기존의 RunConsole() 함수를 아래와 같이 수정한다. (코드 상단에 #include \u0026lt;iostream\u0026gt;을 해야한다.)\nConsoleGuiTool.cpp  114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135  BOOL CConsoleGuiToolApp::RunConsole() { if (AttachConsole(ATTACH_PARENT_PROCESS)) { FILE *pfStdin; FILE *pfStdout; FILE *pfStderr; freopen_s(\u0026amp;pfStdin, \u0026#34;CONIN$\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen_s(\u0026amp;pfStdout, \u0026#34;CONOUT$\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen_s(\u0026amp;pfStderr, \u0026#34;CONOUT$\u0026#34;, \u0026#34;w\u0026#34;, stderr); std::cin.clear(); std::cout.clear(); std::cerr.clear(); } printf(\u0026#34;Program is running in console mode\\n\u0026#34;); Sleep(5000); printf(\u0026#34;It seems program did some job, 5 second passed\\n\u0026#34;); return FALSE; }       'use strict'; var containerId = JSON.parse(\"\\\"4b4fb0e97c146462\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  L116~128의 내용은 부모 프로세스의 콘솔에 연결하고 stdin, stdout, stderr를 다시 여는 작업을 수행한다.\n임의의 Exit Code로 종료시키기 원칙적으로는 main() 함수의 return 값으로 exit code를 보내는 것이 정석이나, 우리가 현재 수정 가능한 코드 범위에서는 main() 함수를 수정할 수 없기 때문에 차선책인 exit() 함수를 사용하면 된다.\nstdin의 연결 상태를 확인할 겸, 아래와 같이 RunConsole() 함수를 수정한다.\nConsoleGuiTool.cpp  114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  BOOL CConsoleGuiToolApp::RunConsole() { int nExitCode; if (AttachConsole(ATTACH_PARENT_PROCESS)) { FILE *pfStdin; FILE *pfStdout; FILE *pfStderr; freopen_s(\u0026amp;pfStdin, \u0026#34;CONIN$\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen_s(\u0026amp;pfStdout, \u0026#34;CONOUT$\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen_s(\u0026amp;pfStderr, \u0026#34;CONOUT$\u0026#34;, \u0026#34;w\u0026#34;, stderr); std::cin.clear(); std::cout.clear(); std::cerr.clear(); } printf(\u0026#34;Program is running in console mode\\n\u0026#34;); Sleep(5000); printf(\u0026#34;It seems program did some job, 5 second passed\\n\u0026#34;); printf(\u0026#34;Enter exit code to get: \u0026#34;); std::cin \u0026gt;\u0026gt; nExitCode; exit(nExitCode); return FALSE; }       'use strict'; var containerId = JSON.parse(\"\\\"bcabea5db80ca3eb\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위 목표를 모두 달성했다. 이제 실행인자를 잘 입력 받았는지 확인하고, 이를 비교하기만 하면 된다.\n실행 인자 사용을 위한 추가 설명 이전의 설명은 CWinApp::InitInstance() 메서드를 수정하여 GUI를 띄우지 않고 콘솔에서 입출력을 수행하는 부분을 설명했다. 실행 인자를 입력받는 방법은 __argc, __argv, __wargv 전역변수를 활용한다. 해당 변수는 stdlib.h에서 제공하며, Microsoft에서만 제공하는 확장 기능이다. (C,C++ 표준이 아님) (Multi-Byte Character Set으로 빌드한 경우 __argv를, Unicode Character Set으로 빌드한 경우 __wargv를 사용)\n이외에도 GetCommandLine(), CWinApp::ParseCommandLine() 등의 방법으로도 실행 인자를 얻을 수 있다. 이 중 ParseCommandLine()에서 사용하는 CCommandLineInfo는 Windows에서 제공하는 기능의 일부를 해석해준다.\nCommand Prompt 명령어 설명 사실 Windows에서 제공하는 Command Prompt, PowerShell에서 GUI를 사용하는 프로그램을 실행시키면 자동으로 해당 shell에서 detach하게 되어있다. 현재 수정한 방식은 GUI를 화면에 출력하기 전에 기능을 수행하고 종료시킨 것이므로, 똑같이 shell에서 detach하게 되어있다.\nCommand Prompt에서 콘솔 모드 사용을 위해서는 아래와 같은 옵션을 고려해야 한다.\nCommand Prompt  \u0026gt; start /wait \\\u0026lt;PROGRAM\\\u0026gt;     'use strict'; var containerId = JSON.parse(\"\\\"97256879bd5deea9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  \u0026lt;PROGRAM\u0026gt;을 실행시키고, 해당 \u0026lt;PROGRAM\u0026gt;이 종료될 때 까지 기다린다.\nCommand Prompt  \u0026gt; cmd /v:on /c \u0026#34;echo !time! ...     'use strict'; var containerId = JSON.parse(\"\\\"20d91fd0c8b879c4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Batch file을 실행할 때, 환경변수 등은 %VAR%를 통해 그 값으로 치환할 수 있다. 하지만 위 예시와 같이 프로그램의 실행 시간을 측정하기 위해 한 명령행 안에 %VAR%로 넣을 경우, 즉시 치환된다.\n(!time! 대신 %time%로 입력 시, 실제 소요시간과 관계없이 같은 시간이 나타난다.) 해당 변수에 접근하는 순간 치환되길 원한다면, 위와 같이 !VAR!로 표기해야 한다. 또한 위와 같은 delayed environment variable expansion을 사용하려면 현재 콘솔에 옵션을 설정하거나 cmd로 실행시킬 때, /v:on 옵션을 주고 실행시켜야 한다.\n해설 C/C++로 작성한 프로그램의 기본 진입점은 main()함수이다. main()함수의 매개변수로 int argc, char** argv를 사용하여 실행 인자를 프로그램 내에서 확인할 수 있다.\n하지만 MFC로 프로젝트를 생성할 경우, main()함수를 개발자가 직접 편집할 수 없다. 이전의 코드에서 봤던 것 처럼 개발자가 수정 가능한 프로그램의 최초 진입 지점은 CWinApp::InitInstance() 메서드이다.\nmain()함수 역할을 수행하는 WinAPI에서 제공하는 진입점은 _tWinMain() 함수이다. MFC에서 작성된 _tWinMain()함수의 정의는 VC\\atlmfc\\src\\mfc\\appmodul.cpp에서 확인할 수 있다.\nVC\\atlmfc\\src\\mfc\\appmodul.cpp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // This is a part of the Microsoft Foundation Classes C++ library. // Copyright (C) Microsoft Corporation // All rights reserved. // // This source code is only intended as a supplement to the // Microsoft Foundation Classes Reference and related // electronic documentation provided with the library. // See these sources for detailed information regarding the // Microsoft Foundation Classes product.  #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;sal.h\u0026#34; ///////////////////////////////////////////////////////////////////////////// // export WinMain to force linkage to this module extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow); extern \u0026#34;C\u0026#34; int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow) #pragma warning(suppress: 4985) { // call shared/exported WinMain \treturn AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow); } ///////////////////////////////////////////////////////////////////////////// // initialize app state such that it points to this module\u0026#39;s core state  BOOL AFXAPI AfxInitialize(BOOL bDLL, DWORD dwVersion) { AFX_MODULE_STATE* pModuleState = AfxGetModuleState(); pModuleState-\u0026gt;m_bDLL = (BYTE)bDLL; ASSERT(dwVersion \u0026lt;= _MFC_VER); UNUSED(dwVersion); // not used in release build #ifdef _AFXDLL \tpModuleState-\u0026gt;m_dwVersion = dwVersion; #endif :       'use strict'; var containerId = JSON.parse(\"\\\"3024ead4c369efec\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  _tWinMain()에서 호출하는 AfxWinMain()의 정의는 VC\\atlmfc\\src\\mfc\\winmain.cpp에서 확인할 수 있다.\nVC\\atlmfc\\src\\mfc\\winmain.cpp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  // This is a part of the Microsoft Foundation Classes C++ library. // Copyright (C) Microsoft Corporation // All rights reserved. // // This source code is only intended as a supplement to the // Microsoft Foundation Classes Reference and related // electronic documentation provided with the library. // See these sources for detailed information regarding the // Microsoft Foundation Classes product.  #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;sal.h\u0026#34; ///////////////////////////////////////////////////////////////////////////// // Standard WinMain implementation // Can be replaced as long as \u0026#39;AfxWinInit\u0026#39; is called first  int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow) { ASSERT(hPrevInstance == NULL); int nReturnCode = -1; CWinThread* pThread = AfxGetThread(); CWinApp* pApp = AfxGetApp(); // AFX internal initialization \tif (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow)) goto InitFailure; // App global initializations (rare) \tif (pApp != NULL \u0026amp;\u0026amp; !pApp-\u0026gt;InitApplication()) goto InitFailure; // Perform specific initializations \tif (!pThread-\u0026gt;InitInstance()) { if (pThread-\u0026gt;m_pMainWnd != NULL) { TRACE(traceAppMsg, 0, \u0026#34;Warning: Destroying non-NULL m_pMainWnd\\n\u0026#34;); pThread-\u0026gt;m_pMainWnd-\u0026gt;DestroyWindow(); } nReturnCode = pThread-\u0026gt;ExitInstance(); goto InitFailure; } nReturnCode = pThread-\u0026gt;Run(); InitFailure: #ifdef _DEBUG \t// Check for missing AfxLockTempMap calls \tif (AfxGetModuleThreadState()-\u0026gt;m_nTempMapLock != 0) { TRACE(traceAppMsg, 0, \u0026#34;Warning: Temp map lock count non-zero (%ld).\\n\u0026#34;, AfxGetModuleThreadState()-\u0026gt;m_nTempMapLock); } AfxLockTempMaps(); AfxUnlockTempMaps(-1); #endif  AfxWinTerm(); return nReturnCode; } /////////////////////////////////////////////////////////////////////////////       'use strict'; var containerId = JSON.parse(\"\\\"ba13e773ba70248b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  AfxGetApp()를 통해 개발자가 정의한 Application 변수의 주소를 얻고, 해당 변수에서 InitInstance() 메서드를 호출한다. 해당 함수는 개발자가 재정의할 수 있으며, 우리는 이 InitInstance()함수를 수정하여 MFC dialog를 띄우지 않고 콘솔에서 처리할 수 있도록 변형한 것이다.\nConsoleGuiTool.cpp  20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  : // CConsoleGuiToolApp construction  CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, \t// Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object  CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() :       'use strict'; var containerId = JSON.parse(\"\\\"8a47e005308c33b9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  다른 GUI framework에서의 진입점 (main 함수) 아래는 각 C/C++로 작성된 GUI framework의 진입점이다. 대부분의 GUI framework는 main() 함수를 편집할 수 있다.\nWxWidget은 MFC와 같이 main() 함수를 편집할 수 없으므로, wxApp이 제공하는 메서드를 사용해야 한다.\nQT GTK\u0026#43; FLTK  #include \u0026lt;QApplication\u0026gt;#include \u0026lt;QCommandLineParser\u0026gt;#include \u0026lt;QCommandLineOption\u0026gt; #include \u0026#34;mainwindow.h\u0026#34; int main(int argc, char *argv[]) { Q_INIT_RESOURCE(application); QApplication app(argc, argv); QCoreApplication::setOrganizationName(\u0026#34;QtProject\u0026#34;); QCoreApplication::setApplicationName(\u0026#34;Application Example\u0026#34;); QCoreApplication::setApplicationVersion(QT_VERSION_STR); QCommandLineParser parser; parser.setApplicationDescription(QCoreApplication::applicationName()); parser.addHelpOption(); parser.addVersionOption(); parser.addPositionalArgument(\u0026#34;file\u0026#34;, \u0026#34;The file to open.\u0026#34;); parser.process(app); MainWindow mainWin; if (!parser.positionalArguments().isEmpty()) mainWin.loadFile(parser.positionalArguments().first()); mainWin.show(); return app.exec(); }   #include \u0026lt;gtk/gtk.h\u0026gt; #include \u0026#34;gtk_app.h\u0026#34; int main (int argc, char **argv) { GtkApplication *app; int status; app = gtk_application_new (\u0026#34;org.gtk.example\u0026#34;, G_APPLICATION_FLAGS_NONE); g_signal_connect (app, \u0026#34;activate\u0026#34;, G_CALLBACK (activate), NULL); status = g_application_run (G_APPLICATION (app), argc, argv); g_object_unref (app); return status; }   #include \u0026lt;FL/Fl.H\u0026gt;#include \u0026lt;FL/Fl_Window.H\u0026gt;#include \u0026lt;FL/Fl_Button.H\u0026gt; int main(int argc, char *argv[]) { Fl_Window* w = new Fl_Window(330, 190); new Fl_Button(110, 130, 100, 35, \u0026#34;Okay\u0026#34;); w-\u0026gt;end(); w-\u0026gt;show(argc, argv); return Fl::run(); }     'use strict'; var containerId = JSON.parse(\"\\\"b28971230c3f74eb\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  참고 링크 [1] MFC 기본코드 분석(https://petra.tistory.com/1296)\n","description":"","id":46,"section":"posts","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"https://devlog.jsyoo5b.net/ko/posts/mfc/console-mode/"},{"content":"이전의 네트워크는 뭐가 불만족스러웠길래? 처음 집 안의 네트워크를 뜯어고치게 된 원인은 아래와 같다.\n IPTV를 사용하고 있다. (셋톱박스가 필요하다.) 셋톱박스는 유선연결만 지원한다. 공유기는 거실에 있다. (셋톱박스가 거실 TV에 붙어 있기 때문에) 내 방에서 유선으로 컴퓨터를 쓰고 싶다. 내가 인터넷 쓸 때 셋톱박스에 영향을 주지 않았으면 좋겠다.  내가 게임 다운받는다고 3Mbps 이상의 대역폭을 사용하면 IPTV 화면이 멈추고 소리만 나오는 등의 문제가 있었다. 결국 나는 다운로드 대역폭을 낮추거나, 밤에 잘 때 대역폭을 높여 써야 하는 상황이었다. 밤에 잘 때도 WiFi로 연결되어 있기 때문에 최대 대역폭도 낮은 편이었다.\n이러느니 그냥 내 방에 공유기를 하나 따로 설치해서 쓰는게 낫겠다 생각해서 공유기를 사왔으나, 해당 공유기를 쓸 수 없었다. 이유는 간단하다. 각 벽에 있는 랜선 벽단자 중 거실에 있는 랜선 벽단자만 살아있기 때문이었다.\n통신 단자함 통신 단자함은 인터넷 배선(혹은 TV 케이블도)을 선택할 수 있는 박스를 말한다. 통신 단자함 박스는 보통 집 안(전력 차단기 근처) 혹은 바깥(집 근처 복도 쪽) 벽에 매설되어있다. (건물 상황에 따라서 IDF 단자함이라 한다.)\n출처: https://extrememanual.net/10935\n2010년대 이후에 지어진 건물은 아마도 위와 같은 형태의 통신 단자함으로 되어 있을 것이다. (초고속정보통신건물 인증제도 덕분에 일반화 된 것으로 알고 있다.) 단자함 내부에 RJ45포트로 연결할 수 있고, 내부에 스위칭 허브를 넣을 공간과 콘센트도 있다.\n한편 그 이전에 지어진 건물의 경우 위와 같은 형태의 통신 단자함을 볼 수 있을 것이다.(우리 집이 이 형태를 사용한다.) 이 단자함보다 더 이전 버전도 존재하지만, 2000년대에 인터넷 고속화 과정에서 대부분 위와 같이 변경되었을 것이다. 여기에 연결된 부분은 110 블럭이라 한다.\n(참고로 신형 통신 단자함 뒷편의 케이블 연결, 랜선 벽단자의 케이블 연결 부분은 키스톤 잭이라 한다.)\n위 사진은 다른 상태지만, 보통 외부 인터넷선(국선)과 집 안에 있는 방 중 1곳(우리 집의 경우, 거실)과 연결하게 되어있다. 즉, 다른 방의 랜선 벽단자는 연결이 끊겨 있는 상태이기 때문에 아무리 공유기를 연결하고 설정을 변경해도 인터넷이 안 되는 것이다. 현재 통신 단자함은 구형이라서 안에 스위칭 허브를 넣을 공간도 없고, 전원도 공급받을 수 없기 때문에 랜선 벽단자는 여전히 1개만 사용 가능했다.\n사실 신형 통신 단자함도 똑같이 110 블럭을 사용할 수도 있다. 통신 단자함 안에 스위칭 허브를 넣을 만큼의 공간적 여유, 콘센트 여부를 가지고 신형과 구형을 구분하면 될 것이다.\n그 외 다른 문제들 통신 단자함에서 외부 인터넷선과 거실 랜선 벽단자 사이 연결은 4가닥으로 되어있었다. 이론 상 4선만으로도 이더넷 사용은 가능하지만, 기가급 인터넷 사용을 위해선 8가닥으로 늘려줘야 했다.\n게다가 확인해보니 거실에서 연결된 공유기가 오래된 공유기라서 대역폭 관리를 잘 못하는 것이 확인되어, 이를 새로 산 신형 공유기로 교체하였다.\n편법으로 랜선 끌어오기 통신 단자함을 통해 각 랜선 벽단자가 연결되는 방식을 알아냈으므로, 간접적으로 랜선을 끌어 올 수 있는 방법이 생겼다.\n이더넷 선은 방향을 따지지 않으므로 (엄밀히 말하면 네트워크 장비와 단말 장비 간 방향을 따지긴 하나, 이를 자동으로 감지해서 변경하는 기능이 지원된다.) 가까운 방(Room2)의 랜선 벽단자를 출력 용도가 아닌 입력 용도로 사용한다. 통신 단자함에서는 Room2와 Room1을 연결해버리면 긴 랜선을 통해 최종적으로 내 방(Room1) 랜선 벽단자를 사용할 수 있다. (공유기에서 직접 연결된 회선으로) 그림에 보이는 집 구조처럼 내 방으로 직접 끌고 올 경우 바닥에 선이 걸리는데, 가까운 방으로 돌리면 최대한 벽에 붙여, 발에 걸리지 않게 할 수 있다.\n여전히 뭔가 불만족스러운데? 이전까지의 설명은 2019년 7월쯤 완료된 상태를 설명한 것이다. 하지만 여전히 불만족스러운 점이 있었다.\n 랜선에 연결하고 싶은 장비들은 다 내 방에 있는데 공유기는 여전히 거실에 있다. (장비가 늘어났음) 긴 랜선이 거실의 공유기에서 출발해서 다른 방으로 타고 들어간다. (최대한 안 보이게 하긴 했지만 여전히 거슬림) 공유기 설정 바꾸거나 재시작할때 셋톱박스가 영향을 받는다. (인터넷 망에서 IPTV를 분리해버리고 싶다)  이 문제를 해결하는 방법은 다음과 같았다.\n 스위칭 허브를 구매하여 외부 인터넷선에서 IPTV용, 공유기용으로 분리해버린다. 기존 거실의 랜선 벽단자는 셋톱박스만 연결한다. 공유기를 내 방에 설치한다. (셋톱박스의 연결만 해결되면 공유기가 굳이 거실에 있을 필요 없음)  문제는 스위칭 허브를 설치하기에 우리집 통신 단자함은 구형 통신단자함이므로 스위칭 허브를 밖에서 연결하고도 거실 랜선 벽단자로 회선 연결을 해야 했다. 또한 이전에 회선을 추가한 것과 달리 국선을 변경하는 작업, 랜선 벽단자를 건드리기 때문에 인터넷이 안 될 수도 있다. 나는 작업을 하고 있을테니 인터넷 접속 여부가 상관없지만, 부모님은 TV도 안되고 인터넷도 안되면 집에서 할 수 있는게 많이 줄어들기 때문에, 부모님이 집을 오랫동안 비울 때를 기다렸다.\n관로포설 관로포설은 벽 안에 선을 넣는 걸 말한다. 그러니깐 지금은 랜선 벽단자에 랜선이 1개만 연결되어 있는데, 선을 하나 더 추가하는 것이다. 2개 이상의 랜선을 꽂을 수 있는 벽단자를 찾던 중 아래와 같은 물건을 구입했다. 심지어 원하는 대로 랜선 단자와 TV케이블 단자 순서 등을 변경할 수 있는 물건이었다.\n그래서 내 방의 TV케이블 벽단자를 이걸로 교체하고, 내 방에서 거실 방향으로 관로포설하면 되겠다고 생각했다.\n하지만 TV케이블 벽단자를 뜯어본 뒤, 이 방법은 불가능한 것을 알게 되었다.\n 랜선 벽단자와 TV케이블 벽단자 내부가 이어져 있을줄 알았는데 각각 개별적인 박스로 구성되어있음. (뚫을 수 없는 두꺼운 플라스틱 재질) TV케이블 하나만 들어오는 줄 알았는데 릴레이 식으로 연결되어 있음. (TV케이블이 있을 공간이 필요함) 게다가 케이블이 통과하는 관로가 너무 좁아서 새로 추가가 불가능함.  어차피 IPTV보는데 TV케이블 뽑아버리면 되는거 아닐까 하는 생각도 잠시 들었었는데, 릴레이 식으로 연결되어 있는걸 봐선 다른 집으로도 연결되어 있을 가능성도 있을 것 같았고, 맘대로 뽑았다가 나중에 다시 복원시켜야 할 때는 답이 안 나오겠다 싶어서 결국 TV케이블쪽은 포기하고 기존 랜선 벽단자 안에 추가로 관로포설을 하기로 했다.\n확인해보니 내 방으로 들어오는 랜선 벽단자 내부에서 3개 선이 들어와서, 2개는 아까 room2, 거실쪽으로 배선되고, 짧은 하나만 내 방 벽단자로 연결되는 것이었다. 내 맘대로 이쪽 벽에서 저쪽 벽으로 보낼 수 있는 게 아니라, 이미 연결된 회선에 따라 가능/불가능 여부가 결정되는 것이었다. 내부적으로 튜브같은게 존재하는데, 이 튜브는 벽단자 - 벽단자 간에 연결되어 있고, 이 튜브 안에 랜선이 포설되어 있는 것이다.\n결국 내 방이 통신 단자함과 가장 가깝기 때문에, 그나마 랜선 추가가 가장 쉬운 상태였다. 기존 내 방과 통신단자함 사이에 연결된 랜선을 제거하고, 새로운 랜선 2개를 밀어넣었다. (접어서 2겹으로 밀어넣고, 반대편에서 가운데를 끊어버림으로서 2개를 넣음)\n관로포설, 통신 단자함 연결 시 주의사항 통신 단자함 내 각 단자 간 연결, 관로포설 시 해당 케이블이 단선인지, 연선인지 잘 확인해야 한다.\n출처: https://www.mirazon.com/network-cables-and-connectors-twisted-pair-cat5/\n대부분의 단선 케이블은 문제가 되지 않는다. 하지만 연선인 경우 문제가 되는데, 연선의 내부 두께가 얇기 때문에 110블럭/키스톤잭의 칼날이 연선의 전도체와 닿지 않을 수도 있다. 케이블이 칼날과 연결되지 않는데 단자 간 연결이나, 관로포설을 해 봤자 해당 케이블에서 전기가 흐르지 않기 때문에 단선된 상태와 똑같은 증상이 나타난다.\n각 선이 단선인지 연선인지 자르지 않고 구분하는 편법은 다음과 같다.\n 작업용 케이블(200m 이상 단위의 박스로 파는 케이블, 보통 길이만큼 잘라서 사용)은 단선일 가능성이 높다. 편의점, 할인마트 등에서 구매할 수 있는 케이블(대부분 5m~30m)은 연선일 가능성이 높다. 연선의 경우 내부 두께가 얇은 편이므로, 케이블 피복과 내부 선 사이에 공간이 많이 남는 편이다. 해당 케이블을 접거나 굽히는 등 모양을 만든 뒤, 해당 모양이 어느 정도 잘 유지되면 단선일 가능성이 높다.  통신 단자함 재배치 이후 통신 단자함에 새로 추가한 랜선을 꽂을 110 블럭을 배치했다.\n뽑아서 옮기는 와중에 110 블럭이 부러지는 일이 일어나긴 했다. 원래는 110블럭을 뽑거나 끼우는데 사용하는 전용 도구가 있는데, 그냥 펜치로 뽑고 끼우다가 틀어져서 부러졌다.\n공유기 배치 공유기는 거실쪽에서도 신호가 잘 닿도록 문 방향으로 배치했다.\n","description":"","id":47,"section":"posts","tags":["관로포설","DIY","네트워크"],"title":"집안 네트워크 뒤집어 놓기","uri":"https://devlog.jsyoo5b.net/ko/posts/infrastructure/changing-home-network/"},{"content":"정규표현식은 특정한 규칙을 지닌 문자열의 집합에 대한 표현식이다. 정규표현식이 사용될 예시는 아래와 같다.\n E-mail 주소(abcd@efg.com) 형태의 문자열인지 확인하고 mailto: 처리를 하려 할 때 어떤 프로그램의 로그 파일 중 특정 이벤트나 메시지만을 필터링 하려는 경우 IDE의 도움 없이 코드에서 특정 변수만 이름을 변경하고자 하는 경우  위와 같이 주어진 문자열 속에서(대부분 긴) 내가 원하는 문자열을 패턴화 시켜 추출해내고, 교체할 수 있게 해 준다. 거의 대부분의 프로그래밍 언어는 정규표현식 기능을 제공한다.\n기초 정규표현식 본 포스트에서는 문자열 추출을 위해 필요한 가장 기초적인 기호 및 사용법에 대하여 설명한다. 좀 더 효율적으로 표현하기 위해 중요한 기술이나, 치환 등에 필요한 내용은 다음 포스트에서 다루도록 하겠다. 아래에서 설명하는 정규표현식의 표현법은 프로그래밍 언어, 환경마다 다를 수 있다. $var 는 변수를 표현하기 위함이다. 해당 문자열에 $가 포함된다는 뜻이 아니다.\n1. 리터럴 문자 기초적인 문자(일부 특수 기호)를 표현한다.\n   기호 의미 예시 / 추가 설명     $text $text 문자열 그대로 추출 /LINE/ -\u0026gt; INLINE 일치   \\t | \\v 수평 | 수직 방향 탭 을 표현함 예시 / 추가 설명 불필요   \\r 캐리지 리턴을 표현함 예시 / 추가 설명 불필요   \\n 줄넘김 (개행 문자) 을 표현함 예시 / 추가 설명 불필요   \\f 페이지 넘김을 표현함 예시 / 추가 설명 불필요   \\\\ 역슬래시 문자를 표현 예시 / 추가 설명 불필요   \\x$HX 16진수 $HX 의 값을 추출 /\\x61/ -\u0026gt; abcab 일치 (0x61 == \u0026lsquo;a\u0026rsquo;)   \\0$OCT 8진수 $OCT 의 값을 추출 예시 / 추가 설명 불필요    위의 표에 나와있는 항목 외에도 정규표현식에서 사용하는 특수문자들을 리터럴 값으로 표현하기 위해 \\로 escape를 사용한다. 하지만 정규표현식을 사용하는 환경에 따라 escape를 한 것을 리터럴로 취급하는지 혹은 반대인지 차이가 있을 수 있다.\n2. 문자 클래스 1개의 문자를 추출하기 위해, 비슷한 부류의 문자들을 종류에 따라 묶어 표현한다.\n   기호 의미 예시 / 추가 설명     [$keys] $keys에 속하는 모든 문자 /[01234]/ -\u0026gt; \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;4\u0026rsquo; 일치   [$a-$b] $a에서 $b 범위에 속하는 모든 문자 /[0-4]/ == /[01234]/   [^$a] $a를 제외한 모든 문자 /[^0-9]/ -\u0026gt; 숫자를 제외한 모든 글자 일치   . 개행 문자를 제외한 모든 문자 예시 / 추가 설명 불필요   \\w 알파벳(대+소), 숫자, _에 해당하는 모든 문자 /\\w/ == /[A-Za-z0-9_]/   \\W 알파벳(대+소), 숫자, _를 제외한 모든 문자 /\\W/ == /[^A-Za-z0-9_]/   \\d 모든 숫자(0~9) 문자 /\\d/ == /[0-9]/   \\D 모든 숫자를 제외한 모든 문자 /\\D/ == /[^0-9]/   \\s 모든 빈칸(스페이스, 탭, 줄바꿈) 문자 /\\s/ == /[ \\t\\r\\n\\v\\f]/   \\S 모든 빈칸(스페이스, 탭, 줄바꿈)을 제외한 문자 /\\S/ == /[^ \\t\\r\\n\\v\\f]/    3. 수량자 수량자를 통해 패턴의 표현 횟수를 줄이거나, 유연하게 처리하게 할 수 있다.\n   기호 의미 예시 / 추가 설명     {$t} 앞의 표현식을 $t번 반복하는 부분을 추출 /[\\da-fA-F]{2}/ -\u0026gt; 2자리 16진수 일치   {$t,} 앞의 표현식을 $t번 이상 반복하는 부분을 추출 /\\d{5}/ -\u0026gt; 5자리 이상의 숫자 일치   {$s,$e} 앞의 표현식을 $s번 이상, $e번 이하 반복하는 부분을 추출 /\\d{3,5}/ -\u0026gt; 3~5자리의 숫자 일치   ? 앞의 표현식이 0번 혹은 1번 나타나는 부분을 추출 /https?/ -\u0026gt; http, https 일치   * 앞의 표현식이 0번 이상 나타나는 부분을 추출 /\\w*/ == \\w{0,}   + 앞의 표현식이 1번 이상 나타나는 부분을 추출 /\\d+/ == \\d{1,}    수량자에는 추가적으로 게으른 문자(lazy evaluation)라는 개념이 있는데 이는 나중에 따로 다루도록 하겠다.\n4. 그룹 조건 수량자를 표현식 단위로 적용하거나, 표현식 여러 개를 묶어 OR 연산을 할 수도 있다.\n   기호 의미 예시 / 추가 설명     ($exp) 표현식 $exp를 묶어 수량자 연산 등을 가능케 함 /(0x[\\da-fA-F]{2} ?)+/ -\u0026gt; 16진법 배열 일치   ($e1|$e2) 표현식 $e1 이나 $e2 중 해당하는 부분을 추출 (OR) /(Str|string)/ -\u0026gt; Str, string 일치    5. 위치 지정 문자열 추출시 위치에 대한 조건을 둘 수 있다. 여기에서 $는 변수를 뜻하는 것이 아니라 글자 \u0026lsquo;$\u0026lsquo;를 뜻하는 것이다. 여기에서 설명하는 문자열은 일반적으로 \\r 혹은 \\n으로 구분되는 문장을 뜻한다. 단어의 기준은 일반적으로 \\s (스페이스, 탭, 줄바꿈) 사이의 글자들을 말한다.\n   기호 의미 예시 / 추가 설명     ^ 문자열의 시작 부분 /^An/ -\u0026gt; 문자열의 시작의 An Ancestor 에서 맨 앞의 An만 일치   $ 문자열의 끝 부분 /er$/ -\u0026gt; 문자열의 끝의 better stronger 에서 맨 끝의 er만 일치   \\b 단어의 경계 /\\bor/ -\u0026gt; organ, inventor 는 일치하지만 bored는 일치하지 않음   \\B 단어의 중간 /\\Bor/ -\u0026gt; bored 는 일치하지만 organ, inventor는 일치하지 않음    정규표현식 관련 사이트  언어/환경별 정규표현식 표현 비교 표  영문 위키 \u0026ldquo;Regular Expression\u0026rdquo;   정규표현식 공부할 수 있는 사이트  regexone : 설명을 보고 아래 예제를 맞추는 방식으로 진행하는 형태 regexcrossword : 가로세로 퍼즐처럼 문제풀이 (확인용)   언어/환경별 정규표현식 실험 사이트  https://regexr.com/ (Javascript, PCRE) http://regexstorm.net/tester (.NET) http://www.regexplanet.com/advanced/java/index.html (Java)   정규표현식 자동 생성  txt2re : 문자열을 입력하면 각 부분마다 표현하기 위한 정규표현식을 자동 생성해줌    ","description":"","id":48,"section":"posts","tags":["정규표현식","문자열 처리"],"title":"정규표현식 기초","uri":"https://devlog.jsyoo5b.net/ko/posts/regex/basic/"},{"content":"모든 개발분야에 관심을 갖고 있으며, 특히 하드웨어, 운영체제, 프로그램의 동작 원리를 알고자 합니다. 본질적인(Low level) 기술을 잘 이해할 수록 다른 분야의 지식 습득도 수월하다 생각하기 때문입니다.\n학습에 있어서도 무분별하게 수긍하지 않고, 비판적으로 학습합니다. 다른 방법은 없는지, 왜 해당 방법이 대세가 되었는지 이해하려 합니다.\n경력 임베디드 SW 개발자 (2018년 1월 ~ 2021년 1월) Firmware 개발 (Xtensa LX6-based ASIC \u0026amp; ThreadX / PIC32)\n 제품 개발 및 시연용 EVM Controller 개발 내부 개발 및 고객사 지원용 Host Adapter 개발  PC Tool 개발 (Windows, MFC, WinUSB)\n 디지털 라디오 칩 기능 확인용 Monitoring Tool 개발 FW Image 생성, Update 등 제품 개발 관련 Tool 개발  웹 프로그래머 (2013년 4월 ~ 2014년 5월, 파트타임)  기존 Windows 기반 프로그램을 웹 환경에 이식  학력 한국항공대학교  컴퓨터공학과 석사 (2013.03 ~ 2016.08) 컴퓨터공학과 학사 (2009.03 ~ 2013.02)  ","description":"","id":49,"section":"","tags":null,"title":"소개","uri":"https://devlog.jsyoo5b.net/ko/about/"}]