[{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n14장. 포인터 포인터의 Go 언어에서의 특징만 확인해보자.\n 빈 포인터의 표기는 null이 아니라 nil로 표현한다. 구조체를 가리키는 포인터에서 해당 구조체의 필드 접근은 -\u0026gt;이 아니라 .으로 가능하다. call-by-address를 통해 함수의 인자를 전달, 수정할 수 있다. new()를 사용하여 인스턴스를 생성할 수 있다. 인스턴스를 가리키는 포인터가 없으면 가비지 컬렉터가 메모리를 회수한다. go 컴파일러에서 탈출 분석을 확인하여, 지역변수가 stack이 아니라 heap에 존재할 수 있다.  기본적인 포인터 사용 go 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package main import \u0026#34;fmt\u0026#34; type Data struct { value int data [10]int } func main() { var data1 Data var pData1 *Data = \u0026amp;data1 var pData2 *Data = \u0026amp;Data{}\t// Create instance with indirect addressing \tvar pData3 *Data = new(Data) // Create with new()  fmt.Printf(\u0026#34;\u0026amp;data1: %p\\n\u0026#34;, \u0026amp;data1) fmt.Printf(\u0026#34;pData1: %p,\\t\u0026amp;pData1: %p\\n\u0026#34;, pData1, \u0026amp;pData1) fmt.Printf(\u0026#34;pData2: %p,\\t\u0026amp;pData2: %p\\n\u0026#34;, pData2, \u0026amp;pData2) fmt.Printf(\u0026#34;pData3: %p,\\t\u0026amp;pData3: %p\\n\u0026#34;, pData3, \u0026amp;pData3) CallByValue(data1, 10) fmt.Println(data1) CallByAddress(\u0026amp;data1, 10) fmt.Println(data1) CallByValue(*pData1, 20) fmt.Println(pData1) CallByAddress(pData1, 20) fmt.Println(pData1) var pData4 *Data = nil pData4.value = 40\t// Trigger segfault } func CallByValue(data Data, n int) { data.value = n data.data[0] = n / 10 fmt.Printf(\u0026#34;Call-by-value \u0026amp;data: %p\\n\u0026#34;, \u0026amp;data) } func CallByAddress(data *Data, n int) { data.value = n data.data[0] = n / 10 fmt.Printf(\u0026#34;Call-by-address \u0026amp;data: %p\\n\u0026#34;, data) }    \r$ ./go_pointer_basics \u0026amp;data1: 0x140000b2000 pData1: 0x140000b2000, \u0026amp;pData1: 0x140000ac018 pData2: 0x140000b2060, \u0026amp;pData2: 0x140000ac020 pData3: 0x140000b20c0, \u0026amp;pData3: 0x140000ac028 Call-by-value \u0026amp;data: 0x140000b2120 {0 [0 0 0 0 0 0 0 0 0 0]} Call-by-address \u0026amp;data: 0x140000b2000 {10 [1 0 0 0 0 0 0 0 0 0]} Call-by-value \u0026amp;data: 0x140000b2240 \u0026amp;{10 [1 0 0 0 0 0 0 0 0 0]} Call-by-address \u0026amp;data: 0x140000b2000 \u0026amp;{20 [2 0 0 0 0 0 0 0 0 0]} panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x2 addr=0x0 pc=0x10044fe78] goroutine 1 [running]: main.main() /Workspace/go/src/musthavego/ch14/go_pointer_basics.go:32 +0x408  \r  'use strict'; var containerId = JSON.parse(\"\\\"2240c8eb76bf8c8e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  가비지 컬렉터 순환 참조 각 인스턴스를 가리키는 포인터가 없을때 해당 변수는 가비지 컬렉션에 의해 메모리가 회수될 수 있다고 한다.\n그렇다면 순환 참조를 해서 각 인스턴스를 가리키는 포인터는 존재하지만, 해당 순환을 가리키는 변수가 없는 경우에도 가비지 컬렉션이 잘 동작하는지 확인해봤다.\ngo 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main type List struct { value int next *List } func main() { var pLists [100]*List for i := 0; true; i++{ var l1 List var l2 List var l3 List l1.next = \u0026amp;l2 l2.next = \u0026amp;l3 l3.next = \u0026amp;l1 l1.value = 1 l1.next.value = l1.value + 1 l1.next.next.value = l1.next.value + 1 pLists[i % 100] = \u0026amp;l1 } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"dd488204e8aa0644\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  직접 실행해 본 결과, 딱히 메모리 누수가 발생하지 않는 것으로 보였다. 하지만 컴파일러가 최적화 과정에서 해당 요소를 미리 차단했는지는 확실하지 않아서, 이 부분은 컴파일 옵션, 메모리 누수 확인 툴을 좀 더 공부해서 다시 확인해봐야 할 것 같다.\n탈출 분석 go 컴파일러는 탈출 분석을 하여 지역 변수의 주소를 return해도 오류가 나지 않는다. (해당 변수를 heap에 할당한다.)\n해당 부분을 검증하기 위해 직접 실험해보았다. 실험 결과 모든 변수는 자체적인 goroutine의 heap에 저장되는 것 같다.\ngo 코드 디버거 출력 메모리 레이아웃 확인  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package main import \u0026#34;fmt\u0026#34; type Data struct{ value int data [10]int } func main() { var data1 Data var data2 Data = *new(Data) var pData1 *Data = \u0026amp;data1 var pData2 *Data = \u0026amp;data2 var pData3 *Data = new(Data) var pData4 *Data = newData() var pData5 *Data n := 10 if n % 5 == 0 { // force variable allocation unpredictable \tpData5 = new(Data) } fmt.Printf(\u0026#34;pData1: %p\\n\u0026#34;, pData1) fmt.Printf(\u0026#34;pData2: %p\\n\u0026#34;, pData2) fmt.Printf(\u0026#34;pData3: %p\\n\u0026#34;, pData3) fmt.Printf(\u0026#34;pData4: %p\\n\u0026#34;, pData4) fmt.Printf(\u0026#34;pData5: %p\\n\u0026#34;, pData5) for { // Force infinite loop to check in /proc/**/maps \t} } func newData() *Data { var d Data = Data{} return \u0026amp;d }    \r$ dlv exec ./go_mem_layout_struct Type \u0026#39;help\u0026#39; for list of commands. (dlv) b go_mem_layout_struct.go:32 Breakpoint 1 (enabled) set at 0x499278 for main.main() ./go_mem_layout_struct.go:32 (dlv) continue pData1: 0xc000102060 pData2: 0xc0001020c0 pData3: 0xc000102120 pData4: 0xc000102180 pData5: 0xc0001021e0 \u0026gt; main.main() ./go_mem_layout_struct.go:32 (hits goroutine(1):1 total:1) (PC: 0x499278) Warning: debugging optimized function 29:\tfmt.Printf(\u0026#34;pData4: %p\\n\u0026#34;, pData4) 30:\tfmt.Printf(\u0026#34;pData5: %p\\n\u0026#34;, pData5) 31: =\u0026gt; 32:\tfor { 33:\t// Force infinite loop to check in /proc/**/map 34:\t} (dlv) regs Rip = 0x0000000000499278 Rsp = 0x000000c000108eb0 Rax = 0x0000000000000000 Rbx = 0x000000c00011e000 Rcx = 0x0000000000000000 Rdx = 0x0000000000000000 Rsi = 0x0000000000000000 Rdi = 0x0000000000000000 Rbp = 0x000000c000108f78 R8 = 0x0000000000000000 R9 = 0x0000000000000000 R10 = 0xfffff80000000001 R11 = 0x0000000000000212 R12 = 0x000000c0000161b0 R13 = 0x000000000000003b R14 = 0x0000000000000013 R15 = 0xffffffffffffffff Rflags = 0x0000000000000202 [IF IOPL=0] Es = 0x0000000000000000 Cs = 0x0000000000000033 Ss = 0x000000000000002b Ds = 0x0000000000000000 Fs = 0x0000000000000000 Gs = 0x0000000000000000 Fs_base = 0x000000000054e5b0 Gs_base = 0x0000000000000000  \r$ cat /proc/70871/maps 00400000-0049a000 r-xp 00000000 08:01 4456778 /Workspace/go/src/musthavego/ch14/go_mem_layout_struct 0049a000-00538000 r--p 0009a000 08:01 4456778 /Workspace/go/src/musthavego/ch14/go_mem_layout_struct 00538000-0054e000 rw-p 00138000 08:01 4456778 /Workspace/go/src/musthavego/ch14/go_mem_layout_struct 0054e000-00581000 rw-p 00000000 00:00 0 c000000000-c004000000 rw-p 00000000 00:00 0 7fc392bef000-7fc394fa0000 rw-p 00000000 00:00 0 7fc394fa0000-7fc3a5120000 ---p 00000000 00:00 0 7fc3a5120000-7fc3a5121000 rw-p 00000000 00:00 0 7fc3a5121000-7fc3b6fd0000 ---p 00000000 00:00 0 7fc3b6fd0000-7fc3b6fd1000 rw-p 00000000 00:00 0 7fc3b6fd1000-7fc3b93a6000 ---p 00000000 00:00 0 7fc3b93a6000-7fc3b93a7000 rw-p 00000000 00:00 0 7fc3b93a7000-7fc3b9820000 ---p 00000000 00:00 0 7fc3b9820000-7fc3b9821000 rw-p 00000000 00:00 0 7fc3b9821000-7fc3b98a0000 ---p 00000000 00:00 0 7fc3b98a0000-7fc3b9900000 rw-p 00000000 00:00 0 7fff8d006000-7fff8d027000 rw-p 00000000 00:00 0 [stack] 7fff8d08f000-7fff8d093000 r--p 00000000 00:00 0 [vvar] 7fff8d093000-7fff8d095000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall] $ objdump -h go_mem_layout_struct go_mem_layout_struct: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 0009828a 0000000000401000 0000000000401000 00001000 2**5 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .rodata 00044167 000000000049a000 000000000049a000 0009a000 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 2 .typelink 00000734 00000000004de300 00000000004de300 000de300 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 3 .itablink 00000050 00000000004dea40 00000000004dea40 000dea40 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .gosymtab 00000000 00000000004dea90 00000000004dea90 000dea90 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 5 .gopclntab 00058ab8 00000000004deaa0 00000000004deaa0 000deaa0 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 6 .go.buildinfo 00000020 0000000000538000 0000000000538000 00138000 2**4 CONTENTS, ALLOC, LOAD, DATA 7 .noptrdata 0000e2c4 0000000000538020 0000000000538020 00138020 2**5 CONTENTS, ALLOC, LOAD, DATA 8 .data 00007790 0000000000546300 0000000000546300 00146300 2**5 CONTENTS, ALLOC, LOAD, DATA 9 .bss 0002d750 000000000054daa0 000000000054daa0 0014daa0 2**5 ALLOC 10 .noptrbss 00005310 000000000057b200 000000000057b200 0017b200 2**5 ALLOC 11 .zdebug_abbrev 000001e6 0000000000581000 0000000000581000 0014e000 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 12 .zdebug_line 00032ac5 0000000000581119 0000000000581119 0014e119 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 13 .zdebug_frame 00010144 000000000059daa3 000000000059daa3 0016aaa3 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 14 .debug_gdb_scripts 0000002d 00000000005a3643 00000000005a3643 00170643 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 15 .zdebug_info 0007d8a7 00000000005a3670 00000000005a3670 00170670 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 16 .zdebug_loc 00087fc6 00000000005d6e41 00000000005d6e41 001a3e41 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 17 .zdebug_ranges 00032a70 00000000005eeb07 00000000005eeb07 001bbb07 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 18 .note.go.buildid 00000064 0000000000400f9c 0000000000400f9c 00000f9c 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA  \r  'use strict'; var containerId = JSON.parse(\"\\\"5e71a9bc2366afe5\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  프로세스의 메모리 레이아웃 확인, 스택 포인터 레지스터의 값(Rsp), 각 변수의 주소를 확인해 본 결과 아래와 같은 사실을 알 수 있다.\n 현재 go 코드가 실행되고 있는 위치는 전통적인 stack 세그먼트가 아니다.\n아마 go runtime이 stack 위에서 동작하며, 실제 go 코드를 수행하는 goroutine이 다른 세그먼트에서 동작하는 것으로 보인다.  procfs의 stack 세그먼트는 0x00007fff8d006000 ~ 0x00007fff8d027000 현재 스택 포인터 레지스터 값은 0x000000c000108eb0 변수들의 주소 값은 0x000000c000102060 ~ 0x000000c0001021e0 즉, 현재 goroutine이 사용중인 세그먼트는 0x000000c000000000 ~ 0x000000c004000000로 볼 수 있다.   변수들은 지역변수, 동적할당 변수 관계 없이 자체적인 heap 영역에 할당하는 것으로 보인다.  현재 스택 포인터 레지스터 값은 0x000000c000108eb0 변수들의 주소 값은 0x000000c000102060 ~ 0x000000c0001021e0 변수들의 주소값과 스택 포인터의 값이 약 0x6000 이상의 차이를 보이고 있다. 변수들이 지역변수, 동적할당 변수, 탈출분석에 의한 변수 관계없이 모두 같은 간격으로 배치되어있다. (0x60) 일반적으로 stack이 큰 값에서 작은 값으로 자라고, 변수들이 선언 순서에 따라 주소 값이 커지는 것으로 보아\n변수는 내부적으로 stack에 저장된다고 보기 힘들 수 있다.    혹시 접근하는 변수 타입이 struct라서 무조건 heap을 사용하는 것이고, 기본 자료형을 사용하면 stack에 값이 들어가는지 추가로 확인해봤다.\ngo 코드 디버거 출력  package main import \u0026#34;fmt\u0026#34; func main() { var num1 int var num2 int = *new(int) var pInt1 *int = \u0026amp;num1 var pInt2 *int = \u0026amp;num2 var pInt3 *int = new(int) var pInt4 *int = newint() var pInt5 *int n := 10 if n % 5 == 0 { // force variable allocation unpredictable \tpInt5 = new(int) } fmt.Printf(\u0026#34;pInt1: %p\\n\u0026#34;, pInt1) fmt.Printf(\u0026#34;pInt2: %p\\n\u0026#34;, pInt2) fmt.Printf(\u0026#34;pInt3: %p\\n\u0026#34;, pInt3) fmt.Printf(\u0026#34;pInt4: %p\\n\u0026#34;, pInt4) fmt.Printf(\u0026#34;pInt5: %p\\n\u0026#34;, pInt5) for { // Force infinite loop to check in /proc/**/maps \t} } func newint() *int { var d int = 0 return \u0026amp;d }  \r$ dlv exec ./go_mem_layout_int Type \u0026#39;help\u0026#39; for list of commands. (dlv) b go_mem_layout_int.go:27 Breakpoint 1 (enabled) set at 0x499245 for main.main() ./go_mem_layout_int.go:27 (dlv) continue pInt1: 0xc00001a0f0 pInt2: 0xc00001a0f8 pInt3: 0xc00001a100 pInt4: 0xc00001a108 pInt5: 0xc00001a110 \u0026gt; main.main() ./go_mem_layout_int.go:27 (hits goroutine(1):1 total:1) (PC: 0x499245) Warning: debugging optimized function 24: fmt.Printf(\u0026#34;pInt4: %p\\n\u0026#34;, pInt4) 25: fmt.Printf(\u0026#34;pInt5: %p\\n\u0026#34;, pInt5) 26: =\u0026gt; 27: for { 28: // Force infinite loop to check in /proc/**/map 29: } (dlv) regs Rip = 0x0000000000499245 Rsp = 0x000000c000108eb0 Rax = 0x0000000000000000 Rbx = 0x000000c00011e000 Rcx = 0x0000000000000000 Rdx = 0x0000000000000000 Rsi = 0x0000000000000000 Rdi = 0x0000000000000000 Rbp = 0x000000c000108f78 R8 = 0x0000000000000000 R9 = 0x0000000000000000 R10 = 0xfffff80000000001 R11 = 0x0000000000000212 R12 = 0x000000c0000161b0 R13 = 0x000000000000003b R14 = 0x0000000000000013 R15 = 0xffffffffffffffff Rflags = 0x0000000000000202 [IF IOPL=0] Es = 0x0000000000000000 Cs = 0x0000000000000033 Ss = 0x000000000000002b Ds = 0x0000000000000000 Fs = 0x0000000000000000 Gs = 0x0000000000000000 Fs_base = 0x000000000054e5b0 Gs_base = 0x0000000000000000  \r  'use strict'; var containerId = JSON.parse(\"\\\"ced765c5647a164e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  int의 크기인 8 byte 간격으로 떨어진 것을 보아 기본 자료형/struct정의 자료형과 관계없이 비슷한 증상이 나타나는 것을 확인할 수 있었다.\n이 부분을 정확하게 이해하려면 goroutine 내 메모리 관리에 대해 자세히 찾아봐야 할 것 같다.\n","description":"","id":0,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 14장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch14/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n13장. 구조체 구조체의 Go 언어에서의 특징만 확인해보자.\n class가 없이, struct만 존재한다. 상속의 is-a 관계가 아닌 has-a 관계로만 구조체 관계를 정의한다. 구조체 속의 구조체 사용에서, 내부 구조체 필드 이름을 제외하면 구조체 확장과 비슷하게 사용할 수 있다. 메서드의 선언, 정의는 구조체 밖에서 이루어진다.  이 중 메서드 관련 내용은 추후 책에서 다루므로 여기에선 간단하게 무슨 의미인지 언급만 하고 지나가도록 하겠다.\n구조체의 선언 책에서는 무조건적으로 struct 타입 선언 시, 타입 명을 같이 선언해야 하는 것 처럼 표현되어있지만, 타입 이름이 없는 익명 구조체 타입을 선언할 수 있다. (물론 활용도가 이름 있는 타입에 비해 떨어지기 때문에 없다고 생각해도 무방할 것으로 보인다.)\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import \u0026#34;fmt\u0026#34; func main() { var contact1 struct { Name\tstring Id\tint Cell\tstring } fmt.Println(contact1) contact1.Id = 1 contact1.Name = \u0026#34;John Doe\u0026#34; contact1.Cell = \u0026#34;1 234-567-890\u0026#34; // Copy anonymous struct into the other variable \tcontact2 := contact1 contact2.Name = \u0026#34;Jane Doe\u0026#34; contact2.Id = 2 fmt.Println(contact1) fmt.Println(contact2) }    \r$ ./go_anonymous_struct { 0 } {John Doe 1 1 234-567-890} {Jane Doe 2 1 234-567-890}  \r  'use strict'; var containerId = JSON.parse(\"\\\"7d0fa3fc4068b8a5\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  구조체를 포함하는 구조체 먼저 다른 구조체를 일반 타입처럼 포함하는 방식으로 실험해보자. 추가로 내부 구조체를 변수로 선언한 뒤, 바로 복사가 가능한지, 구조체 내부 필드 중 일부만 초기화하는 것도 확인해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type User struct { Name\tstring Id\tint Age\tint } type VipUser struct { UserInfo\tUser Level\tint Since\ttime.Time } func main() { var john User = User{\u0026#34;John Doe\u0026#34;, 1, 30} var johnVip VipUser = VipUser{UserInfo: john, Level: 1} janeVip := VipUser{User{\u0026#34;Jane Doe\u0026#34;, 2, 32}, 2, time.Now()} fmt.Println(johnVip) fmt.Println(janeVip) fmt.Printf(\u0026#34;VIP user %s became VIP since %v\u0026#34;, janeVip.UserInfo.Name, janeVip.Since) }    \r$ ./go_struct_in_struct {{John Doe 1 30} 1 0001-01-01 00:00:00 +0000 UTC} {{Jane Doe 2 32} 2 2021-05-31 13:06:28.78326 +0900 KST m=+0.000120543} VIP user Jane Doe became VIP since 2021-05-31 13:06:28.78326 +0900 KST m=+0.000120543  \r  'use strict'; var containerId = JSON.parse(\"\\\"10146e6fdcae7533\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이제 포함된 필드(Embedded field) 방식으로 다시 실험해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type User struct { Name\tstring Id\tint Age\tint } type VipUser struct { User Level\tint Since\ttime.Time } func main() { var john User = User{\u0026#34;John Doe\u0026#34;, 1, 30} var johnVip VipUser = VipUser{User: john, Level: 1} janeVip := VipUser{User{\u0026#34;Jane Doe\u0026#34;, 2, 32}, 2, time.Now()} fmt.Println(johnVip) fmt.Println(janeVip) fmt.Printf(\u0026#34;VIP user %s became VIP since %v\u0026#34;, janeVip.Name, janeVip.Since) }    \r$ ./go_embedded_struct {{John Doe 1 30} 1 0001-01-01 00:00:00 +0000 UTC} {{Jane Doe 2 32} 2 2021-05-31 13:13:14.075062 +0900 KST m=+0.000131959} VIP user Jane Doe became VIP since 2021-05-31 13:13:14.075062 +0900 KST m=+0.000131959  \r  'use strict'; var containerId = JSON.parse(\"\\\"6150fc3dfe132a1e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  구조체 패딩 go에서도 구조체 내 멤버 접근 속도를 빠르게 하기 위해 메모리 패딩을 수행한다. 확실한 비교를 위해 책에 나온 예제에서 주소 값까지 찍어보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type Unoptimized struct { A\tint8 B\tint C int8 D int E int8 } type Optimized struct { A int8 C int8 E int8 B int D int } func main() { var1 := Unoptimized{} var2 := Optimized{} fmt.Printf(\u0026#34;sizeof Unoptimized: %d, Optimized: %d\\n\u0026#34;, unsafe.Sizeof(var1), unsafe.Sizeof(var2)) fmt.Printf(\u0026#34;\\nUnoptimized\\n\\tA: %p\\n\\tB: %p\\n\\tC: %p\\n\\tD: %p\\n\\tE: %p\\n\u0026#34;, \u0026amp;var1.A, \u0026amp;var1.B, \u0026amp;var1.C, \u0026amp;var1.D, \u0026amp;var1.E) fmt.Printf(\u0026#34;\\nOptimized\\n\\tA: %p\\n\\tB: %p\\n\\tC: %p\\n\\tD: %p\\n\\tE: %p\\n\u0026#34;, \u0026amp;var2.A, \u0026amp;var2.B, \u0026amp;var2.C, \u0026amp;var2.D, \u0026amp;var2.E) }    \r$ ./go_struct_padding sizeof Unoptimized: 40, Optimized: 24 Unoptimized A: 0x140000b2030 B: 0x140000b2038 C: 0x140000b2040 D: 0x140000b2048 E: 0x140000b2050 Optimized A: 0x140000ba000 B: 0x140000ba008 C: 0x140000ba001 D: 0x140000ba010 E: 0x140000ba002  \r  'use strict'; var containerId = JSON.parse(\"\\\"5587bd95e4c12489\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  구조체의 메서드 비슷하게 struct만 사용할 수 있는 C언어와 비교해보자.\nC언어 Go  // struct 선언 struct MyStr { uint capacity; uint length; char *storage; // method 목록 선언 (함수 포인터)  int (*GetLength)(struct MyStr *ms); void (*Append)(struct MyStr *ms, struct MyStr *follow); }; // method 구현 (함수 정의) int _getLength(struct MyStr *ms) { // Implemenation... }; void _append(struct MyStr *ms, struct MyStr *follow) { // Implemenation... }; // struct 변수 초기화 struct MyStr str1 = {0, 0, NULL}; str1.GetLength = _getLength; // 함수 포인터 매핑 str1.Append = _append; // 함수 포인터 매핑  // struct method 사용 int length = str1.GetLength(\u0026amp;str1); str1.Append(\u0026amp;str1, \u0026amp;str2);  \r// struct 선언 type MyStr struct { capacity uint length uint storage *byte; } // method 선언, 정의 func (ms *MyStr) Length() int { // Implementation... } func (ms *MyStr) Append(MyStr *follow) { // Implementation... } // struct 변수 초기화 var str1 MyStr = MyStr {0, 0, nil} // struct method 사용 length := str1.GetLength(); str1.Append(\u0026amp;str2);  \r  'use strict'; var containerId = JSON.parse(\"\\\"6cc2c61fcc6aaa53\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위 예시에서 보듯 method 목록 선언이 구조체 밖에서 이루어진다. 더 자세한 부분은 추후 메서드를 다루는 장에서 자세히 보도록 하겠다.\n","description":"","id":1,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 13장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch13/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n12장. 배열 배열의 Go 언어에서의 특징만 확인해보자.\n 배열의 길이는 상수로 되어있다. 가변 배열은 slice를 써야 한다. [...]으로 길이를 자동 완성할 수 있다. range로 배열을 순회할 수 있다. len()으로 배열의 길이를 알 수 있다. =으로 배열을 복사할 수 있다.  range를 통한 배열 순회 Go에서 range를 통해 배열을 순회하는 방식은 python에 비해 index를 쉽게 접근할 수 있다는 장점이 있다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \u0026#34;fmt\u0026#34; func main() { var nums [5]int = [...]int{2, 3, 5, 8, 13} for i, val := range nums { fmt.Printf(\u0026#34;nums[%d] = %d\\n\u0026#34;, i, val) } fmt.Println() for i := 0; i \u0026lt; len(nums); i++ { fmt.Printf(\u0026#34;nums[%d] = %d\\n\u0026#34;, i, nums[i]) } }    \r$ ./go_array_loop_with_range nums[0] = 2 nums[1] = 3 nums[2] = 5 nums[3] = 8 nums[4] = 13 nums[0] = 2 nums[1] = 3 nums[2] = 5 nums[3] = 8 nums[4] = 13  \r  'use strict'; var containerId = JSON.parse(\"\\\"984a8aaab95623be\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  배열의 복사 C계열의 언어는 memcpy()나 배열 순회를 통해 배열을 복사해야 하지만, go에서는 =로 바로 복사가 가능하다.\n만약 복사하려는 배열의 길이가 다른 경우, copy()를 통해 복사할 수 있다. go에서는 배열 변수의 타입 검사 시 배열 길이도 비교하기 때문이다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package main import \u0026#34;fmt\u0026#34; func main() { var arrX [5]int var arr3 = [3]int{3, 4, 5} var arr5 = [5]int{10, 20, 4:50} var arr8 = [8]int{7, 6, 5, 4, 3, 2, 1, 0} fmt.Println(arrX) // go vet: Cannot use \u0026#39;arr3\u0026#39; (type [3]int) as the type [5]int \t// arrX = arr3 \tcopy(arrX[0:3], arr3[:]) fmt.Println(arrX) arrX = arr5 fmt.Println(arrX) // src length can exceed dst length \tcopy(arrX[:], arr8[1:7]) fmt.Println(arrX) }    \r$ ./go_array_copy [0 0 0 0 0] [3 4 5 0 0] [10 20 0 0 50] [6 5 4 3 2]  \r  'use strict'; var containerId = JSON.parse(\"\\\"6d0df8c2712e4dbc\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"","id":2,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 12장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch12/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n11장. for문 for문의 Go 언어에서의 특징만 확인해보자.\n Go에서 반복문은 for문만 제공된다. for를 while처럼 사용하기 위한 문법을 제공한다. (초기문이나 후처리 생략)  초기문, 후처리 생략 초기문과 후처리를 생략할 수 있다. 모두 생략하는 경우 사실상 while문과 다름이 없다.\n일반 for문 초기문 생략 후처리 생략 모두 생략  1 2 3  for i := 1; i \u0026lt;= 9; i++ { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, 2, i, 2 * i) }    \r1 2 3 4  i := 1 for ; i \u0026lt;= 9; i++ { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, 2, i, 2 * i) }    \r1 2 3 4  for i := 1; i \u0026lt;= 9; { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, 2, i, 2 * i) i++ }    \r1 2 3 4 5  i := 1 for i \u0026lt;= 9 { fmt.Printf(\u0026#34;%d * %d = %d\\n\u0026#34;, 2, i, 2 * i) i++ }    \r  'use strict'; var containerId = JSON.parse(\"\\\"173394941e814a3e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  초기문과 후처리를 모두 생략한 경우는 사실상 while문이나 다름이 없다.\n레이블을 활용한 break 다중 for문에서 레이블을 선언하고, break 뒤에 레이블을 입력하면 해당 레이블에서 가장 가까운 for에서 break하는 효과가 있는데, 사실상 goto의 응용이라고 볼 수 있다.\n대부분 프로그래밍 언어에서는 goto계열의 기능 사용을 자제하라고 권고하고 있다. 만약 goto를 사용할 수 밖에 없는 경우에는 뒤쪽 레이블로만 사용할 것을 권고하고 있다. 대부분 임베디드 계열 코드나, 커널 코드를 보면 성능 향상이나 코드 크기 문제로 인해 어쩔 수 없이 goto를 사용하기 때문이다.\n그런데 여기서 사용하는 break의 활용 예시는 앞쪽 레이블을 인자로 사용하며, 해당 레이블에서 가까운 for문을 확인해야 하므로, 좋은 접근법은 아니다. 일반적으로 사용하지 말고, 어쩌다 코드 리딩 중에 발견할때 이해하는 수준으로 넘어가자.\n","description":"","id":3,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 11장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch11/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n10장. switch문 switch문의 Go 언어에서의 특징만 확인해보자.\n 각 조건 단위의 종료를 위해 break를 쓸 필요가 없다. 대신 기존의 break 생략을 fallthrough 키워드로 대체한다. case에서 값 비교 뿐만 아니라 조건문 검사가 가능하다. 대상 값 선언 전에 초기문을 사용할 수 있다.  break 생략과 fallthrough go 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import \u0026#34;fmt\u0026#34; func main() { switch age := getMyAge(); age { case 9: fallthrough case 10: fallthrough case 11: fmt.Println(\u0026#34;You need to be at least 12-years-old to sign up.\u0026#34;) case 12: fallthrough case 13: fmt.Println(\u0026#34;You need parent\u0026#39;s approval to sign up.\u0026#34;) default: fmt.Println(\u0026#34;You\u0026#39;re ok to sign up.\u0026#34;) } } func getMyAge() int { return 9 }    \r$ ./go_switch_fallthrough You need to be at least 12-years-old to sign up.  \r  'use strict'; var containerId = JSON.parse(\"\\\"45d768f773f4b9df\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  case에서 조건 검사 위에서는 fallthrough 사용 예시를 보여주기 위해 11세 이하 조건을 간략하게 9, 10, 11만 선택하게 했다. default가 14세 이상이기 때문에 입력 값이 0~8이 들어오면 버그가 발생한다. Go에서는 case에서 조건 검사가 가능하니, 이를 활용해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  package main import \u0026#34;fmt\u0026#34; func main() { switch age := getMyAge(); true { case age \u0026lt; 12: fmt.Println(\u0026#34;You need to be at least 12-years-old to sign up.\u0026#34;) case 12 \u0026lt;= age \u0026amp;\u0026amp; age \u0026lt; 14: fmt.Println(\u0026#34;You need parent\u0026#39;s approval to sign up.\u0026#34;) default: fmt.Println(\u0026#34;You\u0026#39;re ok to sign up.\u0026#34;) } } func getMyAge() int { return 8 }    \r$ ./go_switch_case_cond You need to be at least 12-years-old to sign up.  \r  'use strict'; var containerId = JSON.parse(\"\\\"db44d525933a3a1f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"","id":4,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 10장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch10/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n9장. if문 if문의 Go 언어에서의 특징만 확인해보자.\n문법적 특징  if 옆의 조건문에 괄호()가 필수가 아니다. One True Brace Style을 따르는 들여쓰기, 대괄호 사용 초기문을 조건문 바로 앞에서 사용할 수 있다.  if 초기문; 조건문 책에서 보면 알 수 있듯, if 옆의 조건 검사 이전에 초기문을 넣을 수 있다. 혹시 이게 else if에도 적용되는지 확인해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import \u0026#34;fmt\u0026#34; func main() { if age := getMyAge(); age \u0026gt; 14 { fmt.Println(\u0026#34;You\u0026#39;re ok to sign up.\u0026#34;) } else if approve := getParentApprove(); age \u0026gt;= 12 \u0026amp;\u0026amp; approve { fmt.Println(\u0026#34;Your parent approved you to sign up.\u0026#34;) } else if age \u0026lt; 12 { fmt.Println(\u0026#34;You need to be at least 12-years-old to sign up.\u0026#34;) } else { fmt.Println(\u0026#34;Your parent didn\u0026#39;t approved you to sign up.\u0026#34;) } } func getMyAge() int { return 12 } func getParentApprove() bool { return false }    \r$ go build $ ./go_else_if_init Your parent didn\u0026#39;t approved you to sign up.  \r  'use strict'; var containerId = JSON.parse(\"\\\"718780920b64f7bb\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  else if에도 초기문과 조건문을 같이 넣을 수 있는 것을 확인할 수 있다.\n","description":"","id":5,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 9장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch09/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n8장. 상수 상수의 필요성, 상수 등은 이미 알고 있으니, Go 언어에서의 특징만 확인해보자.\n타입 있는 vs 타입 없는 타입 있는 상수는 C/C++에서 const으로 정의된 형태의 상수와 같은 효과라고 볼 수 있다.\n 상수를 사용할 때 타입 검사가 이루어진다. 메모리 위에 해당 상수가 존재한다.  타입 없는 상수는 C/C++에서 #define으로 정의된 형태의 상수와 같은 효과라고 볼 수 있다.\n 해당 상수는 문자열 값 그대로 치환된다. 메모리 위에 해당 상수가 존재하지 않을 수도 있다.  iota C/C++의 enum과 비슷한 용도로 사용하는데, 수식에 활용될 수 있어서 좀 더 간편하게 다양한 형태의 상수 정의에 활용될 수 있다.\ngo 코드 C 코드  1 2 3 4 5 6 7 8 9 10 11 12 13  package main import \u0026#34;fmt\u0026#34; const ( FLAG_ALPHA = 1 \u0026lt;\u0026lt; iota FLAG_BRABO FLAG_CHARLIE ) func main() { fmt.Println(FLAG_ALPHA, FLAG_BRABO, FLAG_CHARLIE) }    \r1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt; enum { FLAG_ALPHA = 1 \u0026lt;\u0026lt; 1, FLAG_BRABO = 1 \u0026lt;\u0026lt; 2, FLAG_CHARLIE = 1 \u0026lt;\u0026lt; 3 }; int main(void) { printf(\u0026#34;%d %d %d\\n\u0026#34;, FLAG_ALPHA, FLAG_BRABO, FLAG_CHARLIE); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"88d6eab7ebfa19aa\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"","id":6,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 8장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch08/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n7장. 함수 함수의 필요성, 효율 등은 이미 알고 있으니, Go 언어에서의 특징만 확인해보자.\nGo는 절차형 프로그래밍 언어 일단 Go는 함수형 프로그래밍 언어가 아니다. 확인해보니 익명 함수 등의 함수형 프로그래밍에서 사용할 기법을 제공하긴 하지만, 기본적으로 절차형 프로그래밍 언어에 맞게 함수를 작성해야 한다.\n관련된 부분은 추후 언급되는 것으로 보이니 이번에는 생략하도록 하겠다.\n다중 반환 함수 이전 ch05에서 언급했듯, Go에서는 함수가 여러 값을 한 번에 반환하는 기능을 제공한다.\n또한 Go의 경우 함수의 선언/정의가 C/C++과 달리 어느 위치에나 존재해도 된다.\n예시로 나온 나누기 함수에서 특정 요소들을 수정해봤다.\n func Divide()의 위치를 뒤로 옮겨서 함수의 선언/정의 위치 관계를 확인 3개 이상의 값을 반환하도록 수정 변수명 지정 반환시에도 같은 타입의 반환 값의 타입 생략이 가능한지 확인 함수의 인자 개수가 길어질 때, 강제로 줄바꿈을 해도 아무 문제 없는지 확인  go 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import \u0026#34;fmt\u0026#34; func main() { dividend := 16 divisor := 5 quot, remain, valid := Divide(dividend, divisor) if valid { fmt.Printf(\u0026#34;The quotient of %d divided by %d is %d with a remainder of %d\u0026#34;, dividend, divisor, quot, remain) } } func Divide(dividend, divisor int) (quotient, remainder int, validity bool) { if divisor == 0 { return 0, 0, false } quotient = dividend / divisor remainder = dividend % divisor validity = true return }    \r$ ./go_func_divide The quotient of 16 divided by 5 is 3 with a remainder of 1 # 0으로 나누고, 예외처리를 하지 않도록 수정한 경우 $ ./go_func_divide_by_zero panic: runtime error: integer divide by zero goroutine 1 [running]: main.Divide(...) /Workspace/go/src/test/go_func_divide_by_zero.go:19 main.main() /Workspace/go/src/test/go_func_divide_by_zero.go:8 +0x12  \r  'use strict'; var containerId = JSON.parse(\"\\\"e3dc3834367e0a89\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  모두 정상적으로 돌아가는 것을 확인할 수 있다.\n그리고 나누는 값에 대한 예외처리를 하지 않으면 panic이 발생하는데, 이 부분은 추후 언급되는 것으로 보이니 생략하도록 하겠다.\n재귀 호출과 Tail call 재귀 호출에 대한 개념이 나와서 Tail Call 최적화가 됐는지 궁금했다.\n찾아보니 Go에서는 TCO가 적용되지 않았고, Go 2에서 지원하는 것을 제안했으나 거부당한 것으로 보인다.\n","description":"","id":7,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 7장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch07/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n6장. 연산자 사실 연산자 대부분이 어느 프로그래밍 언어나 다 비슷해서 딱히 다룰 거리는 없어 보이는데, Go 언어에서 발견한 특이한 부분만 다뤄보려 한다.\nXOR 연산자 특이하게도 Go에서는 비트 단위의 NOT 연산이 존재하지 않는다. 대신 XOR을 단독 연산자로 사용하여 NOT 연산을 대체한다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10  package main import \u0026#34;fmt\u0026#34; func main() { var uint8Max uint8 = ^uint8(0) fmt.Printf(\u0026#34;%b\\n\u0026#34;, uint8Max) }     $ ./go_xor_not 11111111     'use strict'; var containerId = JSON.parse(\"\\\"26e1b36a52d10abc\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Bit clear 연산자 비트 연산에서 A ∧ ¬B(A AND NOT B)를 수행하면 A에서 B에 선택된 비트들만 0으로 clear한다. Go 언어에서는 \u0026amp;^(AND-NOT)을 연산자 단위로 취급, 제공한다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13  package main import \u0026#34;fmt\u0026#34; func main() { var flags uint8 = 0b_11001100 var clears uint8 = 0b_01100110 fmt.Printf(\u0026#34;%b\\n\u0026#34;, flags) flags \u0026amp;^= clears fmt.Printf(\u0026#34;%b\\n\u0026#34;, flags) }     $ ./go_bit_clear 11001100 10001000     'use strict'; var containerId = JSON.parse(\"\\\"9db2aaf4702e5fd6\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Shift 연산자 Shift 연산이 2의 제곱에 대한 곱셈, 나눗셈 역할을 하는 것은 알고 있었다. 하지만 오른쪽 shift시 채워지는 값이 양수/음수에 따라 다르다는 것은 처음 알았다.\nGo 언어만 그런 것인지, 다른 언어에서도 당연한 것인지 확인해보자.\ngo 코드 C 코드 Java 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11  package main import \u0026#34;fmt\u0026#34; func main() { var num1 uint8 = 0b_11001100 fmt.Printf(\u0026#34;0x%X\\n\u0026#34;, num1 \u0026gt;\u0026gt; 2) fmt.Printf(\u0026#34;0x%X\\n\u0026#34;, uint8(int8(num1) \u0026gt;\u0026gt; 2)) }     1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt; int main(void) { u_int8_t num1 = 0xCC; printf(\u0026#34;0x%X\\n\u0026#34;, num1 \u0026gt;\u0026gt; 2); printf(\u0026#34;0x%X\\n\u0026#34;, (u_int8_t)((int8_t)num1 \u0026gt;\u0026gt; 2)); }     1 2 3 4 5 6 7 8  public class java_shr { public static void main(String[] args) { char num1 = 0xCC; System.out.printf(\u0026#34;0x%X\\n\u0026#34;, num1 \u0026gt;\u0026gt; 2); System.out.printf(\u0026#34;0x%X\\n\u0026#34;, ((byte)num1 \u0026gt;\u0026gt; 2)); } }     $ ./go_shr 0x33 0xF3 $ ./c_shr 0x33 0xF3 $ java java_shr 0x33 0xFFFFFFF3     'use strict'; var containerId = JSON.parse(\"\\\"d24eb3806cdecb85\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Go 언어만이 아니라 모든 언어에서 동일한 결과가 확인되었다.\nNextAfter 컴퓨터에서 실수 연산 처리에는 오차가 수반된다. 해당 문제를 해결할 수 있도록 Go에서는 다음 비트 값의 실수를 얻는 NextAfter() 함수를 제공한다.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { var num1 float64 = 0.0 fmt.Printf(\u0026#34;%g\\n\u0026#34;, num1) fmt.Printf(\u0026#34;%g\\n\u0026#34;, math.Nextafter(num1, 1)); }     $ ./go_next_after 0 5e-324     'use strict'; var containerId = JSON.parse(\"\\\"b725bac2a79628ef\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"","id":8,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 6장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch06/"},{"content":"iamroot 17기 스터디를 다행히 아직 참여하고 있다. 요새 진도 내용을 잘 못 따라가고 있기도 하고, 이전 스터디에 대한 복습이 필요한 것 같아, 내용을 정리하려 한다.\n이전보다는 리눅스 커널 소스도 직접 읽어보고, 추가적으로 공부한 지식이 있으니, 당시 있던 의문에 더 정확한 결론을 내릴 수 있을 것 같다.\n스터디 초기에는 커널의 내부 구성, 역할 등에 대한 이론을 이해하기 위해 리눅스 커널 내부 구조를 참고해 이론 스터디를 진행했다.\n1주차 진도는 Chapter.0 ~ Chapter.3 (p10 ~ p93)이었다.\nChapter.0 운영체제 이야기 Q. 디스크 블록의 크기는 (일반적으로 4KB) 무엇을 기준으로 결정되었는가? (p12) 해당 부분의 맥락으로 보았을 때, 운영체제가 디스크 사용 시 이미 지정된 단위를 기준으로 OS가 제공한다는 점이 핵심이라고 본다. 이와 다른 경우로는 실제 파일의 크기만큼만 디스크를 제공하는 경우다.\n컴퓨터 내에서는 특정 단위를 기준으로 자르는 것이 속도 관점에서 더 효율적이며, 여기 디스크 블록을 제외한 다른 자원의 단위도 특정 단위를 기준으로 자른다. 이와 비슷한 예로 페이지, 패킷, CPU time 등이 존재한다.\n굳이 4KB를 표기한 것은 일반적으로 페이지 크기가 4KB이기 때문에 언급된 것으로 보인다.\nChapter.2 리눅스 커널 구조 Q. 파일 시스템을 사용자가 일관된 인터페이스로 접근한다는 것이 무슨 뜻인가? (p38) 물리적으로 실제 데이터를 기록하는 파일 시스템은 fat32, ext4 등이 존재한다. 그리고 논리적으로 존재하는 proc, sysfs, devfs 등이 존재한다. 참고로 여기서 내가 의미하는 물리적/논리적의 구분은 기록이 비휘발성인지, 휘발성인지를 기준으로 잡고 있다. (nfs의 경우 물리적으로 실제 데이터를 기록할 때 사용되지만, 파일 시스템의 역할상으로는 논리적으로 수행된다고 볼 수도 있다.)\n이들은 모두 리눅스 파일시스템에 마운트 되어 있다.\n /boot, /bin, /etc 등은 ext4 등으로 포맷된 디스크에 실제로 존재한다. 모든 프로세스와 커널의 정보를 담은 /proc은 procfs 파일시스템으로 정의되어있다. 연결된 IO장치에 접근하기 위한 /dev는 devfs 파일시스템으로 정의되어있다.\n게다가 /dev/에는 /dev/sda, /dev/hda, /dev/ttyUSB 같은 물리적인 장치 뿐만 아니라,\n/dev/null, /dev/zero, /dev/random 같이 실제 물리적인 장치가 아니지만 자주 사용되는 논리적인 장치가 있다. 연결된 CPU, RAM, IO장치 등의 정보, 커널의 설정 값을 확인하고 변경할 수 있는 /sys는 sysfs 파일시스템으로 정의되어있다.  이들이 모두 일관된 인터페이스로 접근할 수 있는 예시를 확인해보자.\n 물리적인 디스크 내에 존재하는 파일의 읽기/쓰기는 다양한 프로그램의 소스 코드에서 확인할 수 있다.\n대표적으로 C에서 fopen(), fprintf(), fread() 등을 사용할 수 있다. 물리적인 파일이 아님에도 위와 같이 파일 읽기/쓰기를 활용하여 프로그래밍을 할 수 있다.\nC에서 fprintf(stdout, ...)을 통해 printf와 같이 콘솔로 출력할 수 있다. 커널의 설정을 실행 중 변경할 때는 굳이 텍스트 에디터 등을 사용하지 않고 shell에서 명령어를 통해 변경한다.\n(일반적으로 echo한 내용을 pipe로 write하거나, cat으로 파일의 내용을 읽는다.)\n# echo nop \u0026gt; /sys/kernel/tracing/current_tracer # 커널의 tracer를 끌 때 (nop) 사용\n# cat /sys/kernel/tracing/trace # 커널의 trace 내용을 확인하려 할 때 사용 어떤 실행 파일을 실행시키고, 그 출력 결과에는 관심이 없을 때, /dev/null로 pipe시켜 내용을 버린다.\n또한 무작위 값을 입력받기 위해 /dev/random을 사용하기도 한다.\n# time ./bench_primes 1 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 # ./bench_primes의 stdout, stderr를 출력하지 않게 한다.\n# dd if=/dev/random of=rand bs=1K count=2 # diskdump할 때 무작위 입력을 위해 /dev/random 파일을 사용한다.  위의 예시에서 확인할 수 있듯, 물리적/논리적인 파일시스템이 여러개 존재하며 모두 /(root filesystem) 아래 하위 디렉터리로 존재한다. 그리고 모든 파일들은 creat(), open(), read(), write(), close() 등의 system call을 통해 접근하게 된다.\nVFS(Virtual File System)은 물리적/논리적으로 다른 파일시스템에서의 syscall을 수행할 수 있게 호환시켜주는 역할을 한다.\n리눅스의 전신인 유닉스 시절부터 모든 것은 파일이다 철학에 따라 개발되었으므로, 운영체제가 사용자에게 제공하는 모든 기능은 파일의 형태를 이루어 제공되게 되었고, 이에 따라 가상 파일 시스템이 필수적이었던 것으로 예상된다.\nQ. 커널 컴파일 과정에서 objcopy가 하는 역할, 의미는 무엇인가? (p43) 컴파일 과정에서 생긴 vmlinux는 virtual memory가 적용된 linux 커널 실행 파일이란 뜻이다.\nobjcopy 과정을 거치기 위해 사용된 Makefile과 관련 명령어, 결과를 먼저 비교해보자.\narch/arm64/boot/Makefile Shell 확인  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  # # arch/arm64/boot/Makefile # # This file is included by the global makefile so that you can add your own # architecture-specific flags and dependencies. # # This file is subject to the terms and conditions of the GNU General Public # License. See the file \u0026#34;COPYING\u0026#34; in the main directory of this archive # for more details. # # Copyright (C) 2012, ARM Ltd. # Author: Will Deacon \u0026lt;will.deacon@arm.com\u0026gt; # # Based on the ia64 boot/Makefile. #  OBJCOPYFLAGS_Image :=-O binary -R .note -R .note.gnu.build-id -R .comment -S  targets := Image Image.bz2 Image.gz Image.lz4 Image.lzma Image.lzo $(obj)/Image: vmlinux FORCE $(call if_changed,objcopy)  $(obj)/Image.bz2: $(obj)/Image FORCE $(call if_changed,bzip2) $(obj)/Image.gz: $(obj)/Image FORCE $(call if_changed,gzip) $(obj)/Image.lz4: $(obj)/Image FORCE $(call if_changed,lz4) $(obj)/Image.lzma: $(obj)/Image FORCE $(call if_changed,lzma) $(obj)/Image.lzo: $(obj)/Image FORCE $(call if_changed,lzo) install: $(CONFIG_SHELL) $(srctree)/$(src)/install.sh $(KERNELRELEASE) \\ \t$(obj)/Image System.map \u0026#34;$(INSTALL_PATH)\u0026#34; zinstall: $(CONFIG_SHELL) $(srctree)/$(src)/install.sh $(KERNELRELEASE) \\ \t$(obj)/Image.gz System.map \u0026#34;$(INSTALL_PATH)\u0026#34;     $ aarch64-linux-gnu-objcopy --help Usage: aarch64-linux-gnu-objcopy [option(s)] in-file [out-file] Copies a binary file, possibly transforming it in the process The options are: -I --input-target \u0026lt;bfdname\u0026gt; Assume input file is in format \u0026lt;bfdname\u0026gt; -O --output-target \u0026lt;bfdname\u0026gt; Create an output file in format \u0026lt;bfdname\u0026gt; : -j --only-section \u0026lt;name\u0026gt;\tOnly copy section \u0026lt;name\u0026gt; into the output --add-gnu-debuglink=\u0026lt;file\u0026gt; Add section .gnu_debuglink linking to \u0026lt;file\u0026gt; -R --remove-section \u0026lt;name\u0026gt; Remove section \u0026lt;name\u0026gt; from the output --remove-relocations \u0026lt;name\u0026gt; Remove relocations from section \u0026lt;name\u0026gt; -S --strip-all\tRemove all symbol and relocation information : -V --version\tDisplay this program\u0026#39;s version number -h --help\tDisplay this output --info\tList object formats \u0026amp; architectures supported aarch64-linux-gnu-objcopy: supported targets: elf64-littleaarch64 elf64-bigaarch64 elf32-littleaarch64 elf32-bigaarch64 elf32-littlearm elf32-bigarm elf64-little elf64-big elf32-little elf32-big srec symbolsrec verilog tekhex binary ihex plugin Report bugs to \u0026lt;http://www.sourceware.org/bugzilla/\u0026gt; # 커널 컴파일을 통해 얻은 리눅스 커널 실행파일 vmlinux가 어떤 파일인지 확인해보자. $ file vmlinux vmlinux: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), statically linked, BuildID[sha1]=33523a2bcbaf40ff140171d6169def75f68aadcd, with debug_info, not stripped # 보다시피 ELF 형식의 파일이다. # 커널 컴파일 과정에서 objcopy로 생성된 Image를 확인해보자. $ file arch/arm64/boot/Image arch/arm64/boot/Image: MS-DOS executable PE32+ executable (EFI application) Aarch64 (stripped to external PDB), for MS Windows # 현재 커널 config에 EFI 지원이 있어, MS-DOS 실행파일의 결과물로 나타난다. # arch/arm64/boot/Makefile 내에 있는 objcopy 플래그를 그대로 사용하여 Image를 직접 생성해보자. $ aarch64-linux-gnu-objcopy -O binary -R .note -R .note.gnu.build-id -R .comment -S vmlinux Image  # 직접 명령어로 생성한 Image와 커널 컴파일의 결과로 나온 Image와 비교해보자. $ diff Image arch/arm64/boot/Image # 동일한 바이너리 파일이므로 특별한 결과가 출력되지 않는다.     'use strict'; var containerId = JSON.parse(\"\\\"46a673584113c1a9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  실행된 objcopy 명령의 옵션을 확인해보면, binary 형식으로 obj(컴파일 과정에서 설명하는 그 목적 코드)들을 복사하는데, 이 때 .note, .comment 등의 섹션은 완전히 지우고, strip을 하게 되는데, 이 과정에서 실제 실행에 불필요한 모든 정보를 지우게 된다.\n즉 커널을 실행하기 위해 필요한 순수한 기계어만 남기는 과정이라 볼 수 있다.\nChapter.3 태스크 관리 Q. execl()을 통해 기존 프로세스의 수행 이미지가 바뀌는 과정에서 내부적으로 do_fork()가 일어나는 것이 아닐까? (p57) execl() 함수가 호출될 때, struct task_struct의 관계(PID, 부모 task 등)는 그대로 유지되지만 새로운 이미지를 실행하기 위한 부분(.text, .data, .stack, \u0026hellip;)만 변경된다.\n직접 예시로 나온 코드를 수정해서 확실한 관계를 확인해보자. 어떤 실행 파일이 출력을 하고 있는 것인지, PID가 몇 번인지 매번 확인할 수 있게 수정했다.\nfork_exec.c fork.c 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(int argc, char* argv[]) { pid_t pid; int exit_status; printf(\u0026#34;%s (%d): Before fork\\n\u0026#34;, argv[0], getpid()); if((pid=fork())\u0026lt;0){ perror(\u0026#34;fork error\u0026#34;); exit(1); } else if(pid == 0) { printf(\u0026#34;%s (%d): Before exec\\n\u0026#34;, argv[0], getpid()); execl(\u0026#34;./fork\u0026#34;, \u0026#34;fork\u0026#34;, (char *)0); printf(\u0026#34;%s (%d): After exec\\n\u0026#34;, argv[0], getpid()); } else { pid = wait(\u0026amp;exit_status); } printf(\u0026#34;%s (%d): Parent\\n\u0026#34;, argv[0], getpid()); return 0; }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int g = 2; int main(int argc, char* argv[]) { pid_t pid; int l = 3; int exit_status; printf(\u0026#34;%s (%d): Parent g=%d, l=%d\\n\u0026#34;, argv[0], getpid(), g, l); if((pid=fork())\u0026lt;0){ perror(\u0026#34;fork error\u0026#34;); exit(1); } else if(pid == 0) { g++; l++; } else { pid = wait(\u0026amp;exit_status); } printf(\u0026#34;%s (%d): g=%d, l=%d\\n\u0026#34;, argv[0], getpid(), g, l); return 0; }     # 각 소스 코드들을 컴파일한다. $ gcc fork.c -o fork $ gcc fork_exec.c -o fork_exec $ ./fork_exec ./fork_exec (3319361): Before fork ./fork_exec (3319362): Before exec fork (3319362): Parent g=2, l=3 fork (3319363): g=3, l=4 fork (3319362): g=2, l=3 ./fork_exec (3319361): Parent     'use strict'; var containerId = JSON.parse(\"\\\"ae62ef761a324e08\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }   fork_exec에서 fork() 함수를 호출하기 전의 프로세스(3319361)애서 \u0026ldquo;Before fork\u0026quot;를 출력한다. fork_exec에서 fork() 함수가 호출되었고, 그 중 자식 프로세스(3319362)에서 \u0026ldquo;Before exec\u0026quot;를 출력한다. fork_exec의 자식 프로세스(3319362)가 execl() 함수를 통해 다른 실행파일인 fork를 실행한다.\n(새로 실행시키는 것이 아닌, 실행 이미지를 교체한다.) 여전히 같은 프로세스 ID(3319362)를 가지는 것을 확인할 수 있다. 교체된 fork 프로세스(3319362)가 fork() 함수를 호출했고, 그 새로운 자식인 fork 프로세스 (3319363)가 생성되었다. 교체된 fork 프로세스(3319362)는 자신의 자식 프로세스 (3319363)이 종료되는 것을 기다린 뒤 출력하고 종료된다. 교체된 fork 프로세스(3319362)의 부모 프로세스 (3319361)는 자식 프로세스가 종료된 것을 확인한 뒤 \u0026ldquo;Parent\u0026quot;를 출력한다. 교체된 fork 프로세스(3319362)는 이미지가 fork_exec에서 fork로 교체되었기 때문에 \u0026ldquo;After exec\u0026quot;는 출력되지 않는다.  이 결과를 통해 이미지가 바뀌는 과정에서 do_fork()는 호출되지 않는 것을 확인할 수 있다. (더 정확한 실험을 하려면 trace를 해서 do_fork()가 호출되지 않았음을 증명하면 되지만, 일단 do_fork()의 결과로 PID가 바뀐다는 것을 통해 증명했다.)\n사실 이 질문이 생긴 원인은 하필 execl()로 교체하는 프로그램이 fork()를 호출하는 프로그램이라 헷갈리기 쉬웠던 것 같다.\nQ. 리눅스가 지원한다는 Linux exec 도메인, BSD나 SVR4 exec 도메인은 무슨 뜻인가? (p69) 해당 내용은 Understanding the linux kernel 내용을 참고하여 설명하도록 하겠다.\n리눅스는 다른 운영체제 용으로 컴파일 된 실행파일을 실행해 줄 수도 있다. (단, 같은 아키텍쳐라서 동일한 기계어를 실행할 수 있을 때를 기준으로 한다.)\n여기서 다른 운영체제라고 무조건 실행할 수 있는 것이 아니다.\n 에뮬레이션 된 실행: POSIX 호환되지 않는 시스템 콜이 있을 경우, 이에 대한 에뮬레이션을 지원해야 한다. Native 실행: 모든 시스템 콜이 POSIX 호환되어, 그대로 실행할 수 있다.  MS-DOS나 Windows의 경우, API 자체가 리눅스와 다르다. (당연히 UNIX를 뿌리로 두지 않기 때문에) 그래서 이를 에뮬레이션 하기 위해 Wine이나 DOSemu 등을 통해 API를 리눅스 환경에 맞게 변환해 주는 작업이 필요하다. (ex. WinAPI -\u0026gt; Syscall)\npersonality에 대한 설명을 읽어보면 해당 실행 파일이 (다른 운영체제 용으로 컴파일된) 커널의 기능을 얼마나 지원할 수 있는지에 대한 flag 형식으로 표현되는 것을 확인할 수 있다.\n이 부분은 리눅스 커널 분석 과정에서 중요한 부분이라기 보단, 이런 기능도 리눅스 커널에서 제공된다라고 하고 넘어갈 수 있을 것 같다. (해당 부분에 관심 있는 사람이라면 모를까)\nQ. n개의 CPU를 갖는 시스템에서는 임의의 시점에 최대 n개의 task라는 것이 Physical core인가? Logical processor인가? (p70) 하드웨어 제조사들마다 다른 용어를 쓰는 바람에 조금 헷갈릴 수도 있는데, 아래와 같이 정의해보겠다. (좀 더 정확한 정의는 추후 시도해 보도록 하겠다.)\n Physical core: 물리적으로 구별되는 CPU,\n일반적으로 제품 소개에 core라고 표기됨 (ex. Dual core -\u0026gt; Physical core 2개) Logical processor: 논리적으로 구별되는 CPU, 하이퍼쓰레드나 SMT 기술로 구현된 CPU 단위,\n최근 제품들의 경우 1개 physical core 당 2개의 logical processor가 지원되며, 전체 개수는 physical core의 개수보다 작을 수 없다.\n일반적으로 제품 소개에 thread라고 표기됨  추후 책에서 runqueue를 다룰 때, Logical processor를 뜻하는 것으로 예측된다. (p77)\n리눅스에서 $ cat /proc/cpuinfo를 해보면 Logical processor의 개수만큼 나타난다. 즉 리눅스 커널에서는 Logical processor를 CPU 단위로 취급하는 것으로 보인다.\nQ. EXIT_ZOMBIE 상태가 유지되는 경우(시스템에 불필요한 부하를 주는 상태)는 어떤 경우인가? (p71) 일반적인 프로세스의 경우, 부모 프로세스가 wait() 함수를 호출하여 자식 프로세스의 상태가 EXIT_DEAD로 바뀌게 허가해준다. 이 개념대로라면 부모가 wait() 함수를 호출하지 못하고 죽으면(ex. SEGFAULT) 자식 프로세스는 좀비 프로세스 상태가 계속 유지되는 것이라 생각하고 있었다.\n하지만 wait() 시스템 콜의 설명에서 아래와 같은 설명이 있다. (man 2 wait에서 NOTES 부분을 확인해 보면 자세한 설명이 나와있다.)\n A child that terminates, but has not been waited for becomes a \u0026ldquo;zombie\u0026rdquo;. The kernel maintains a minimal set of information about the zombie process (PID, termination status, resource usage information) in order to allow the parent to later perform a wait to obtain information about the child. As long as a zombie is not removed from the system via a wait, it will consume a slot in the kernel process table, and if this table fills, it will not be possible to create further processes. If a parent process terminates, then its \u0026ldquo;zombie\u0026rdquo; children (if any) are adopted by init(1), (or by the nearest \u0026ldquo;subreaper\u0026rdquo; process as defined through the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation); init(1) automatically performs a wait to remove the zombies.\n 해석하면 아래와 같다.\n 자식 프로세스가 종료되었지만 부모 프로세스로부터 wait을 호출받지 못하면 좀비 프로세스가 된다. 커널은 좀비 프로세스에 대한 최소한의 정보(PID, 종료 상태, 자원 사용 정보)를 유지하여, 추후 부모 프로세스가 나중에 wait을 했을 때 이 정보들을 얻을 수 있게 한다. 좀비 프로세스가 wait으로 제거되지 않는 상태로 유지된다면, 커널의 프로세스 테이블의 한 칸을 계속 소모하고 있는 것이며, 해당 테이블이 꽉 찰 경우 추후 새로운 프로세스를 생성할 수 없게 된다. 만약 부모 프로세스가 종료되면, 그 프로세스에 딸려 있던 좀비 자식 프로세스들은 init 프로세스에게 입양된다. (혹은 prctl 시스템콜의 PR_SET_CHILD_SUBREAPER 동작을 수행한 가장 가까운 subreaper에게 입양된다.) init은 자동으로 wait을 수행하여 좀비 프로세스들을 삭제한다.\n 좀비 프로세스가 되는 데 가장 중요한 것은 wait()의 호출이 이루어 지지 않는 것이었다.\n직접 내가 생각했던 방법과, wait의 설명에서 한 내용을 실험해보자.\nparent_segfault.c no_wait.c parent_segfault 실행 no_wait 실행  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt; int main(void) { pid_t pid; int status; if ((pid = fork()) \u0026lt; 0) { perror(\u0026#34;fork\u0026#34;); exit(1); } if (pid == 0) { /* Child waits 50 second and terminate */ sleep(50); exit(0); } else { /* Parent will be terminated before the child\u0026#39;s termination */ char *msg = \u0026#34;Test\u0026#34;; msg[0] = \u0026#39;S\u0026#39;; /* triggering segfault */ } return 0; }   #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt; int main(void) { pid_t pid; int status; if ((pid = fork()) \u0026lt; 0) { perror(\u0026#34;fork\u0026#34;); exit(1); } /* Child */ if (pid == 0) { /* Child terminate immediately */ exit(0); } else { /* Parent waits 50 second and terminate */ sleep(50); } return 0; }   # 실행파일로 컴파일한다. $ gcc parent_segfault.c -o parent_segfault # parent_segfault 실행한다. (ps로 결과를 확인해야 하므로 \u0026amp;을 붙여 백그라운드 실행시킨다.) $ ./parent_segfault \u0026amp; [1] 1244753 [1] + 1244753 segmentation fault (core dumped) ./parent_segfault # 바로 ps 명령으로 ./parent_segfault의 자식 프로세스 상태를 조회해 보자. $ ps -ef | grep parent_segfault jsyoo5b 1244755 1 0 13:40 pts/2 00:00:00 ./parent_segfault jsyoo5b 1245371 4116883 0 13:40 pts/2 00:00:00 grep ... # grep 명령의 process # 50초 뒤에 다시 조회하여 zombie상태인지 확인해보자. $ ps -ef | grep parent_segfault jsyoo5b 1247619 4116883 0 13:42 pts/2 00:00:00 grep ... # grep 명령의 process # 아무 결과도 나타나지 않는다.   # 실행파일로 컴파일한다. $ gcc no_wait.c -o no_wait # no_wait 실행한다. (ps로 결과를 확인해야 하므로 \u0026amp;을 붙여 백그라운드 실행시킨다.) $ ./no_wait \u0026amp; [1] 1257718 # 바로 ps 명령으로 ./no_wait의 자식 프로세스 상태를 조회해 보자. $ ps -ef | grep no_wait jsyoo5b 1257718 4116883 0 13:47 pts/2 00:00:00 ./no_wait jsyoo5b 1257720 1257718 0 13:47 pts/2 00:00:00 [no_wait] \u0026lt;defunct\u0026gt; jsyoo5b 1257956 4116883 0 13:47 pts/2 00:00:00 grep ... # grep 명령의 process # 50초 뒤에 다시 조회하여 zombie상태인지 확인해보자. $ ps -ef | grep no_wait jsyoo5b 1264140 4116883 0 13:51 pts/2 00:00:00 grep ... # grep 명령의 process # 아무 결과도 나타나지 않는다.     'use strict'; var containerId = JSON.parse(\"\\\"bcb18e317e973153\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위의 실험에서 parent_segfault는 부모 프로세스가 강제 종료될 수 있도록 강제로 SEGFAULT를 일으켰다. 부모 프로세스가 강제 종료되면 부모 프로세스가 1(init 프로세스)으로 변경된 것을 볼 수 있다.\n반대로 자식이 먼저 종료되도록 부모가 wait()을 호출하지 않는 경우, 자식 프로세스는 \u0026lt;defunct\u0026gt; 상태가 되는데, 이 상태가 좀비 프로세스 상태임을 의미한다. 자식 프로세스는 50초동안 부모 프로세스에서 wait()를 호출하길 기다리며 좀비 프로세스 상태였지만, 부모 프로세스는 그냥 종료되었고, 아마 1(init 프로세스)에게 입양되어, wait() 처리를 통해 종료되었을 것이다.\nQ. SIGKILL이 발생하는 경우는 어떤 경우인가? (p72) 스터디 당시 Ctrl+C로 발생시키는 것이 아니냐고 했는데, Ctrl+C는 SIGKILL이 아니라 SIGINT(Interrupt Signal)다. 아마 Ctrl+C를 통해 실행 중이던 프로세스를 종료시키기 때문에 그런 것으로 생각할텐데, 정확하게 설명하자면 SIGINT의 기본 핸들러가 해당 프로세스의 종료기 때문이다.\nSIGINT의 핸들러를 직접 정의하는 예제를 간단하게 짜 보았다. 참고로 signal()을 사용하는 것은 좋지 않으며, sigaction()을 사용하는 것이 좋다고 알고 있으나, 이 부분은 추후 제대로 공부하고 글을 쓰도록 하겠다. (게다가 간단한 예제라서 공을 들이지 않은 것도 있다.)\nsigint_hndl.c 실행 결과  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;signal.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #define SIGINT_THRESHOLD 3  void sigint_hndl(int signo) { static int sigint_cnt = 0; if (signo == SIGINT) { sigint_cnt++; if (sigint_cnt \u0026lt; SIGINT_THRESHOLD) { printf(\u0026#34; Send %d more SIGINT to terminate\\n\u0026#34;, (SIGINT_THRESHOLD - sigint_cnt)); } else { exit(0); } } } int main(void) { signal(SIGINT, sigint_hndl); while(1) sleep(1); return 0; }   # 실행파일로 컴파일한다. $ gcc sigint_hndl.c -o sigint_hndl # sigint_hndl을 실행하고 Ctrl+C를 3번 입력하여 종료시킨다. $ ./sigint_hndl ^C Send 2 more SIGINT to terminate ^C Send 1 more SIGINT to terminate ^C # Ctrl+C를 3번째 입력받고 나서야 종료된다. (signal handler에 작성한 대로 동작함)     'use strict'; var containerId = JSON.parse(\"\\\"3909331dd833a856\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  다시 본론으로 돌아와서, SIGKILL은 명시적으로 호출했을 때만 발생한다. 대표적인 경우로 kill -9 $PID와 같은 명령어를 통해 종료시키는 방법이 있다. (여기서 9는 SIGKILL의 portable number다.)\n프로세스를 종료시키는 시그널 종류는 SIGTERM, SIGINT, SIGQUIT, SIGKILL, SIGHUP이 존재한다.\n SIGTERM은 종료 요청으로, kill 명령이 보내는 기본 시그널이다.\nGUI에서 종료버튼을 누르거나, Task Manager에서 종료 요청을 보낼 때와 비슷하다고 볼 수 있다.\n문서 작업 프로그램의 경우 종료 요청 시 저장하겠냐고 다시 물어보는 동작을 하듯, 사용자가 작성한 핸들러를 동작시킬 수 있다. SIGINT는 위에서 설명했듯 Program interrupt를 보내는 것이다. INTR 글자의 가장 일반적인 예가 우리가 아는 Ctrl+C이다. SIGQUIT는 SIGINT와 비슷하지만 다른 QUIT 글자 (Ctrl+\\)로 발생되며, core dump를 발생시킨다.\n사용자가 직접 프로그램 에러를 발생시키며 종료시키는 경우라 볼 수 있다. (다른 예시로는 SEGFAULT 등의 오류로 인해 프로그램에서 에러 시그널을 발생하는 경우가 있다.) SIGHUP는 hang-up 신호로, 사용자 터미널의 연결이 끊긴 경우 이를 알려 동작중이던 프로세스들이 종료되라고 알리는 것이다. (네트워크 연결 끊김 등)  위 예시된 시그널등과 달리 SIGKILL은 해당 프로세스의 의사와 관계 없이 (핸들러를 등록하지 못하고) 강제 종료할 때 사용된다.\n시스템을 종료시키는 shutdown의 경우, SIGTERM과 SIGKILL의 용도를 확실히 알 수 있게 해 준다.\n 먼저 모든 프로세스에 SIGTERM을 보내, 자발적으로 종료되길 기다린다. 혹시나 SIGTERM에도 종료되지 않은 프로세스들을 강제 종료시키기 위해 SIGKILL을 보낸다.  일부 시스템 관리 프로그램의 경우, lock을 잡고 있거나, db를 수정하고 있는 데 SIGKILL만으로 종료하면 프로그램의 상태가 이상해진 상태로 종료되므로, 기본적으로는 SIGTERM으로 종료시키는 것이 적합하다.\n","description":"","id":9,"section":"posts","tags":["커널"],"title":"[iamroot] 1주차 스터디 회고 (리눅스 커널 내부구조)","uri":"https://devlog.jsyoo5b.net/ko/posts/linux-kernel/iamroot/week1-lki/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n5장. fmt 패키지를 이용한 텍스트 입출력 GUI나 웹 서버 등 다른 interface를 사용하는 app이 아니라면 기본적으로 console로 입출력이 이루어진다. go에서는 fmt 패키지를 통해 콘솔의 입출력을 처리한다.\n줄바꿈 (CR, LF) fmt.Println() 함수는 인자로 들어온 내용을 출력하고, 이후 줄바꿈을 진행한다. 이 때 줄바꿈에 대한 ASCII 코드는 플랫폼에 따라 다르다. 그런데 go에서는 compile시 알아서 해당 플랫폼에 대한 줄바꿈 ASCII 코드를 사용한다. go에서는 무조건 LF만 출력한다.\n줄바꿈에 대한 ASCII 코드는 LF(Line Feed, 0x0A), CR(Carrige Return, 0x0D)가 있는데, 이는 타자기 시절의 줄바꿈 행동과 관계가 있다.\nLF는 타자기의 커서 위치에서 줄(세로 방향)을 하나 아래로 내리는 행위를 의미했으며, CR은 타자기의 커서 위치를 해당 줄의 시작 부분으로 옮기는(가로 방향) 행위를 의미한다.\nCR LF를 둘 다 쓰는 유명한 예외인 Windows에서 해당 문제에 대한 이슈가 제기되었다. 해당 이슈를 확인해 본 결과 CR LF 출력 문제를 지원하지 않겠다고 했다.\n하지만 실제 Windows에서 실행해보면, 무조건 CR LF를 같이 출력하는 것을 확인할 수 있다.\nGo 코드 실행 결과  1 2 3 4 5 6 7 8  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Println\u0026#34;) fmt.Print(\u0026#34;Print with \\\\n\\n\u0026#34;) }     PS \u0026gt; .\\go_newline.exe | xxd 00000000: 5072 696e 746c 6e0d 0a50 7269 6e74 2077 Println..Print w 00000010: 6974 6820 5c6e 0d0a ith \\n..     'use strict'; var containerId = JSON.parse(\"\\\"a10e7d33db44bad7\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  보다시피 Println()을 호출할 때나, Print()에서 \\n을 호출할 때나 무조건 CR LF를 출력하는 것을 확인할 수 있다.\nGo 언어에서 구현된 Println()의 내역을 확인해보면 그냥 \\n만 마지막에 출력하는 것으로 확인할 수 있다.\n즉 go에서는 무조건 줄바꿈에 LF만 사용하는 것을 확인할 수 있다. 아마 CR LF 문제는 Windows에서 처리하도록 변경된 것으로 보인다. 해당 부분에 대한 조사가 필요할 것 같다.\nPrintf의 formatter Printf()는 각 변수를 형식에 맞춰 출력시키는 함수다. 그리고 해당 형식을 표현하는 formatter 종류는 다양하게 존재한다.\ngo는 강 타입 언어로, 명시적으로 타입 변환을 해야하는데, Printf()의 인자로 들어가는 경우에는 타입을 강제로 지정하지 않는다. (interface를 인자로 받는데, 이게 타입 검사를 강제화 하지 않는 것으로 보인다.) 억지로 type에 맞지 않는 formatter를 사용해보자.\nGo 코드 실행 결과  1 2 3 4 5 6 7 8 9  package main import \u0026#34;fmt\u0026#34; func main() { var num int = 1010; fmt.Printf(\u0026#34;%d %t %f %s\u0026#34;, num, num, num, num); }     $ ./go_printf 1010 %!t(int=1010) %!f(int=1010) %!s(int=1010) # 빌드 과정에서 에러로 취급되지 않은 경고문을 확인 $ go vet go_printf.go # command-line-arguments ./go_printf.go:8:2: Printf format %t has arg num of wrong type int     'use strict'; var containerId = JSON.parse(\"\\\"7b6e9a0f10a58ce2\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  자체적으로 잘못된 formatter를 사용했음을 Printf()의 결과로 알린다.\n입력 scan 과정의 오류 fmt.Scan() 등의 함수를 통해 입력을 받을 수 있는데, 여기도 C처럼 address를 전달한다. Call by address 방식만 지원되는 것으로 보인다.\nScan() 과정에서 원하는 타입대로 입력하지 않으면 오류가 발생한다. 이때 Error 처리를 stderr로 출력하지 않고, 해당 함수의 인자로 에러 알림을 변수로 받을 수 있다.\nGo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \u0026#34;fmt\u0026#34; func main() { var num1 int var num2 int fmt.Print(\u0026#34;Enter 2 numbers: \u0026#34;) n, err := fmt.Scanln(\u0026amp;num1, \u0026amp;num2) if err != nil { fmt.Println(err) } else { fmt.Printf(\u0026#34;%d numbers entered, num1: %d, num2: %d\u0026#34;, n, num1, num2) } }     $ ./go_scan Enter 2 numbers: 3 4 2 numbers entered, num1: 3, num2: 4 # 일부러 잘못된 값을 입력해보자. $ ./go_scan Enter 2 numbers: hello expected integer     'use strict'; var containerId = JSON.parse(\"\\\"b72a35be2bcd84f5\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  추가적으로 fmt.Scanln()에서 return값을 할당하는 과정에서 볼 수 있듯, go에서는 함수에서 여러 값을 반환할 수 있는 것으로 보인다.\n사용되지 않는 변수에 대한 오류 go에서는 선언하고 사용되지 않는 (reference되지 않는) 변수를 허용하지 않는다. fmt.Scanln()과 같이 여러 값을 반환하는 함수에서 일부 값만 사용하고, 나머지를 버리기 위해서는 _(blank identifier)를 사용하면 된다.\nGo 코드 (unref.go) Go 코드 (blank.go) 빌드 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \u0026#34;fmt\u0026#34; func main() { var num1 int var num2 int fmt.Print(\u0026#34;Enter 2 numbers: \u0026#34;) n, err := fmt.Scanln(\u0026amp;num1, \u0026amp;num2) \tif err != nil { fmt.Println(err) } else { fmt.Printf(\u0026#34;num1: %d, num2: %d\u0026#34;, num1, num2) } }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \u0026#34;fmt\u0026#34; func main() { var num1 int var num2 int fmt.Print(\u0026#34;Enter 2 numbers: \u0026#34;) _, err := fmt.Scanln(\u0026amp;num1, \u0026amp;num2) \tif err != nil { fmt.Println(err) } else { fmt.Printf(\u0026#34;num1: %d, num2: %d\u0026#34;, num1, num2) } }     # unref.go를 빌드 $ go build # unref ./unref.go:10:2: n declared but not used # blank.go를 빌드 (문제 없음) $ go build     'use strict'; var containerId = JSON.parse(\"\\\"06bcff91d6ced100\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"","id":10,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 5장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch05/"},{"content":"『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트입니다.\n4장. 변수 일단 이 책에서는 내가 생각하는 컴퓨터공학의 핵심이라 생각하는 타입의 개념에 대해 충실히 설명하고 있다.\n예를 들어 1과 1.0은 다르고, 숫자 1234와 전화번호 1234가 다른 것 처럼 적절한 타입으로 표현하는 것(프로그래머의 추상화 관점)과, 이를 통해 컴퓨터가 메모리의 값을 적절한 방식으로 해석하게 됨(하드웨어 구현 관점)을 설명하고 있다.\nint의 크기 go언어에서는 int의 크기가 시스템의 크기에 따라 결정된다고 한다. 책에 나온 정의가 약간 부정확해 보여서 직접 실험해봤다. 컴파일 환경의 비트에 따라 달라진다가 좀 더 정확한 표현인 것 같다.\ngo 코드 32bit 실행 64bit 실행  1 2 3 4 5 6 7 8 9 10  package main import \u0026#34;fmt\u0026#34; func main() { var intMax uint = ^uint(0) fmt.Println(intMax) }     # 명시적으로 x86 32bit로 컴파일 하려면 앞에 환경변수를 변경한다. $ GOARCH=386 GO386=softfloat go build # 32bit 실행파일 확인 $ file go_intmax go_intmax: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, Go BuildID=whcf5YULQAGTt7WJw_Bi/_S-7XiOp74YDhMdaR-XW/kAzTzAYBcTiwIMmaKgmI/NcdUi1SXls08b19JVtIc, not stripped $ ./go_intmax 4294967295   # 명시적으로 x86 64bit로 컴파일 하려면 앞에 환경변수를 변경한다. $ GOARCH=amd64 go build # 64bit 실행파일 확인 $ file go_intmax go_intmax: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=WUYerYNB9m74ls69fi0P/-XlxGK553eA5t4u4wzct/aa8a3tMsB8mwewlWCl3k/P0xI5AHDRcm1sthL6TCV, not stripped $ ./go_intmax 18446744073709551615     'use strict'; var containerId = JSON.parse(\"\\\"bc5980c94fbed3f7\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  참고로 C의 경우 int 크기의 정의가 해당 프로세서가 가장 효율적으로 사용할 수 있는 크기로 정의되어 있다.\n일반적으로 32bit 환경이거나 64bit 환경이거나 모두 32bit를 사용하고 있으며 (과거 16bit 시절에는 16bit를 사용했음.) 실질적인 32~64의 적용은 long type에 적용되거나, pointer의 크기에만 적용된다.\n실제 C에서 적용되는 자료형 크기 정보는 C language data type model를 참고하기 바란다.\nstring, rune go에서는 모든 문자열을 UTF-8로 인코딩해서 나타내며, 모든 문자를 표현하기 위한 타입을 rune 타입이라 정의했다. rune이 int32의 별칭이라는 것으로 보아, UCS를 모두 표현하는 것으로 보인다.\n실제 문자열이 utf-8로 인코딩 되어 있는지 확인해보자.\ngo 코드 실행 결과  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import \u0026#34;fmt\u0026#34; func main() { var multilingual string = \u0026#34;English와 한글이 섞인\u0026#34; fmt.Println(multilingual) multiLingRunes := []rune(multilingual) multiLingBytes := []byte(multilingual) fmt.Println(multiLingRunes) fmt.Println(multiLingBytes) }     $ ./go_multilingual English와 한글이 섞인 [69 110 103 108 105 115 104 50752 32 54620 44544 51060 32 49438 51064] [69 110 103 108 105 115 104 236 153 128 32 237 149 156 234 184 128 236 157 180 32 236 132 158 236 157 184]     'use strict'; var containerId = JSON.parse(\"\\\"9fcf122cc016c367\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  var의 명시적 표기 필요성 go에서 변수 선언에는 var 키워드를 사용하는데, := 할당자를 통해 묵시적으로 변수 선언이 가능하다. 묵시적인 표기로도 선언이 가능한데 왜 굳이 var라는 키워드가 필요할까?\n혹시 kotlin처럼 var와 val의 차이가 있는 건가 싶었는데, go에서는 const 키워드로 상수를 표현한다고 한다.\n굳이 var 키워드가 꼭 필요한가 싶어서 확인해보니, 전역변수 선언에서는 묵시적 선언이 불가능 한 것으로 보인다.\ngo 코드 빌드 결과  1 2 3 4 5 6 7 8 9 10 11  package main import \u0026#34;fmt\u0026#34; var testVar1 int = 10 testVar2 := 10  func main() { fmt.Println(testVar1) fmt.Println(testVar2) }     $ go build # go_var ./go_var.go:6:1: syntax error: non-declaration statement outside function body     'use strict'; var containerId = JSON.parse(\"\\\"821e650fbd8860be\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"","id":11,"section":"posts","tags":["golang"],"title":"Tucker의 Go 언어 프로그래밍 4장 요약","uri":"https://devlog.jsyoo5b.net/ko/posts/golang/musthave/ch04/"},{"content":"리눅스 커널 소스에 첫 기여를 한 기념으로 어떻게 기여하게 되었는지 그 과정을 공유한다. 사실 코드를 수정한 것도 아니고, 고작 1줄에 불과하기때문에 그렇게 대단한 것은 아니라고 생각하지만, 그 기여를 위해 어떤 판단을 했고, 어떻게 자료 조사를 했는지에 대한 경험을 공유하고자 한다.\n어떻게 기여할 만한 것을 찾았는가? 리눅스 커널에서는 관련 문서를 Documentation/ 에서 관리하고 있다. 보통 *.rst나 *.txt로 각 주제에 대한 글을 작성해 놓은 상태다.\n물론 해당 문서 파일들을 더 효과적인 방식으로 변환하는 기능도 제공한다. 예를 들어 make pdfdocs, make htmldocs 등이 있다. 말 그대로 pdf문서로 변환해주거나, HTML로 변환하여 웹에서 제공할 수 있게 해준다.\n현재 iamroot 커널 스터디를 진행하고 있는데, 추후 개념 관련 정리를 rst로 작성하여 웹으로 배포하면 좋겠다는 생각이 들어서 htmldocs로 변환하는 부분을 실험해봤다. 그런데 오류 메시지만으로는 해결할 수 없는 상태가 발생했고, 이를 수정하는 과정을 기여할 수 있었다.\n커널의 make htmldocs 커널에서 문서를 HTML로 변환할 때 sphinx라는 도구를 사용한다.\nshell  $ make htmldocs Documentation/Makefile:30: The \u0026#39;sphinx-build\u0026#39; command was not found. Make sure you have Sphinx installed and in PATH, or set the SPHINXBUILD make variable to point to the full path of the \u0026#39;sphinx-build\u0026#39; executable. Detected OS: Ubuntu 20.04.1 LTS. Warning: better to also install \u0026#34;convert\u0026#34;. Warning: better to also install \u0026#34;dot\u0026#34;. Warning: better to also install \u0026#34;dvipng\u0026#34;. Warning: better to also install \u0026#34;fonts-noto-cjk\u0026#34;. Warning: better to also install \u0026#34;latexmk\u0026#34;. Warning: better to also install \u0026#34;rsvg-convert\u0026#34;. You should run: sudo apt-get install imagemagick graphviz dvipng fonts-noto-cjk latexmk librsvg2-bin Warning: It is recommended at least Sphinx version 1.7.9. If you want pdf, you need at least 2.4.4. Note: It is recommended at least Sphinx version 2.4.4 if you need PDF support. Can\u0026#39;t build as 1 mandatory dependency is missing at ./scripts/sphinx-pre-install line 853. /usr/bin/python3 -m venv sphinx_2.4.4 . sphinx_2.4.4/bin/activate pip install -r ./Documentation/sphinx/requirements.txt If you want to exit the virtualenv, you can use: deactivate make[1]: *** [Documentation/Makefile:32: htmldocs] Error 2 make: *** [Makefile:1658: htmldocs] Error 2     'use strict'; var containerId = JSON.parse(\"\\\"2c26a7ac12e49484\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  만약 sphinx가 설치되어 있지 않다면 위와 같이 에러문이 출력된다. 각 OS에 따라 sphinx, 기타 관련 추천 패키지를 설치하기 위한 명령을 알려준다. 참고로 sphinx는 python 패키지로 설치되기 때문에 효과적인 관리를 위해 virtualenv를 생성하고, 그 위에서 pip를 통해 문서 생성에 필요한 패키지를 자동으로 설치시킨다. 필요한 패키지는 requirements.txt 안에 정의되어 있다.\nSphinx 설치 후 재시도 위의 명령과 비슷하게 virtualenv를 설정하고 필요 패키지를 설치한 다음 다시 make htmldocs를 시도해보자. (나는 git 관리의 편의를 위해 virtualenv 디렉토리를 .sphinx로 변경했다.)\nshell  $ /usr/bin/python3 -m venv .sphinx $ . .sphinx/bin/activate $ pip install -r ./Documentation/sphinx/requirements.txt Collecting docutils Downloading docutils-0.16-py2.py3-none-any.whl (548 kB) |████████████████████████████████| 548 kB 1.9 MB/s Collecting Sphinx==2.4.4 Downloading Sphinx-2.4.4-py3-none-any.whl (2.7 MB) |████████████████████████████████| 2.7 MB 11.2 MB/s Collecting sphinx_rtd_theme Downloading sphinx_rtd_theme-0.5.0-py2.py3-none-any.whl (10.8 MB) |████████████████████████████████| 10.8 MB 11.6 MB/s : # (다른 설치 기록은 생략함) Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Pygments-2.7.3 Sphinx-2.4.4 alabaster-0.7.12 babel-2.9.0 certifi-2020.12.5 chardet-3.0.4 docutils-0.16 idna-2.10 imagesize-1.2.0 packaging-20.7 pyparsing-2.4.7 pytz-2020.4 requests-2.25.0 snowballstemmer-2.0.0 sphinx-rtd-theme-0.5.0 sphinxcontrib-applehelp-1.0.2 sphinxcontrib-devhelp-1.0.2 sphinxcontrib-htmlhelp-1.0.3 sphinxcontrib-jsmath-1.0.1 sphinxcontrib-qthelp-1.0.3 sphinxcontrib-serializinghtml-1.1.4 urllib3-1.26.2 $ make htmldocs  SPHINX htmldocs --\u0026gt; file:///home/jsyoo5b/Workspace/Kernel/iamroot/Documentation/output PARSE include/uapi/linux/dvb/audio.h PARSE include/uapi/linux/dvb/ca.h PARSE include/uapi/linux/dvb/dmx.h PARSE include/uapi/linux/dvb/frontend.h PARSE include/uapi/linux/dvb/net.h PARSE include/uapi/linux/dvb/video.h PARSE include/uapi/linux/videodev2.h PARSE include/uapi/linux/media.h PARSE include/uapi/linux/cec.h PARSE include/uapi/linux/lirc.h Running Sphinx v2.4.4 Extension error: Could not import extension kfigure (exception: No module named \u0026#39;six\u0026#39;) enabling CJK for LaTeX builder make[1]: *** [Documentation/Makefile:82: htmldocs] Error 2 make: *** [Makefile:1658: htmldocs] Error 2     'use strict'; var containerId = JSON.parse(\"\\\"0fadd14fec1e030b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  문서를 생성하던 도중 에러가 발생한다. 하지만 어떻게 해결해야 하는지에 대한 해결법은 나오지 않는다. 이 부분이 내가 기여한 이슈의 시작점이다.\nSphinx 문서 생성의 문제점 분석 위의 make htmldocs에서 에러가 난 부분만 다시 집중해보자.\nshell  $ make htmldocs  SPHINX htmldocs --\u0026gt; file:///home/jsyoo5b/Workspace/Kernel/iamroot/Documentation/output PARSE include/uapi/linux/dvb/audio.h PARSE include/uapi/linux/dvb/ca.h PARSE include/uapi/linux/dvb/dmx.h PARSE include/uapi/linux/dvb/frontend.h PARSE include/uapi/linux/dvb/net.h PARSE include/uapi/linux/dvb/video.h PARSE include/uapi/linux/videodev2.h PARSE include/uapi/linux/media.h PARSE include/uapi/linux/cec.h PARSE include/uapi/linux/lirc.h Running Sphinx v2.4.4 Extension error: Could not import extension kfigure (exception: No module named \u0026#39;six\u0026#39;) enabling CJK for LaTeX builder make[1]: *** [Documentation/Makefile:82: htmldocs] Error 2 make: *** [Makefile:1658: htmldocs] Error 2     'use strict'; var containerId = JSON.parse(\"\\\"5b144b2fba691ab2\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  kfigure라는 extension을 import할수 없는데, 그 이유는 six란 모듈을 찾을수 없기 때문이라고 한다. 일단 kfigure가 뭔지 확인해보자.\nshell  $ ls Documentation/sphinx/ automarkup.py kernel_include.py load_config.py parse-headers.pl cdomain.py kernellog.py maintainers_include.py requirements.txt kerneldoc.py kfigure.py parallel-wrapper.sh rstFlatTable.py     'use strict'; var containerId = JSON.parse(\"\\\"2c82ab9d4c65deb4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  kfigure는 Documentation/sphinx/에 작성된 모듈로, rst에서 그린 그림을 이미지로 변환해주는 모듈이다. 그럼 해당 파일의 내용에서 six가 사용되는 부분을 확인해보자.\nDocumentation/sphinx/kfigure.py (상단 import 부분) Documentation/sphinx/kfigure.py (하단 사용 부분)  57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  from docutils.parsers.rst.directives import images import sphinx from sphinx.util.nodes import clean_astext from six import iteritems  import kernellog PY3 = sys.version_info[0] == 3 if PY3: _unicode = str else: _unicode = unicode # Get Sphinx version major, minor, patch = sphinx.version_info[:3] if major == 1 and minor \u0026gt; 3: # patches.Figure only landed in Sphinx 1.4 from sphinx.directives.patches import Figure # pylint: disable=C0413 else: Figure = images.Figure __version__ = \u0026#39;1.0.0\u0026#39;     528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557  def add_kernel_figure_to_std_domain(app, doctree): \u0026#34;\u0026#34;\u0026#34;Add kernel-figure anchors to \u0026#39;std\u0026#39; domain. The ``StandardDomain.process_doc(..)`` method does not know how to resolve the caption (label) of ``kernel-figure`` directive (it only knows about standard nodes, e.g. table, figure etc.). Without any additional handling this will result in a \u0026#39;undefined label\u0026#39; for kernel-figures. This handle adds labels of kernel-figure to the \u0026#39;std\u0026#39; domain labels. \u0026#34;\u0026#34;\u0026#34; std = app.env.domains[\u0026#34;std\u0026#34;] docname = app.env.docname labels = std.data[\u0026#34;labels\u0026#34;] for name, explicit in iteritems(doctree.nametypes):  if not explicit: continue labelid = doctree.nameids[name] if labelid is None: continue node = doctree.ids[labelid] if node.tagname == \u0026#39;kernel_figure\u0026#39;: for n in node.next_node(): if n.tagname == \u0026#39;caption\u0026#39;: sectname = clean_astext(n) # add label to std domain labels[name] = docname, labelid, sectname break       'use strict'; var containerId = JSON.parse(\"\\\"d5f4778363230879\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  확인해보니 six에서 iteritem 함수를 사용하는데, 현재 virtualenv에서 설치한 패키지 중에는 six가 존재하지 않는 것 같다.\n문제의 six 패키지에 대한 정보를 검색해보니 python2와 python3 사이의 호환성을 유지하기 위해 사용하는 모듈이라 한다. 그런데 왜 six는 자동으로 설치되지 않았을까?\nrequirements.txt 확인 일단 Sphinx를 실행시키는 환경의 requirements.txt의 내용을 확인해보자.\nDocumentation/sphinx/requirements.txt  docutils Sphinx==2.4.4 sphinx_rtd_theme     'use strict'; var containerId = JSON.parse(\"\\\"f8b340231cb02de8\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  설치 목록에 six가 없는 것을 알 수 있다. 하지만 지금 증상을 다른 사람들이 눈치채지 못했다는 것은, 저기 목록에 있는 패키지 중에 하나가 원래는 six를 자동으로 설치했을 것이다.\n이전 설치기록을 보면 알 수 있듯이, 위 3가지 패키지를 설치하기 위해 그 패키지들이 필요로 하는 하위 의존성 있는 패키지들을 같이 설치한 것을 볼 수 있다.\nshell  $ pip install -r ./Documentation/sphinx/requirements.txt Collecting docutils Downloading docutils-0.16-py2.py3-none-any.whl (548 kB)  |████████████████████████████████| 548 kB 1.9 MB/s Collecting Sphinx==2.4.4 Downloading Sphinx-2.4.4-py3-none-any.whl (2.7 MB)  |████████████████████████████████| 2.7 MB 11.2 MB/s Collecting sphinx_rtd_theme Downloading sphinx_rtd_theme-0.5.0-py2.py3-none-any.whl (10.8 MB)  |████████████████████████████████| 10.8 MB 11.6 MB/s Collecting Pygments\u0026gt;=2.0 Downloading Pygments-2.7.3-py3-none-any.whl (950 kB) |████████████████████████████████| 950 kB 6.4 MB/s Collecting babel!=2.0,\u0026gt;=1.3 Downloading Babel-2.9.0-py2.py3-none-any.whl (8.8 MB) |████████████████████████████████| 8.8 MB 11.8 MB/s Requirement already satisfied: setuptools in ./.sphinx/lib/python3.8/site-packages (from Sphinx==2.4.4-\u0026gt;-r ./Documentation/sphinx/requirements.txt (line 2)) (44.0.0) Collecting requests\u0026gt;=2.5.0 Downloading requests-2.25.0-py2.py3-none-any.whl (61 kB) |████████████████████████████████| 61 kB 8.1 MB/s Collecting sphinxcontrib-serializinghtml Downloading sphinxcontrib_serializinghtml-1.1.4-py2.py3-none-any.whl (89 kB) |████████████████████████████████| 89 kB 8.1 MB/s Collecting sphinxcontrib-jsmath Downloading sphinxcontrib_jsmath-1.0.1-py2.py3-none-any.whl (5.1 kB) Collecting sphinxcontrib-htmlhelp Downloading sphinxcontrib_htmlhelp-1.0.3-py2.py3-none-any.whl (96 kB) |████████████████████████████████| 96 kB 6.3 MB/s Collecting packaging Downloading packaging-20.7-py2.py3-none-any.whl (35 kB) Collecting alabaster\u0026lt;0.8,\u0026gt;=0.7 Downloading alabaster-0.7.12-py2.py3-none-any.whl (14 kB) Collecting sphinxcontrib-devhelp Downloading sphinxcontrib_devhelp-1.0.2-py2.py3-none-any.whl (84 kB) |████████████████████████████████| 84 kB 2.9 MB/s Collecting sphinxcontrib-qthelp Downloading sphinxcontrib_qthelp-1.0.3-py2.py3-none-any.whl (90 kB) |████████████████████████████████| 90 kB 8.9 MB/s Collecting snowballstemmer\u0026gt;=1.1 Downloading snowballstemmer-2.0.0-py2.py3-none-any.whl (97 kB) |████████████████████████████████| 97 kB 7.4 MB/s Collecting imagesize Downloading imagesize-1.2.0-py2.py3-none-any.whl (4.8 kB) Collecting Jinja2\u0026gt;=2.3 Downloading Jinja2-2.11.2-py2.py3-none-any.whl (125 kB) |████████████████████████████████| 125 kB 12.3 MB/s Collecting pytz\u0026gt;=2015.7 Downloading pytz-2020.4-py2.py3-none-any.whl (509 kB) |████████████████████████████████| 509 kB 12.2 MB/s Collecting chardet\u0026lt;4,\u0026gt;=3.0.2 Downloading chardet-3.0.4-py2.py3-none-any.whl (133 kB) |████████████████████████████████| 133 kB 12.1 MB/s Collecting idna\u0026lt;3,\u0026gt;=2.5 Downloading idna-2.10-py2.py3-none-any.whl (58 kB) |████████████████████████████████| 58 kB 7.7 MB/s Collecting urllib3\u0026lt;1.27,\u0026gt;=1.21.1 Downloading urllib3-1.26.2-py2.py3-none-any.whl (136 kB) |████████████████████████████████| 136 kB 13.2 MB/s Collecting certifi\u0026gt;=2017.4.17 Downloading certifi-2020.12.5-py2.py3-none-any.whl (147 kB) |████████████████████████████████| 147 kB 12.4 MB/s Collecting pyparsing\u0026gt;=2.0.2 Downloading pyparsing-2.4.7-py2.py3-none-any.whl (67 kB) |████████████████████████████████| 67 kB 6.4 MB/s Collecting MarkupSafe\u0026gt;=0.23 Downloading MarkupSafe-1.1.1-cp38-cp38-manylinux1_x86_64.whl (32 kB) Installing collected packages: docutils, sphinxcontrib-applehelp, Pygments, pytz, babel, chardet, idna, urllib3, certifi, requests, sphinxcontrib-serializinghtml, sphinxcontrib-jsmath, sphinxcontrib-htmlhelp, pyparsing, packaging, alabaster, sphinxcontrib-devhelp, sphinxcontrib-qthelp, snowballstemmer, imagesize, MarkupSafe, Jinja2, Sphinx, sphinx-rtd-theme Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Pygments-2.7.3 Sphinx-2.4.4 alabaster-0.7.12 babel-2.9.0 certifi-2020.12.5 chardet-3.0.4 docutils-0.16 idna-2.10 imagesize-1.2.0 packaging-20.7 pyparsing-2.4.7 pytz-2020.4 requests-2.25.0 snowballstemmer-2.0.0 sphinx-rtd-theme-0.5.0 sphinxcontrib-applehelp-1.0.2 sphinxcontrib-devhelp-1.0.2 sphinxcontrib-htmlhelp-1.0.3 sphinxcontrib-jsmath-1.0.1 sphinxcontrib-qthelp-1.0.3 sphinxcontrib-serializinghtml-1.1.4 urllib3-1.26.2     'use strict'; var containerId = JSON.parse(\"\\\"afb72b97e6e32427\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  하지만 위의 상황에서 설명했듯, six는 설치되지 않았다. 혹시 다른 패키지나 six가 설치 목록에 있었는데 삭제된 것은 아닌지 확인해보자.\nshell  $ git --no-pager log --stat Documentation/sphinx/requirements.txt commit d5afc9640a6d4596e57a2c4906f903ab1c83ada5 Author: Mauro Carvalho Chehab \u0026lt;mchehab+huawei@kernel.org\u0026gt; Date: Tue Apr 14 18:48:30 2020 +0200 docs: update recommended Sphinx version to 2.4.4 There are some docs that have nested tables. While this was always part of the spec, only Sphinx version 2.4.x can translate it to LaTeX. In other words, if someone is using a Sphinx version \u0026lt; 2.4, the LaTeX and PDF output won\u0026#39;t work for some of the docs. So, it seems that it is time to raise the bar again for the recommented version. The Sphinx check script is already smart enough to keep working, with older versions, warning the users that an upgrade is recommended (and explaining how): Sphinx version 1.7.9 Warning: It is recommended at least Sphinx version 2.4.4. Detected OS: Fedora release 31 (Thirty One). To upgrade Sphinx, use: /usr/bin/virtualenv sphinx_2.4.4 . sphinx_2.4.4/bin/activate pip install -r ./Documentation/sphinx/requirements.txt Signed-off-by: Mauro Carvalho Chehab \u0026lt;mchehab+huawei@kernel.org\u0026gt; Link: https://lore.kernel.org/r/498f701c618f7d0cf5f0a37e5889ee926f7c8bf4.1586881715.git.mchehab+huawei@kernel.org Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/requirements.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) commit a700767a7682d9bd237e927253274859aee075e7 Author: Mauro Carvalho Chehab \u0026lt;mchehab+samsung@kernel.org\u0026gt; Date: Wed May 29 20:09:32 2019 -0300 docs: requirements.txt: recommend Sphinx 1.7.9 As discussed at the linux-doc ML, while we\u0026#39;ll still support version 1.3, it is time to recommend a more modern version. So, let\u0026#39;s switch the minimal requirements to Sphinx 1.7.9, as it has the \u0026#34;-jauto\u0026#34; flag, with makes a lot faster when building documentation. Signed-off-by: Mauro Carvalho Chehab \u0026lt;mchehab+samsung@kernel.org\u0026gt; Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/requirements.txt | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) commit fb947f3f472303d54759bf898cf92fd8c2dc9bdf Author: Mauro Carvalho Chehab \u0026lt;mchehab@kernel.org\u0026gt; Date: Mon Jul 17 18:46:38 2017 -0300 sphinx-pre-install: use a requirements file Instead of using 3 commands to install a virtualenv, use a single one, reading the requirements from this file: Documentation/sphinx/requirements.txt Signed-off-by: Mauro Carvalho Chehab \u0026lt;mchehab@s-opensource.com\u0026gt; Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/requirements.txt | 3 +++ 1 file changed, 3 insertions(+)     'use strict'; var containerId = JSON.parse(\"\\\"2bdb1b4823cc57c9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  다행히 requirements.txt의 변화 기록도 많지 않고, 변화분도 적어서 쉽게 확인할 수 있다. 시간순으로 각 commit에 대해 요약하자면 아래와 같다.\n 원래는 virtualenv에서 각 패키지들 설치 명령을 직접 입력하던 것을 간소화(fb947f3f472303d54759bf898cf92fd8c2dc9bdf) 문서 생성 속도를 빠르게 하기 위해 Sphinx의 버전을 1.7.9로 변경함(a700767a7682d9bd237e927253274859aee075e7) 다른 문서 생성하는 부분에 Sphinx 1.7.9는 부적합해서 버전을 2.4.4로 변경함(d5afc9640a6d4596e57a2c4906f903ab1c83ada5)  딱히 six가 지워질 이유는 없었던 것 같다. 그렇다면 혹시 six를 사용하는 kfigure.py에서 갑자기 six를 사용하기 시작했는데 requirements.txt에 추가하는 것을 빼먹었을 수도 있지 않을까? kfigure.py의 수정 기록을 찾아보자.\nkfigure.py에서 six 부분 기록 확인하기 shell  $ git --no-pager log --stat Documentation/sphinx/kfigure.py commit 93431e0607e58a3c997a134adc0fad4fdc147dab Author: Alexander A. Klimov \u0026lt;grandmaster@al2klimov.de\u0026gt; Date: Tue May 26 08:05:44 2020 +0200 Replace HTTP links with HTTPS ones: documentation Rationale: Reduces attack surface on kernel devs opening the links for MITM as HTTPS traffic is much harder to manipulate. Deterministic algorithm: For each file: For each line: If doesn\u0026#39;t contain `\\bxmlns\\b`: For each link, `\\bhttp://[^# \\t\\r\\n]*(?:\\w|/)`: If both the HTTP and HTTPS versions return 200 OK and serve the same content: Replace HTTP with HTTPS. Signed-off-by: Alexander A. Klimov \u0026lt;grandmaster@al2klimov.de\u0026gt; Link: https://lore.kernel.org/r/20200526060544.25127-1-grandmaster@al2klimov.de Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/kfigure.py | 6 +++--- 1 file changed, 3 insertions(+), 3 deletions(-) commit 096ea522e84ea68f8e6c41e5e7294731a81e29bc Author: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Date: Tue May 21 14:23:43 2019 -0600 doc: Cope with Sphinx logging deprecations Recent versions of sphinx will emit messages like: Documentation/sphinx/kerneldoc.py:103: RemovedInSphinx20Warning: app.warning() is now deprecated. Use sphinx.util.logging instead. Switch to sphinx.util.logging to make this unsightly message go away. Alas, that interface was only added in version 1.6, so we have to add a version check to keep things working with older sphinxes. Cc: stable@vger.kernel.org Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/kfigure.py | 40 +++++++++++++++++++++++----------------- 1 file changed, 23 insertions(+), 17 deletions(-) commit ae17a87dd7c79fa742ef5dcf06d1095eec4e1925 Author: Masanari Iida \u0026lt;standby24x7@gmail.com\u0026gt; Date: Thu Jan 11 20:00:28 2018 +0900 linux-next: docs-rst: Fix typos in kfigure.py This patch fixes some spelling typos found in kfigure.py Signed-off-by: Masanari Iida \u0026lt;standby24x7@gmail.com\u0026gt; Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/kfigure.py | 6 +++--- 1 file changed, 3 insertions(+), 3 deletions(-) commit db6ccf23e8ba40fc2e8914ec9c0eb950df71d9fe Author: Markus Heiser \u0026lt;markus.heiser@darmarit.de\u0026gt; Date: Mon Mar 6 14:09:27 2017 +0100 docs-rst: automatically convert Graphviz and SVG images This patch brings scalable figure, image handling and a concept to embed *render* markups: * DOT (http://www.graphviz.org) * SVG For image handling use the \u0026#39;image\u0026#39; replacement:: .. kernel-image:: svg_image.svg :alt: simple SVG image For figure handling use the \u0026#39;figure\u0026#39; replacement:: .. kernel-figure:: svg_image.svg :alt: simple SVG image SVG image example Embed *render* markups (or languages) like Graphviz\u0026#39;s **DOT** is provided by the *render* directive.:: .. kernel-render:: DOT :alt: foobar digraph :caption: Embedded **DOT** (Graphviz) code. digraph foo { \u0026#34;bar\u0026#34; -\u0026gt; \u0026#34;baz\u0026#34;; } The *render* directive is a concept to integrate *render* markups and languages, yet supported markups: * DOT: render embedded Graphviz\u0026#39;s **DOT** * SVG: render embedded Scalable Vector Graphics (**SVG**) Cc: Jani Nikula \u0026lt;jani.nikula@linux.intel.com\u0026gt; Cc: Laurent Pinchart \u0026lt;laurent.pinchart@ideasonboard.com\u0026gt; Tested-by: Mauro Carvalho Chehab \u0026lt;mchehab@s-opensource.com\u0026gt; Tested-by: Daniel Vetter \u0026lt;daniel.vetter@ffwll.ch\u0026gt; Signed-off-by: Daniel Vetter \u0026lt;daniel.vetter@intel.com\u0026gt; (v2 - v5) Signed-off-by: Markus Heiser \u0026lt;markus.heiser@darmarit.de\u0026gt; (v1, v6) Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/kfigure.py | 551 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1 file changed, 551 insertions(+)     'use strict'; var containerId = JSON.parse(\"\\\"1ad96e845260f09d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  commit 기록이 많은 것은 아니지만, 딱히 six를 언급하는 부분은 찾을 수 없다. 그렇다면 git log보단 blame으로 해당 라인의 기록을 찾는 것이 더 효율적이다.\nshell  $ git --no-pager blame -L48,62 Documentation/sphinx/kfigure.py db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 48) import os db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 49) from os import path db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 50) import subprocess db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 51) from hashlib import sha1 db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 52) import sys db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 53) db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 54) from docutils import nodes db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 55) from docutils.statemachine import ViewList db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 56) from docutils.parsers.rst import directives db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 57) from docutils.parsers.rst.directives import images db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 58) import sphinx db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 59) db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 60) from sphinx.util.nodes import clean_astext db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 61) from six import iteritems db6ccf23e8ba4 (Markus Heiser 2017-03-06 14:09:27 +0100 62)     'use strict'; var containerId = JSON.parse(\"\\\"51f6619d6bc3d4d4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위에서 확인했던 commit 기록과 비교해봤을 때(db6ccf23e8ba40fc2e8914ec9c0eb950df71d9fe), six는 kfigure.py를 처음 작성했을 때 부터 계속 사용해 왔음을 알 수 있다. 그렇다면 다시 requirements.txt의 기록을 다시 찾아봐야 한다.\nrequirements.txt의 하위 의존성 패키지 찾아보기 지금까지 분석한 것을 보고 평소 python으로 개발을 해 본 사람으로 생각했다면, 아쉽게도 나는 python을 아주 가끔 쓰기 때문에 전문적으로 아는 것은 아니다. 각 패키지 설치의 하위 의존성을 확인하는 방법을 검색해봤는데 나는 찾지 못했다. (키워드를 잘 모르는 것일 가능성이 높아보임)\n현재로선 requirements.txt에 작성된 패키지를 직접 찾아 들어가서 하위 호환성을 확인해 보는 수밖에 없겠다. (사실 3가지 commit 버전을 모두 requirements.txt로 설치해보고 언제부터 six가 설치 목록에서 사라졌는지 확인하는 것이 제일 쉽다.)\nrequirements.txt의 기록을 보면 Sphinx의 버전이 2번 변경되었고, docutils가 1번 변경되었다. 변경 횟수가 더 많은 Sphinx가 더 의심스러워서 Sphinx를 먼저 찾아봤다. Sphinx의 소스에서 하위 의존성 패키지 설치 목록이 정의된 파일은 setup.py인 것 같다. 코드의 install_requires 리스트에서 하위 의존성 패키지를 선언하고 있고, 제일 아래 setup의 인자로 전달되는 것을 확인할 수 있다.\n다행히 requirements.txt에서 Sphinx의 버전이 명시되어 있으므로, 일단은 각 버전 별로 setup.py를 비교해보자. Sphinx는 각 버전을 배포할 때마다 버전 이름으로 tag를 달아놨으므로, tag를 기반으로 각 버전을 찾아가면 되겠다.\n각 tag에 들어가면 tag가 연결된 commit id를 알아낼 수 있다. 해당 commit id를 클릭하면 그 commit 당시의 소스 코드를 확인할 수 있다. 각 버전, 해당 commit id, 그때 당시의 setup.py를 링크로 정리하면 다음과 같다.\n   태그 commit id 해당 파일 상태     v2.4.4 72ad5f2 setup.py   v1.7.9 1cd87a1 setup.py    분명 v1.7.9에는 install_requires에 six가 있지만, v2.4.4에는 존재하지 않는 것을 확인할 수 있다. 결국 Sphinx 버전이 올라가면서 six가 하위 의존성에서 제외되면서 자동으로 설치되지 않게 되었음을 알 수 있다.\n참고로 six는 2.x부터 하위 의존성에서 제외된 것을 확인할 수 있다.\n왜 이 문제를 발견하지 못했을까? Sphinx 버전을 2.4.4로 올린 commit의 로그를 다시 확인해보자.\npatch  commit d5afc9640a6d4596e57a2c4906f903ab1c83ada5 Author: Mauro Carvalho Chehab \u0026lt;mchehab+huawei@kernel.org\u0026gt; Date: Tue Apr 14 18:48:30 2020 +0200 docs: update recommended Sphinx version to 2.4.4 There are some docs that have nested tables. While this was always part of the spec, only Sphinx version 2.4.x can translate it to LaTeX. In other words, if someone is using a Sphinx version \u0026lt; 2.4, the LaTeX and PDF output won\u0026#39;t work for some of the docs. So, it seems that it is time to raise the bar again for the recommented version. The Sphinx check script is already smart enough to keep working, with older versions, warning the users that an upgrade is recommended (and explaining how):  Sphinx version 1.7.9 Warning: It is recommended at least Sphinx version 2.4.4. Detected OS: Fedora release 31 (Thirty One). To upgrade Sphinx, use: /usr/bin/virtualenv sphinx_2.4.4 . sphinx_2.4.4/bin/activate pip install -r ./Documentation/sphinx/requirements.txt Signed-off-by: Mauro Carvalho Chehab \u0026lt;mchehab+huawei@kernel.org\u0026gt; Link: https://lore.kernel.org/r/498f701c618f7d0cf5f0a37e5889ee926f7c8bf4.1586881715.git.mchehab+huawei@kernel.org Signed-off-by: Jonathan Corbet \u0026lt;corbet@lwn.net\u0026gt; Documentation/sphinx/requirements.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)     'use strict'; var containerId = JSON.parse(\"\\\"2881647485df79fc\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  여기에서는 Sphinx 검사 스크립트가 버전 업그레이드 필요 여부에 대한 경고 및 설치법을 잘 설명하고 있다고만 언급하고 있다.\n즉, 해당 패치를 작성할 때는 Sphinx 버전을 업그레이드하는 경우만 고려하고, 처음부터 설치하는 경우는 고려하지 않은 상태였음을 알 수 있다. 1.7.9에서 2.4.4로 업그레이드하는 경우는 이미 1.7.9 설치 과정에서 six가 설치되어 있기 때문에 이런 문제를 확인하지 못한 것으로 보인다.\n문제 해결 및 commit 일단 six가 없는 문제는 six를 설치하면 된다. 위에서 requirements.txt를 사용했으니 여기에 six를 추가하면 된다.\n그리고 혹시 다른 모듈에서도 설치되지 않은 패키지가 있는지 확인해보자.\nshell  $ grep -r \u0026#34;import\u0026#34; Documentation/sphinx Documentation/sphinx/automarkup.py:from docutils import nodes Documentation/sphinx/automarkup.py:from sphinx import addnodes Documentation/sphinx/automarkup.py:from sphinx.environment import NoUri Documentation/sphinx/automarkup.py:import re Documentation/sphinx/load_config.py:import os Documentation/sphinx/load_config.py:import sys Documentation/sphinx/load_config.py:from sphinx.util.pycompat import execfile_ Documentation/sphinx/kernel_include.py:# imports Documentation/sphinx/kernel_include.py:import os.path Documentation/sphinx/kernel_include.py:from docutils import io, nodes, statemachine Documentation/sphinx/kernel_include.py:from docutils.utils.error_reporting import SafeString, ErrorString Documentation/sphinx/kernel_include.py:from docutils.parsers.rst import directives Documentation/sphinx/kernel_include.py:from docutils.parsers.rst.directives.body import CodeBlock, NumberLines Documentation/sphinx/kernel_include.py:from docutils.parsers.rst.directives.misc import Include Documentation/sphinx/kerneldoc.py:import codecs Documentation/sphinx/kerneldoc.py:import os Documentation/sphinx/kerneldoc.py:import subprocess Documentation/sphinx/kerneldoc.py:import sys Documentation/sphinx/kerneldoc.py:import re Documentation/sphinx/kerneldoc.py:import glob Documentation/sphinx/kerneldoc.py:from docutils import nodes, statemachine Documentation/sphinx/kerneldoc.py:from docutils.statemachine import ViewList Documentation/sphinx/kerneldoc.py:from docutils.parsers.rst import directives, Directive Documentation/sphinx/kerneldoc.py:import sphinx Documentation/sphinx/kerneldoc.py: from sphinx.util.docutils import switch_source_input Documentation/sphinx/kerneldoc.py: from sphinx.ext.autodoc import AutodocReporter Documentation/sphinx/kerneldoc.py:import kernellog Documentation/sphinx/kernellog.py:import sphinx Documentation/sphinx/kernellog.py: from sphinx.util import logging Documentation/sphinx/rstFlatTable.py:# imports Documentation/sphinx/rstFlatTable.py:import sys Documentation/sphinx/rstFlatTable.py:from docutils import nodes Documentation/sphinx/rstFlatTable.py:from docutils.parsers.rst import directives, roles Documentation/sphinx/rstFlatTable.py:from docutils.parsers.rst.directives.tables import Table Documentation/sphinx/rstFlatTable.py:from docutils.utils import SystemMessagePropagation Documentation/sphinx/kfigure.py:import os Documentation/sphinx/kfigure.py:from os import path Documentation/sphinx/kfigure.py:import subprocess Documentation/sphinx/kfigure.py:from hashlib import sha1 Documentation/sphinx/kfigure.py:import sys Documentation/sphinx/kfigure.py:from docutils import nodes Documentation/sphinx/kfigure.py:from docutils.statemachine import ViewList Documentation/sphinx/kfigure.py:from docutils.parsers.rst import directives Documentation/sphinx/kfigure.py:from docutils.parsers.rst.directives import images Documentation/sphinx/kfigure.py:import sphinx Documentation/sphinx/kfigure.py:from sphinx.util.nodes import clean_astext Documentation/sphinx/kfigure.py:from six import iteritems Documentation/sphinx/kfigure.py:import kernellog Documentation/sphinx/kfigure.py: from sphinx.directives.patches import Figure # pylint: disable=C0413 Documentation/sphinx/cdomain.py:from docutils import nodes Documentation/sphinx/cdomain.py:from docutils.parsers.rst import directives Documentation/sphinx/cdomain.py:import sphinx Documentation/sphinx/cdomain.py:from sphinx import addnodes Documentation/sphinx/cdomain.py:from sphinx.domains.c import c_funcptr_sig_re, c_sig_re Documentation/sphinx/cdomain.py:from sphinx.domains.c import CObject as Base_CObject Documentation/sphinx/cdomain.py:from sphinx.domains.c import CDomain as Base_CDomain     'use strict'; var containerId = JSON.parse(\"\\\"234aaefbe6d9024c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  일단 import를 기준으로 검색해 본 결과 six만 없는 것으로 판단했다. 이제 수정하고 commit을 작성하자. 앞에서 조사했던 내용을 포함하여 왜 six가 requirements.txt에 추가되어야 하는지 설명하자.\npatch  From eb48c1fd1092cdd0c1636ea0275ab3a48101e483 Mon Sep 17 00:00:00 2001 From: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; Date: Mon, 7 Dec 2020 23:35:09 +0900 Subject: [PATCH] docs: update requirements to install six module On the update of Sphinx version to 2.4.4, the \u0026#34;six\u0026#34; library won\u0026#39;t be installed automatically. (which is required by kfigure.py) Main reason of this issue were occurred by the requirements changed from the sphinx library. In Sphinx v1.7.9, six was listed on the install_requires, but it has been removed since 2.x The kfigure.py uses six library explicitly, adding six to requirements.txt seems reasonable Signed-off-by: JaeSang Yoo \u0026lt;jsyoo5b@gmail.com\u0026gt; --- Documentation/sphinx/requirements.txt | 1 + 1 file changed, 1 insertion(+) diff --git a/Documentation/sphinx/requirements.txt b/Documentation/sphinx/requirements.txt index 489f6626de67..5030d346d23b 100644 --- a/Documentation/sphinx/requirements.txt +++ b/Documentation/sphinx/requirements.txt @@ -1,3 +1,4 @@ docutils Sphinx==2.4.4 sphinx_rtd_theme +six -- 2.25.1     'use strict'; var containerId = JSON.parse(\"\\\"64750669e6b9aefd\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  대충 commit 메시지를 해석하자면 아래와 같다.\npatch  Sphinx 버전을 2.4.4로 올리면서, \u0026#34;six\u0026#34; 라이브러리가 더 이상 자동으로 설치가 되지 않는다. (kfigure.py에서 필요함) 이 문제의 주요 원인은 sphinx 라이브러리의 요구사항이 변경되었기 때문이다. Sphinx v1.7.9까지는 six가 install_requires에 있었는데, 2.x부터는 삭제되었다. kfigure.py에서 six 라이브러리를 명시적으로 사용하니깐, six를 requirements.txt에 추가하는 것이 좋겠다.     'use strict'; var containerId = JSON.parse(\"\\\"b3e9f0696e82a9d9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  해당 패치를 커널에 반영하기 위해서는 메일로 패치를 전송해야 하는데, 그건 내용이 복잡하기도 하고, 주제를 따로 빼는 것이 좋을 것 같아 다음 글에서 설명하도록 하겠다.\n결과 해당 patch를 메일로 전송했고, 마지막으로 requirements.txt를 수정했던 사람으로부터 답장이 왔다. 사실 1줄밖에 안되는 데다가 간단한 문제기 때문에 특별한 review가 없다.\n이후 실제 Documentation의 maintainer가 나한테 patch가 적용되었다고 답장을 보냈다. Python2 하위 호환성을 그만 제공하는 것이 제일 최선이지만, 그 전까지는 six를 설치하는 것이 맞으니 일단 적용하도록 하겠다고 한다. 마침 sphinx 분석 과정에서 현재 버전이 더 이상 python2를 지원하지 않으니, 아예 그냥 python3로 변경시키면 안되는지 물어봤고, 메일을 주고 받은 결과 일단은 더 수정할 거리는 없이 여기서 마무리 하기로 했다.\n최종적으로 commit이 mainline에 등록되었다.\n","description":"","id":12,"section":"posts","tags":["커널","git","sphinx"],"title":"내 첫 리눅스 커널 기여","uri":"https://devlog.jsyoo5b.net/ko/posts/linux-kernel/my-first-commit/"},{"content":"본 리뷰는 조엘 온 소프트웨어 책에 대한 리뷰입니다.\n이 책은 지식전달 목적의 교재보다는 개발자의 에세이에 가까운 책이므로 특별히 장단점 분석을 하지 않습니다. 또한 본 글에서 책의 내용과 설명 부분은 제 주관적인 해석이 포함되어 있으므로 저자의 의도와 일치하지 않을 수 있습니다.\n읽은 계기 나는 이 책을 약 7~8년 전에 처음 접했었다. 그때 당시에는 1부 중간을 읽다가 말았던 것 같은데, 최근 이 책을 끝까지 읽었다. 7~8년 전이면 학부 4학년~대학원생(+회사 파트타임 근무 기간)일 때였는데, 당시에는 이 책이 코드 작성법에 대한 조언을 위주로 하는 책인줄 알았다. 왜냐하면 가장 인상깊은 내용이 러시아 페인트공 문제였기 때문이다. (참고로 원문에서는 Shlemiel the painter\u0026rsquo;s algorithm이라고 되어있는데, 의미로 해석한다면 실수가 잦은 페인트공의 알고리즘이라고 해석할 수 있겠다. 왜 실수가 잦은 사람이 러시아인으로 번역되었는지는 잘 모르겠다.)\n그리고 이런 글로 시작한다는 것은, 드디어 끝까지 읽어봤기 때문이다. 끝까지 읽어보니 이 책을 지금 읽은 것이 가장 적절했다고 생각했다. 왜냐하면 책의 중반부터 다루는 내용은 코드를 잘 짜는 법보단 개발자로서 일을 잘 하는 법에 가깝기 때문이다. 학생때나 초급 개발자 시기에는 실제 프로젝트를 수행하며 생기는 경험이 부족하기 때문에 같은 내용을 읽었어도 느끼는 바가 적었을 것이다.\n레거시 코드를 활용해야하는 이유에 대한 합리적 설득 이번에 읽으면서 제일 큰 깨달음을 얻은 부분이라면 레거시 코드를 활용해야 하는 이유에 대해 합리적인 설득 부분이다. 회사에서 참고한 기존 코드 뿐만 아니라 내가 이전 프로젝트에서 작성한 코드조차 싹 다 밀어버리고 처음부터 다시 작성하고 싶다는 생각이 강렬하게 들었다. 실제로 일부는 직접 다시 작성하는 경우가 있었는데 내 나름대로 합리적인 이유는 있었다. 기존 코드가 특정 환경에 너무 의존적이거나, 해당 코드를 라이브러리화 했을 때 라이브러리의 장점을 살리지 못하는 경우라던가, 안 좋은 설계로 구현한 코드임을 알게 되었을때 등의 이유였다. (모두 설계가 좋지 않았기 때문으로 수렴한다.)\n최근 프로젝트는 핵심은 유지하고 API만 변경하거나, 가독성만 발전시키는 방향으로 리팩토링하는 식으로 최대한 레거시 코드를 활용하긴 했다. 하지만 \u0026ldquo;시간적 여유만 더 있었더라면 저 레거시 코드와 타협하지 않고 더 깨끗하게 작성할 수 있을텐데\u0026quot;같은 미련이 없진 않았다. 그런데 이 책에서는 코드를 새로 작성하는 것은 결코 해선 안될 일이라고 말한다. 핵심적인 근거는 3가지이다.\n기본적으로 코드는 작성보다 읽는것이 더 어렵다 나는 이 부분을 내가 예전에 짰던 코드를 보며 공감할 수 있었다. 물론 과거에 비해 나는 조금 더 경험이 생기고, 지식이 쌓이고, 다른 코드도 많이 봤을테니 예전에 짰던 코드가 구려보이는 것은 당연할 것이다. 하지만 남이 짠것도 아니고 내가 짠 코드인데 \u0026ldquo;그땐 이걸 몰랐지, 이렇게 고치자\u0026rdquo; 수준이 아니라 \u0026ldquo;도대체 과거의 나는 코드에 뭔 짓을 한거지?\u0026rdquo; 같은 생각이 든다는 것이다. 남이 짠 코드가 구려보이면 그 사람 실력이 모자라다고 거만한 생각을 했겠지만, 고작 3개월 사이에 다시 읽어본 코드에서 이런 생각이 든다는 것은 읽는 입장에서는 모든 코드가 다 구려 보인다고 볼 수 있을 것 같다.\n프로그램을 숲으로 비유하자면, 숲을 만들기 위해 묘목을 한번에 심고 다 같이 키워서 울창하게 하는 것이 아니라, 묘목 하나를 나무로 만들고, 그 나무를 기준으로 묘목을 추가로 심는 것을 반복해서 만들게 될 것이다. 당연히 나무 하나하나에 집중하면서 작성하다 보니 큰 숲의 관점으로 보기 힘든 것은 당연하다. 미래의 내가 엿먹으라고 이렇게 작성한게 아니라 이게 그때 당시에 최선이었을 것이라는 것이다. 글을 잘 쓰기 위해선 다 쓰고 읽어봐야 하는 것과 같은 이야기다. 하지만 보통 빌드한 프로그램을 돌려보고 동작을 확인하는 것에서 끝난다. 읽을 것을 고민하는 시간은 설계하는 시간이 거의 전부다. 작성하다 보면 당연하다 생각해서 주석도 쓰지 않는 경우도 많다.\n물론 레거시 코드에는 기술부채도 분명 존재할 것이다. 마감이 급할 때 버그 수정을 위해 하드코딩한다던가, 바로 다음 프로젝트가 급해서 기술부채를 해결하지 못하고 프로젝트를 종료하는 등 레거시 코드의 품질 저하에는 여러 원인이 있을 수 있다. 하지만 이 상황은 나만 겪는 것이 아닐것이다. 나, 내 후임, 내 동료, 내 사수 모두 이런 저런 이유로 읽기 힘든 레거시 코드를 생성했을 것이다.\n기존 코드는 여러 에러에 대처한 훌륭한 코드 다른 이유는 어느정도 간접적으로 눈치채고 있었다. 머리로 알겠는 것과 마음까지 완전히 바뀌는 것은 별개다보니 여전히 코드를 새로 작성하고 싶다는 욕구가 생기곤 했다. 하지만 이 설명을 보고 나니 체크메이트 당한 기분이었다. 버그 수정을 위해 급하게 작성한 코드는 가독성은 안 좋지만, 소프트웨어의 목적성이나 정확성은 보장한다. 여러 핑계를 대면서 코드를 처음부터 다시 작성한다면 똑같은 실수를 반복하게 될 것이다.\n비슷한 관점에서 연상되는 글이 있다. 정확히 내가 생각하던 글은 아닌 것 같은데, 핵심은 코드를 변경할 때 테스트 코드는 안전을 보장하진 못해도 없을 때 생길 위험을 많이 줄여준다는 주장이었다. 그런데 코드를 처음부터 다시 작성하면 테스트 코드도 활용하지 못할 가능성이 높다. 위험을 줄여주는 테스트 코드조차 활용할 수 없으니, 기술 부채를 없애기 위해 시작한 작업이 오히려 다른 관점의 기술 부채를 생성할 수도 있다.\n코드를 다시 작성하는 것은 민첩성이 떨어져 시장 지배력이 낮아질 수 있다 책에서는 넷스케이프가 코드를 갈아엎고 새로 짜다가 시장 점유를 놓친 이야기로 이 이유에 대한 설명을 보충한다. 위에서 내가 한 생각처럼 시간적 여유만 더 있었더라면은 개발자의 기준일 뿐, 그러다 제품 출시가 미뤄지고, 시장 점유율을 놓치는 이야기는 마치 상업성과 예술성에서 고민하는 예술가 모습을 보는 것 같다. 최소한 예술가는 예술성에 집중하면 이를 알아주고 가치를 높여주는 평론가라도 있지만, 프로그래머는 제품으로 내놓을 뿐 코드를 내놓지 않는다. (오픈소스 이야기는 바로 아래에서 할 것이다.) 취미로 코드를 작성한다면 몰라도 일하고 사업하는 입장에선 장인정신이 매번 옳은 마음가짐이 아닐 수도 있다.\n물론 오픈소스 프로젝트들은 사업성과 거리가 멀어보인다. 하지만 자세히 보면 오픈소스들 간에도 경쟁하고, 도태되고, 살아남는 현상은 존재한다. 내가 생각하는 대표적인 예시는 jQuery와 YUI다. (내가 웹 개발을 전문적으로 하지 않으므로 좋은 예시가 아닐수도 있다.) 내 기억으론 둘 다 JavaScript를 보조하기 위한 라이브러리로 사용되었고, 지원하는 기능의 범위도 비슷하다. 지금은 jQuery도 구시대 기술로 취급받을 만큼 웹 개발 환경도 바뀐 상태지만, jQuery와 YUI의 인지도를 비교해보면 jQuery가 압도적일 것이다. jQuery는 2020년에도 업데이트가 되고 있지만, YUI는 2014년에 프로젝트가 종료되었다. YUI가 코드를 처음부터 다시 작성해서 도태된 것은 아니지만, 오픈소스들 나름의 경쟁이 있고, 예술성만으로 평가받는 분야가 아님을 이야기하고 싶었다. 오픈소스지만 전혀 인지도가 없다면 그냥 공개해놓은 프로젝트처럼 보일 것이다.\n혹시 YUI에 대한 관심이 있을 사람을 위해 왜 YUI가 도태되고 종료되었는지를 분석한 글도 첨부한다.\n소프트웨어 세계에선 만병통치 디자인도 없다 소프트웨어의 종류를 분야에 따라 다르게 구분을 하면서 각 분야별로 다른 개발 방법론을 적용해야 한다고 했다. 나는 이 중에서도 사용자와 소프트웨어의 관계, 디자인 관련된 설명에서 느끼는 바가 많았다. 이 책에서는 소프트웨어의 종류를 5가지로 분류했다.\n 상품 소프트웨어\n말 그대로 상품으로 판매하는 소프트웨어로, 사용자는 불특정 다수이며, 해당 사용자의 도메인 지식(해당 소프트웨어 사용과 관련된 지식) 수준 또한 예측하기 어렵다. 또한 다른 경쟁 상품/대체재가 존재할 가능성이 높다. 사내 소프트웨어\n회사 내부 \u0026amp; 관련 협력사에서 사용할 소프트웨어로, 사용자는 어느정도 한정된 인원이며, 대부분 도메인 지식을 잘 갖추고 있다고 생각할 수 있다. 임베디드 소프트웨어\n특정 하드웨어에서 구동되도록 제한되어있으며, 최대한 단순화 된 입출력만을 사용하여 사용자와 상호작용한다. 하드웨어에 의존적이다보니 사용자에게 요구하는 도메인 지식의 깊이가 낮은 편이다. (소프트웨어 기준) 품질 기준은 다른 종류 소프트웨어보다 한참 높다. (문제를 고칠 기회조차 오지 않을 가능성이 있기 때문이다.) 성능적 제한으로 인해 우아한 코드보단 빠른 코드가 더 중요하다. 게임 소프트웨어 (주로 패키지 게임을 말하는 듯)\n상품 소프트웨어의 일부지만, 기존 상품 소프트웨어와의 차이점이 있다. 화면, 키보드/마우스부터 내부 하드웨어 자원까지 독점에 가깝게 사용하는 구조로 동작한다. 버전 변화가 버그 수정같은 수준으로 한정적이다. 제품을 지속적으로 사용할 확률이 낮다. 이러한 복합적인 원인에 의해 임베디드 수준의 품질 기준을 요구하게 된다. 일회성 소프트웨어\n귀찮은 일을 반복시키기 위해 급히 작성한 쉘 스크립트, 해당 소프트웨어가 자주 활용되거나 발전시킬 가치가 생기면 사내 소프트웨어의 형태로 변형된다.  특히 여기서 상품 소프트웨어와 사내 소프트웨어를 다루면서 디자인에 관한 관점도 언급한다. 과장해서 사내 소프트웨어는 더럽게 디자인해도 대체재가 없기 때문에 사용된다. 게다가 해당 소프트웨어를 반복적으로 사용할 수록 거기에 몸이 적응해서 시간이 갈수록 그 문제를 못 느끼게 된다.\n나는 전문적인 디자인을 배우지도 않았고, 특히나 배색을 위한 색감은 거의 최악 수준이다. 하지만 내 나름대로의 디자인 철학이 있는데, \u0026ldquo;이거 어떻게 사용하는거에요?\u0026rdquo; 같은 질문을 듣지 말자 였다. 상품 소프트웨어를 개발하는 입장에서는 괜찮은 철학이지만 사내 소프트웨어를 개발할 때는 불필요하게 에너지를 낭비할 수도 있는 철학임을 인지할 수 있었다.\n다른 관점으로 생각해 보면 상품 소프트웨어와 사내 소프트웨어의 관계는 입문용 제품과 전문가용 제품의 관계로 비유해 볼 수 있을 것 같다.\n말단 프로그래머가 할 수 있는 일 말단이면서도 해내기에서는 말단 프로그래머가 회사를 변화시키기 위한 전략을 설명하고 있다. 요약하자면 좋은 향기가 나는 사람이 되라는 것이다.\n회사 내부에서는 매우 오래 된 소스 관리 도구로 버전 관리를 하고 있었다. (보안상 문제가 될 수도 있어 특정하지는 않는다. 상당히 오래 된 소스 관리 도구인데 당신이 생각하는 그것은 아닐 것 같다.) 게다가 직원들도 해당 도구 사용법을 완벽히 숙지하지 못한 것인지, 각종 환장의 콜라보가 터져나오는 소리가 들리곤 했다.\n A가 file.c라는 파일을 보고 있는데, 그거땜에 B라는 사람이 file.c를 수정을 못 하고 있다. 소스의 접근 권한 관리가 실제 파일의 읽기/쓰기 권한과 연동되어서, 다른 에디터로 수정 시 소스 상태가 꼬인다. A가 file.c를 수정하다가 예기치 않게 프로그램이 종료되었는데 서버에 권한이 꼬인 상태가 되어 직접 DB를 수정해줘야 한다. A가 뭔가 수정을 했는데, B가 사용하려니 문제가 있다. 근데 B가 문제를 수정하지 못하고 A가 수정해줘야 한다.  일부는 정확하지 않은 상황일 수도 있다. (일부는 내가 겪었던 상황을 기억을 바탕으로 쓴 것이고, 일부는 직원들끼리 오가는 이야기에서 맥락을 파악한 것이다.) 그리고 글의 정황에서 눈치챘겠지만, 저런 상황이 계속 나오는데도 여전히 그 도구를 사용해왔다. 다행히(?) 나는 그 도구를 사용해야 할 상황이 적었는데, 어쨋든 소스 관리에 대한 대책이 필요해 보였다.\n일단 대세는 git이었다. 대학원때나 파트타임으로 일할때는 SVN도 사용해봤었는데, 전문적으로 사용한 것은 아니었다. 내가 아는 git은 SourceForge처럼 코드를 가져오는 수단 정도였다. 사실상 git == github였다. (물론 둘의 차이는 알고 있었지만, 활용 수준에선 둘을 동일 개념으로 보는 수준이었다.) 나 혼자라도 해봐야겠다는 생각으로 시작했다.\n1년차에는 git의 최소한의 사용법은 익혀서, 날짜 단위로 코드 형상에 대한 스냅샷을 보관하는 수준으로는 활용할 수 있었다. 구글링 하면서 더듬대긴 했지만 어쨋든 과거의 코드 형상을 다시 가져오는 등의 작업은 할 수 있었다.\n2년차에 접어들 때, git을 좀 더 효율적으로 사용하기 위한 방법인 git-flow를 배웠다. Commit의 단위를 깔끔하게 나눈 것은 아니었지만, 내 코드의 흐름이 보이기 시작했다.\n3년차에 접어들 때, 아예 git 관련 전문 강의를 수강했다. 처음엔 \u0026ldquo;인터넷에 뒤지면 튜토리얼부터 시작해서 자료가 많은데 굳이 이걸 돈 주고 들어야 할까?\u0026rdquo; 같은 생각으로 구글링만 갖고 독학하려 했다. 부족한 부분은 있었지만 \u0026ldquo;일단 나 혼자서는 형상 관리가 가능함\u0026rdquo; 수준까지는 된다고 판단했다. 하지만 회사에서 다른 사람한테 가르쳐주기엔 모자라다는 생각을 했고, 협업 관련 지식은 부족했기에 강의를 수강했다. 그 해에는 외부 교육 수강에 대한 지원조차 받지 못했지만, 내 사비로 수강했다. (기업 문화를 발전시키겠다는 대의보단 나라도 살고 봐야겠다는 의욕이 더 정확하지만.)\n내가 git을 통해 편하게 일하는 듯한 향기를 풍기며 간접적으로 홍보했다. 매번 새로운 버전을 배포할 때 git log를 바탕으로 패치노트를 작성해서 전달했고, 버그의 원인 규명이나 수정도 효율적으로 했다. 문제의 그 소스 관리 도구와 연관된 프로젝트는 따로 내가 git 버전으로 포팅해서 보관했고, 그걸로 변경 이력에 대한 분석도 도와줬다.\n마침내 1명은 git을 공부하기 시작했다. 공부할 때 필요한 자료도 찾아서 공유해줬고, 가끔 물어보면 아는대로 대답해줬다. 내가 판단하기에 그 1명정도는 바꾸는데 성공한 것 같았다. 고작 1명이냐 싶겠지만 코드를 수정하는 6명 중 1명을 바꿨다.\n이거 15년 전에 출간된 책인데 간과하기 쉬운 사실은 이 책이 2005년에 출간된 책이라는 것이다. 심지어 이 책은 블로그 글을 잘 편집하고 번역한 것이며 실제 글의 작성 시기를 고려하면 거의 20년 전 글이다. 번역이 지금 보기에 완전 자연스럽진 않아도 읽는데 불편함이 없을 정도로 잘 번역되어있다. 그리고 책에서 언급하는 회사나 인물이 번역 당시에는 독자들이 잘 모를까봐 주석을 달아놨지만, 지금은 주석을 달지 않아도 될 만큼 국내에서도 유명한 존재라는 것도 재밌다. (Amazon의 제프 베조스, 밴엔제리 아이스크림 등) 두 기업을 롤 모델 방향에 관해 정리하면서 언급하는데 글의 작성 시기를 모른다면 그냥 성공한 기업에 본인 편한대로 해석한 느낌이 들 정도다. 성공하는 사람/회사를 알아보는걸까?\n개발자로서 나를 돌아보게 되다 내가 팔랑귀일수도 있겠지만, 책을 보면서 개발자로서의 좌우명이 약간 변경되었다. 장인정신으로 깨끗하게 작성한 코드가 목적이었는데, 때와 상황에 맞게 유기적으로 변할 수 있는 개발자가 되어야겠다는 생각이 들었다. 기존의 좌우명은 정해진 기간, 적당한 상황 단위로 최선을 다 하되 평생 그러고 있다간 오히려 도태될 수도 있겠다는 생각이 들었다.\n약간 안도감도 들었다. 내가 일하는 상황이나 고민이 이상한 것이 아니라 충분히 발생할 수 있다는 것, 해결을 위해 한 문제분석이나 가설, 해결법이 비슷한 것을 보고 \u0026ldquo;최소한 개발 업무는 정상적으로 했구나\u0026rdquo; 같은 생각이 들었다.\n또한 내가 해 온 선택이 매번 옳은 것은 아니었지만, 몇몇 부분에서는 꽤 괜찮은 선택을 해왔음을 인정받는 느낌이 들었다. 솔직히 처음에는 나라도 살아남아야겠다로 시작했지만, 나중에는 사람들을 바꿀 수 없다면 내가 잘해서 바뀌고 싶게 만들자는 생각으로 해왔던 일이 이 책에서도 추천하는 방법일 줄은 몰랐다. (다른 사람들은 어떻게 생각하는지 모르겠지만\u0026hellip;)\n","description":"","id":13,"section":"posts","tags":["조엘 온 소프트웨어"],"title":"[책 리뷰] 조엘 온 소프트웨어","uri":"https://devlog.jsyoo5b.net/ko/posts/review/book-joel-on-software/"},{"content":"라즈베리파이 OS를 설치한 microSD카드를 꽂고 전원을 연결하면 바로 라즈베리파이 OS가 부팅된다. 하지만 해당 장치를 사용하려면 HDMI로 모니터에 연결하고 (혹은 DSI 커넥터에 디스플레이 모듈 연결) 키보드, 마우스를 연결해야 한다. Headless 방식은 위 장치들이 없이 네트워크 혹은 시리얼 케이블로 연결하는 환경을 말한다. (보통 위 3가지 장치를 묶어서 KVM 스위치 등으로 여러 컴퓨터를 동시 제어할 때 쓰기도 한다.)\n본 문서에서는 라즈베리파이를 처음부터 Headless로 사용하기 위해 필요한 설정 방법을 설명할 것이다. 순서는 아래와 같다.\n 네트워크/시리얼 포트로 라즈베리파이와 연결 가능한 환경 확보 SSH 원격 접속을 설정하여 CLI로 접속 가능하게 하기 VNC 원격 접속을 설정하여 GUI로 접속 가능하게 하기  본 문서에서는 처음부터 headless로 사용하기 위해 라즈베리파이 OS가 설치된 microSD의 내용을 변경하는 방법을 설명한다. 라즈베리파이 OS가 설치된 microSD카드는 FAT32로 포맷된 boot 파티션과 ext4로 포멧된 rootfs 파티션이 있을 것이다. 본 문서에서는 boot파티션의 내용 수정을 주로 설명할 것이다.\n라즈베리파이와 연결 가능한 환경 확보하기 WiFi 자동 접속 설정하기 라즈베리파이를 유선랜으로 연결할 수 있다면 가장 좋겠지만, 불가능한 경우 WiFi에 자동 접속하도록 설정해주자. 라즈베리파이는 wpa_supplicant를 사용하므로 해당 설정 파일을 미리 작성해서 넣으면 된다.\nboot 파티션에 wpa_supplicant.conf 파일을 생성하고 WiFi 연결 정보를 작성한다. 아래는 WiFi AP 이름이 \u0026ldquo;testing\u0026rdquo;, 비밀번호가 \u0026ldquo;testingPassword\u0026quot;일 때의 작성 예시다.\nwpa_supplicant.conf  ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=GB  network={ ssid=\u0026#34;testing\u0026#34; psk=\u0026#34;testingPassword\u0026#34; }     'use strict'; var containerId = JSON.parse(\"\\\"76c9249fb4091511\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  country= 부분에는 현재 WiFi의 국가를 설정하는 부분인데, 한국이라서 KR로 입력하면 WiFi 사용에 문제가 있는 경우가 있으므로, 일단은 GB 혹은 US로 설정해 주도록 하자. (링크를 보면 알겠지만, 한국에서 WiFi 사용을 위한 주파수 밴드가 대부분 비활성화 되어 있어 생기는 문제다.)\n비밀번호 없는 WiFi 접속 설정 network={ } 안에 비밀번호 대신 key_mgmt=NONE를 입력하면 된다. 아래는 비밀번호 없는 WiFi AP 이름이 \u0026ldquo;testing\u0026quot;일 때의 작성 예시다.\nwpa_supplicant.conf  network={ ssid=\u0026#34;testing\u0026#34; key_mgmt=NONE }     'use strict'; var containerId = JSON.parse(\"\\\"51d0074d4dc51d4b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  숨겨진 WiFi 접속 설정 network={ } 안에 scan_ssid=1을 추가하면 된다. 아래는 숨겨진 WiFi AP 이름이 \u0026ldquo;hiddenSSID\u0026rdquo;, 비밀번호가 \u0026ldquo;testingPassword\u0026quot;일 때의 작성 예시다.\nwpa_supplicant.conf  network={ ssid=\u0026#34;hiddenSSID\u0026#34; scan_ssid=1  psk=\u0026#34;testingPassword\u0026#34; }     'use strict'; var containerId = JSON.parse(\"\\\"f7b84122a2460d0e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  2개 이상의 WiFi 접속 설정 각 WiFi AP에 대한 network={ }를 여러 개 입력하면 된다. 각 WiFi AP간 우선순위는 priority=으로 표기한다. 아래는 WiFi AP 이름이 \u0026ldquo;firstSSID\u0026rdquo;, 비밀번호가 \u0026ldquo;firstPassword\u0026quot;이고 다른 WiFi AP의 이름이 \u0026ldquo;secondSSID\u0026rdquo;, 비밀번호가 \u0026ldquo;secondPassword\u0026quot;이며, \u0026ldquo;firstSSID\u0026quot;를 우선적으로 접속하고 싶을 때의 작성 예시이다.\nwpa_supplicant.conf  network={ ssid=\u0026#34;firstSSID\u0026#34; psk=\u0026#34;firstPassword\u0026#34; priority=1 } network={ ssid=\u0026#34;secondSSID\u0026#34; psk=\u0026#34;secondPassword\u0026#34; priority=2 }     'use strict'; var containerId = JSON.parse(\"\\\"f916b0aac73fad5c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  WiFi 비밀번호 암호화하기 이전까지의 설정은 모두 비밀번호가 평문으로 저장된다는 문제점이 있다. 비밀번호를 노출하고 싶지 않다면, 미리 암호화된 비밀번호로 변환하여 저장하는 방법이 있다. (해당 방법은 wpa_supplicant를 직접 사용해야하며, 윈도우즈에서는 일반적으로 설치하기 힘든 것으로 보인다.)\n $ wpa_passphrase $SSID $PASSPHRASE\n wpa_supplicant를 설치하면 wpa_passphrase 명령어도 같이 설치되는데, 위와 같이 명령어의 인자로 WiFi AP의 이름과 비밀번호를 입력하면 사용해야 할 network={ } 내용을 생성해준다. 원문 비밀번호는 앞에 #으로 주석처리되어 있는데, 평문을 노출하지 않고 저장하는 것이 목적이므로 해당 줄만 삭제하면 된다. 아래는 WiFi AP 이름이 \u0026ldquo;testing\u0026rdquo;, 비밀번호가 \u0026ldquo;testingPassword\u0026quot;일 때 평문을 감추는 예시다.\nshell  $ wpa_passphrase testing testingPassword network={ ssid=\u0026#34;testing\u0026#34; #psk=\u0026#34;testingPassword\u0026#34;  psk=131e1e221f6e06e3911a2d11ff2fac9182665c004de85300f9cac208a6a80531 }     'use strict'; var containerId = JSON.parse(\"\\\"15241405ffbc0694\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  wpa_supplicant를 직접 사용할 수 없는 경우에는 Wireshark에서 제공하는 변환 페이지를 사용할 수도 있다.\n라즈베리파이 제로를 USB 이더넷 장치로 사용할 수 있게 설정하기 라즈베리파이 제로의 경우 WiFi가 지원되지 않는다. 하지만 해당 제품에서 USB 연결 설정을 변경하여 PC에서 USB 이더넷 장치로 인식하게 하는 방법이 있다. Addon board나 dongle expansion breakout module kit을 사용한다면 PC에서 라즈베리파이를 마치 이더넷 어댑터에 연결한 것 처럼 사용할 수 있다. 이 방법은 라즈베리파이 제로 W도 적용 가능하다.\nboot 파티션의 cmdline.txt 파일을 아래와 같이 수정한다.\n console=serial0,115200 console=tty1 root=PARTUUID=384c22b9-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait modules-load=dwc2,g_ether quiet splash plymouth.ignore-serial-consoles\n 해당 파일은 1줄짜리로 되어있는데, 내용 중 rootwait 부분과 quiet 사이에 modules_load=dwc2,g_ether를 추가해준다.\n또한 config.txt 파일에 dtoverlay=dwc2를 추가한다.\nconfig.txt  50 51 52 53 54 55 56 57 58  # Uncomment this to enable infrared communication. #dtoverlay=gpio-ir,gpio_pin=17 #dtoverlay=gpio-ir-tx,gpio_pin=18 # Additional overlays and parameters are documented /boot/overlays/README dtoverlay=dwc2  # Enable audio (loads snd_bcm2835) dtparam=audio=on       'use strict'; var containerId = JSON.parse(\"\\\"080d1a3b39812ac4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  라즈베리 파이 제로의 USB controller인 DesignWare Core2의 OTG 설정을 활성화해주고, USB OTG 모듈 중 g_ether 모듈을 사용하게 하는 것이다.\n윈도우즈에서는 이렇게 설정한 라즈베리파이를 연결하면 RNDIS 장치로 인식하게 되는데, 해당 장치 연결 시 컴퓨터가 느려지는 문제가 있다.\n라즈베리파이에게 DHCP로 IP를 할당해 줄 수 없을 때 라즈베리파이 제로를 USB로 연결하거나, 공유기 등에서 DHCP 기능을 사용하지 않는 경우 라즈베리파이는 IP를 할당받지 못하게 된다. 고정IP 설정은 boot 파티션 수정으로 할 수 없기 때문에 rootfs 파티션 내부를 수정하거나, 링크 로컬 주소를 사용해야 한다. 위에서 말한대로 rootfs는 ext4로 포멧되어있으니 윈도우즈만 사용하는 경우에는 고정IP 설정은 바로 할 수 없다고 생각하면 된다.\nrootfs에서 고정 IP 설정하기 rootfs의 /etc/dhcpcd.conf 파일 끝에 아래와 같이 수정한다.\n/etc/dhcpcd.conf  interface $IF_NAME static ip_address=$DEV_IP_ADDR/$PREFIX_BITS static routers=$GATEWAY_IP_ADDR static domain_name_servers=$DNS_IP_ADDR     'use strict'; var containerId = JSON.parse(\"\\\"c92d7f9e4252f424\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }   $IF_NAME은 사용할 네트워크 장치의 이름을 입력한다. (유선랜: eth0, WiFi: wlan0) $DEV_IP_ADDR는 라즈베리파이가 사용할 주소를, $PREFIX_BITS는 서브넷 마스크의 비트 수를 입력하면 된다. $GATEWAY_IP_ADDR는 공유기의 주소를 입력한다. $DNS_IP_ADDR는 DNS의 주소를 입력한다. (대부분 공유기가 DNS요청을 대신 처리해주기 때문에 공유기의 주소를 입력해도 된다.)  유선랜과 WiFi의 설정을 같이 입력해도 된다. 아래는 유선랜이 172.16.1.101, WiFi가 172.16.2.101로 잡히도록 설정한 예시이다. (공유기는 172.16.0.1로 가정)\n/etc/dhcpcd.conf  interface eth0 static ip_address=172.16.1.101/16 static routers=172.16.0.1 static domain_name_servers=172.16.0.1 interface wlan0 static ip_address=172.16.2.101/16 static routers=172.16.0.1 static domain_name_servers=172.16.0.1     'use strict'; var containerId = JSON.parse(\"\\\"10a8a78da1a4bbe5\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  SSH 원격 접속 설정하기 boot 파티션 안에 ssh 혹은 ssh.txt 파일만 생성하면 된다. 해당 파일의 내용은 관계없다. (빈 파일도 상관없다.)\n리눅스의 경우 touch 명령어를 사용하여 생성할 수 있다.\nshell  # touch $RPI_BOOT/ssh     'use strict'; var containerId = JSON.parse(\"\\\"a76b91a92bbd9f8d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  VNC 원격 접속 설정하기 VNC 서버 설정은 boot 파티션 수정으로 할 수 없다. 원칙적으로 VNC 원격 접속 설정은 라즈베리파이를 부팅하고 나서, raspi-config를 사용하여 Interfacing option에서 VNC 서버 사용 여부를 수정해야한다. 하지만 해당 명령어의 코드를 보면 systemctl을 이용하여 VNC 서비스 데몬을 enable시키는 것을 확인할 수 있다. systemctl enable의 역할은 미리 작성된 서비스 데몬의 파일을 자동 실행되도록 심볼릭 링크를 달아주는 것이므로 rootfs에서 미리 수정할 수 있다. 위에서 말한대로 rootfs는 ext4로 포멧되어있으니 윈도우즈만 사용하는 경우에는 VNC 원격 접속 설정은 바로 할 수 없다고 생각하면 된다.\nshell  # ln -s -f /usr/lib/systemd/system/vncserver-x11-serviced.service $RPI_ROOTFS/etc/systemd/system/multi-user.target.wants/vncserver-x11-serviced.service     'use strict'; var containerId = JSON.parse(\"\\\"558f2967b3996c79\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  chroot를 통해 미리 라즈베리파이 OS의 rootfs 위에서 작업하거나, 혹은 mount된 경로를 고려하여 심볼릭 링크를 생성해주면 된다.\n 원본 VNC 서비스 데몬 스크립트 위치: /usr/lib/systemd/system/vncserver-x11-serviced.service 연결할 자동 실행 위치: /etc/systemd/system/multi-user.target.wants/  원본 VNC 서비스 데몬 스크립트의 경로는 위에 설명한 경로로 고정되어야 한다. (라즈베리파이 안에서 해당 스크립트의 위치를 찾으면 되기 때문이다.)\n참고 링크 [1] boot 파티션 상세 설명(https://www.raspberrypi.org/documentation/configuration/boot_folder.md)\n[2] WiFi 설정을 위한 wpa_supplicant 설명(https://www.raspberrypi.org/documentation/configuration/wireless/headless.md)\n[3] 라즈베리파이 제로의 USB OTG 모드 설정(https://gist.github.com/gbaman/50b6cca61dd1c3f88f41)\n","description":"","id":14,"section":"posts","tags":["리눅스","네트워크","headless","wpa_supplicant"],"title":"SD카드에서 라즈베리파이 headless 설정하기","uri":"https://devlog.jsyoo5b.net/ko/posts/rpi/headless-config-in-sd/"},{"content":"최근 라즈베리파이 사이트에서는 손쉽게 라즈베리파이 OS설치를 위한 프로그램 Raspberry Pi Imager를 제공하지만, 본 문서에서는 해당 프로그램을 사용하지 않고 직접 설치하는 과정을 설명하려 한다. 당연히 최근의 라즈베리파이는 microSD카드를 사용하지만, 본 글에서는 편의상 SD카드라고 표현하도록 하겠다.\nOS 이미지를 다운받아서 준비해놓자.\n Raspberry Pi OS with desktop and recommended software: 기본적인 GUI 뿐만 아니라 모든 추천 SW가 설치되어 있는 상태 Raspberry Pi OS with desktop: 기본적인 GUI와 최소한의 SW만 설치되어 있는 상태 Raspberry Pi OS Lite: 최소한의 OS 구성요소만 설치됨 (GUI도 설치되어 있지 않음)  윈도우즈에서 SD카드에 OS 설치하기 먼저 SD카드를 포맷해야 한다.\n 윈도우즈의 포맷 기능 사용 SD 그룹의 포맷 도구 사용  SD카드 내에 1개의 파티션으로, FAT32로 포맷하면 된다.\nSD카드의 용량이 64GB이상일 때 (SDXC) SD카드의 용량이 32GB보다 큰 용량이라면 SD카드 포맷 시 추가적으로 수행해야 할 작업이 있다. (보통 용량이 32GB 다음에 64GB이므로 64GB라고 표현하였다.) 문제가 되는 SD카드는 표면에 SDXC 혹은 SDUC라고 써있는 카드들이다. SDUC는 표준상 2TB 이상일텐데, 라즈베리파이에 그만큼 비싼 카드를 사용할 사람은 없으리라 생각하여 SDXC만 고려하도록 하겠다.\n특히 2020년 기준으로는 SD카드의 단가가 많이 내려간 편이라 64GB의 가성비가 32GB의 가성비보다 좋은 경우가 있고, 일부 브랜드의 경우 용량이 더 큰데도 가격이 더 싼 경우가 존재하므로 다루는 것이 좋을 것이라 생각했다.\n문제의 원인은 SDXC에서 기본 파일시스템 형식을 exFAT로 선정했기 때문인데, 일반적인 방법으로는 윈도우즈에서 SDXC 카드를 FAT32로 포맷할 수 없기 때문이다. 라즈베리파이의 부팅 파티션은 FAT32만 가능하기 때문에 이를 수정해줘야 한다.\n FAT32 포맷 GUI 버전 FAT32 포맷 CLI 버전  라즈베리파이 OS 이미지 올리기  Win32DiskImager balenaEtcher Upshift imgFlasher  위 도구 중 하나를 사용하여 다운받았던 OS 이미지를 올리면 된다.\n리눅스에서 터미널로 SD카드에 OS 설치하기 SD카드 블록 장치 이름 확인  $ lsblk -p\n lsblk 명령을 통해 연결된 블록 장치(저장장치)를 확인한다. 사이즈, 마운트 경로 등을 통해 SD카드의 장비 이름을 알아내도록 하자. (만약 블록 장치가 많거나 유사해서 확인하기 힘들다면, SD카드를 연결하기 전의 명령어 결과와 연결한 후의 명령어 결과를 비교하여 유추하도록 하자)\nshell  $ lsblk -p NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 1 60.1G 0 disk ├─/dev/sda1 8:1 1 256M 0 part /mnt/boot └─/dev/sda2 8:2 1 59.8G 0 part /mnt/rootfs /dev/nvme0n1 259:0 0 476.9G 0 disk ├─/dev/nvme0n1p1 259:1 0 512M 0 part /efi ├─/dev/nvme0n1p2 259:2 0 444.4G 0 part / └─/dev/nvme0n1p3 259:3 0 32G 0 part [SWAP]     'use strict'; var containerId = JSON.parse(\"\\\"9041df86de65f8e0\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  나의 경우는 노트북의 OS가 nvme0에 설치되어있으므로 SD카드는 sda임을 알 수 있다.\n라즈베리파이 OS 이미지 쓰기  # dd bs=4M status=progress if=$RPI_OS_IMG of=$SD_DEVICE\n dd 명령으로 라즈베리파이 OS 이미지를 SD카드에 기록한다. 위 명령어의 $RPI_OS_IMG는 라즈베리파이 OS 이미지 파일을 압축해제한 경로를 넣으면 되고, $SD_DEVICE는 위에서 찾은 SD카드 블록 장치의 경로를 입력한다.\nshell  $ sudo dd bs=4M status=progress if=./2020-08-20-raspios-buster-armhf.img of=/dev/sda 3812622336 bytes (3.8 GB, 3.6 GiB) copied, 209 s, 18.2 MB/s 911+0 records in 911+0 records out 3821010944 bytes (3.8 GB, 3.6 GiB) copied, 537.638 s, 7.1 MB/s     'use strict'; var containerId = JSON.parse(\"\\\"f5697e332aa48e24\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  파티션 상태 확인, 확장하기  $ lsblk -p $SD_DEVICE\n 라즈베리파이 OS 이미지가 기록된 SD카드의 파티션 정보를 확인해보자. 이미 우리는 SD카드의 블록 장치 이름을 알고 있으니, 해당 장치 이름만 사용해서 해당 디스크의 상태를 확인하자.\nshell  $ lsblk -p /dev/sda NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 1 60.1G 0 disk ├─/dev/sda1 8:1 1 256M 0 part └─/dev/sda2 8:2 1 3.3G 0 part     'use strict'; var containerId = JSON.parse(\"\\\"20d6a4cdc0915070\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  결과를 자세히 보면 2개의 파티션으로 나눠져 있는데, sda1은 라즈베리파이 부팅 설정을 위한 파티션으로 FAT32로 포맷되어있다. sda2는 라즈베리파이의 rootfs이다. (부팅 후 \u0026lsquo;/\u0026lsquo;에 마운트되는 파일시스템)\n문제는 두 파티션 용량의 합이 전체 SD카드의 용량에 비해 터무니없이 작다는 것이다. 약 56GB가 낭비되고 있는데, 이 공간을 rootfs가 사용할 수 있게 파티션을 변경해보자. 여기서는 fdisk를 사용하도록 하겠다.\n(참고로 라즈베리파이를 부팅한 이후에도 자체적으로 파티션 확장하는 기능이 제공되긴 한다.)\n # fdisk $SD_DEVICE\n shell  $ sudo fdisk /dev/sda  Welcome to fdisk (util-linux 2.36). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): p Disk /dev/sda: 60.06 GiB, 64490569728 bytes, 125958144 sectors Disk model: Storage Device Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x58ce116e Device Boot Start End Sectors Size Id Type /dev/sda1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/sda2 532480 7462911 6930432 3.3G 83 Linux     'use strict'; var containerId = JSON.parse(\"\\\"2adead7a720694c3\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  SD카드의 장치 이름을 인자로 fdisk를 실행한다. 먼저 p 명령을 입력하여 현재 SD카드의 상세 정보를 출력한다. 여기에서 중요한 값은 Disk의 전체 sector 갯수(예시의 125958144), rootfs(2번째 파티션)의 시작 sector 값(예시의 532480)이다.\nfdisk  Command (m for help): d Partition number (1,2, default 2): 2  Partition 2 has been deleted.     'use strict'; var containerId = JSON.parse(\"\\\"14e89d84104b9e9f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  fdisk에서는 파티션을 바로 확장하는 명령어가 제공되지 않는다. 파티션을 삭제하고 용량을 키워서 다시 할당해야 한다. (해당 파티션의 내용이 삭제되는 것이 아니라, 파티션의 범위 정보만 변경되는 것이다.) d 명령을 입력하여 rootfs 파티션의 정보만 삭제한다.\nfdisk  Command (m for help): n Partition type p primary (1 primary, 0 extended, 3 free) e extended (container for logical partitions) Select (default p): p Partition number (2-4, default 2): 2 First sector (2048-125958143, default 2048): 532480 Last sector, +/-sectors or +/-size{K,M,G,T,P} (532480-125958143, default 125958143):  Created a new partition 2 of type \u0026#39;Linux\u0026#39; and of size 59.8 GiB. Partition #2 contains a ext4 signature. Do you want to remove the signature? [Y]es/[N]o: n     'use strict'; var containerId = JSON.parse(\"\\\"f4fcef88be066f37\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이제 기존 파티션의 위치에 맞춰서 용량을 늘려서 다시 생성하자. n 명령을 입력하여 새로 생성한다. primary type으로 선택, 파티션 번호는 기존의 2번으로 선택하자. (위의 extended 파티션 타입은 해당 파티션이 Logical partition일 때 이를 확장하기 위해 사용되는 파티션이므로 지금 파티션 크기를 확장시키는 것과 다른 것이다.)\n이제 파티션의 시작 sector, 마지막 sector를 설정해줘야 한다. 삭제하기 전의 sda2 파티션의 시작 sector 값을 입력하자. (위에서 확인했던 532480) 자세히 보면 비어있는 공간이 2048번 sector에도 존재하기 때문에 기본값으로 입력하면 의도하지 않은 파티션을 생성할 수도 있다. 마지막 sector의 기본값은 전체 sector의 끝이므로 그냥 사용해도 된다.\nfdisk  Command (m for help): p  Disk /dev/sda: 60.06 GiB, 64490569728 bytes, 125958144 sectors Disk model: Storage Device Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x58ce116e Device Boot Start End Sectors Size Id Type /dev/sda1 8192 532479 524288 256M c W95 FAT32 (LBA) /dev/sda2 532480 125958143 125425664 59.8G 83 Linux     'use strict'; var containerId = JSON.parse(\"\\\"e7ae5719d3aa6a4b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  이후 다시 p 명령을 입력하여 수정된 파티션 테이블을 확인하자. 이번엔 rootfs의 크기가 59.8GB로 늘어난 것을 확인할수 있다. 현재 상태는 이렇게 파티션 테이블을 재구성한다고 한 것이지 아직 반영된 것이 아니다.\nfdisk  Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks.     'use strict'; var containerId = JSON.parse(\"\\\"59fa23737f160293\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  w 명령을 입력하여 현재 설정된 파티션 테이블을 실제로 반영하도록 하자. 해당 파티션이 변경되면 fdisk는 자동으로 종료된다.\n파티션 마운트하기 이제 아래에서 라즈베리파이 부팅 설정을 수정하려면 boot 파티션을 마운트해야한다. mount 명령으로 각 파티션을 특정 디렉토리에 마운트하자.\n # mount $SD_DEVICE_PARTITION $MOUNT_PATH\n shell  $ lsblk -p /dev/sda NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 1 60.1G 0 disk ├─/dev/sda1 8:1 1 256M 0 part └─/dev/sda2 8:2 1 59.8G 0 part $ ls -d $PWD/* /mnt/boot /mnt/rootfs $ sudo mount -t vfat /dev/sda1 /mnt/boot $ sudo mount -t ext4 /dev/sda2 /mnt/rootfs     'use strict'; var containerId = JSON.parse(\"\\\"404b01cf09168a41\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  일반적으로는 mount 명령시 파일시스템 타입을 입력하지 않아도 알아서 해당 파일시스템 타입에 맞게 알아서 마운트해주지만, 만약 특별히 명시해야 할 필요가 있을 경우에는 FAT32는 vfat로, ext4는 ext4로 입력해주면 된다.\n # mount -t $FS_TYPE $SD_DEVICE_PARTITION $MOUNT_PATH\n 이후 마운트 된 path에 진입하면 파일들이 존재하는 것을 확인할 수 있을 것이다.\n참고 링크 [1] 라즈베리파이 OS 설치 방법(https://www.raspberrypi.org/documentation/installation/installing-images/)\n[2] SD카드 요구사항(https://www.raspberrypi.org/documentation/installation/sd-cards.md)\n[3] SDXC 카드 포맷하기(https://www.raspberrypi.org/documentation/installation/sdxc_formatting.md)\n[4] 윈도우즈에서 설치 방법(https://www.raspberrypi.org/documentation/installation/installing-images/windows.md)\n[5] 리눅스에서 설치 방법(https://www.raspberrypi.org/documentation/installation/installing-images/linux.md)\n","description":"","id":15,"section":"posts","tags":["리눅스","SD카드"],"title":"라즈베리파이 OS 설치하기","uri":"https://devlog.jsyoo5b.net/ko/posts/rpi/flash-rpi-os-into-sd/"},{"content":"본 리뷰는 리얼리눅스로부터 어떠한 지원도 받지 않았으며, 제 사비로 수강한 경험에 대한 리뷰입니다.\n리뷰 요약  추천 대상  시스템 분야에 대한 이해가 필요한 초급~중급 수준의 개발자   장점  시스템 \u0026amp; OS 분야를 다루는 강의 이론 이해 \u0026amp; 실습 적용이 적절히 어우러진 밸런스 있는 강의 지식 전달만이 아닌 해결법도 같이 가르치는 강의 수강 이후에도 질문 가능한 Q\u0026amp;A   단점  강의 주제가 한정적 \u0026amp; 매번 강의가 열리지 않는다는 점 저렴한 것은 아닌 수강비용 실습이 완벽하게 진행되지 않을 수도 있음    수강 계기 나는 원래 페스타, 온오프믹스 등 모임 주관 사이트같은 곳에서 강의 등을 찾아보고 괜찮은 강의나 행사에 참여하는 편이다. 내가 모르는 개발 트렌드나 새로운 지식의 범위를 넓히는 방법 중 하나다.\n원래 2019년에 iamroot 커널 스터디에 참여할 예정이었는데, 스터디 시작 일정과 전문연구요원 훈련소 일정이 겹치는 바람에 해당 스터디에는 참여할 수 없었다. 대신 2020년에 스터디 진행하기 전에 커널이나 C언어 심화 공부나 리눅스 커널 관련 책을 독학할 예정이었는데, 이때 페스타에서 리얼리눅스 강의를 발견했다.\n위 사진에서 볼 수 있듯, 나는 5번이나 리얼리눅스 강의를 수강하였으며, 당연히 강의가 만족스러웠기 때문에 여러 번에 걸쳐 다양한 강의를 수강했다. 본 리뷰에서는 Try 오픈소스 컨트리뷰션을 제외한 나머지 리눅스 커널에 관련된 강의들만 리뷰하도록 하겠다. (Try 오픈소스 컨트리뷰션은 따로 글을 할당하여 리뷰할 예정.)\n좋은 점 나는 현재 임베디드 FW 개발 업무를 하고 있는데, 내 업무와 관련된 강의는 정말 찾기 힘든 편이다. 시스템 \u0026amp; OS 관련 강의는 정말 찾기 힘들고, 가끔 있는 강의는 각 회사별 제품 사용에 관련된 강의로 개념적인 부분을 중점적으로 보는 강의는 거의 못 본 것 같다.\n실습 위주의 강의 내가 이전까지 시스템 \u0026amp; OS 공부 할 때 느꼈던 문제는 이런 것들이 있다.\n 내용 자체가 너무 넓고, 복잡하고, 서로 관계가 깊이 얽혀 있고 어렵다.\n(책을 읽어도 머리속에 하나도 들어오지 않는다.) 각 기능이 유기적으로 연결되어있어 적당한 시작점이 존재하지 않는다.\n(공부할 때 임시로 배제하면서 진행하는 수 밖에 없다.) 해당 상황을 겪어 보기 전 까지는 각 기법이 사용되는 이유를 이해하기 힘들다.\n(머리로는 이해한다고 하지만 딱히 문제의 심각성 등을 이해하지 못한다.) 직접 디버깅을 해 보면서 단계적으로 코드 흐름을 따라가기 어렵다.\n(코드가 너무 복잡하거나, 내가 찍을 수 있는 시간 간격보다 너무 짧거나)  각 문제들의 내용을 종합하자면 시스템 \u0026amp; OS 공부는 직접 상황을 맞닥드리지 않는 이상은 Bottom-up 방식으로 공부하게 되는 것이고, 어디부터 건드려야할지 감이 안 온다는 것이다.\n보통 여기서 열리는 강의는 특정 주제에 대한 특강 식으로 진행된다. 각 특강에서는 단계적으로 어떤 기능 하나에 대해서만 직접 확인하는 것을 목적으로 하기 때문에 공부 범위가 발산하는 것을 어느정도 방지할 수 있고, Trace라는 방식으로 실제 커널의 동작 과정을 확인해 볼 수 있기 때문에 위의 문제점을 많이 해결해 주는 편이다.\nuftrace, ftrace, sysfs 등을 통해 이론을 증명하는 실습 실습에는 uftrace, ftrace, sysfs를 사용한다.\n 개념적인 설명이 진행된다. 기능 확인을 위해 작성된 C 프로그램 코드에 대해 간략히 설명한다. 해당 프로그램을 uftrace로 실행하면서 각 함수 실행 흐름을 기록한다. Trace된 함수 흐름을 따라 리눅스 커널의 코드를 읽으면서 예상 흐름을 확인한다.  직접 작성한 코드로 재현하기 힘들거나, 실시간으로 일어나는 현상을 확인할 때는 ftrace나 sysfs 설정을 통해 확인한다.\nftrace는 실제 커널 디버깅 과정에서도 사용하는 것으로 알고 있다. 이런 도구 사용법을 같이 설명하므로 추후 개별적인 문제 해결에서도 도움이 될 수 있다.\n아쉬운 점 물론 아쉬운 점이 없는 것은 아니다. 솔직히 값어치는 하지만 쉽게 수강할 만큼 싼 비용은 아니다. (굳이 비교하자면 다른 현장 강의 가격대와 비교했을 때 비싼 건 아니다.)\n완벽하게 진행되지는 않는 실습 실습을 통해 이론을 실제로 증명하는 것이 이 강의의 핵심인데, 실습이 완벽하게 매번 똑같이 잘 이루어 지는 것은 아니다.\n첫번째 원인은 각 실습 환경이 완전히 동일하지 않기 때문이다. 강의에서는 최대한 동일한 환경을 제공하기 위해 VirtualBox 이미지로 제공하는데, 아무리 가상머신으로 표준화 해도 Host OS에서 문제를 일으키면 답이 안나온다. 최악의 경우 모든 실습이 잘 진행되지 않아 강의 내내 구경만 하는 경우가 생길 수도 있다.\n두번째 원인은 원하는 대로 Trace하는 것이 생각만큼 쉽지 않다는 것이다. Trace 중간에 스케쥴링이 일어나서 생기는 함수도 같이 추적되는 것은 물론이며, 일부 기능을 제대로 확인하려면 매번 cache를 비워줘야 하는 등 원하는 대로 쉽게 Trace되지 않는다.\n이 외에도 사소한 오류로 인해 강의가 잘 진행되지 않는 문제가 가끔 있는데, 이건 강의 횟수가 더 늘어남에 따라 점점 보완될 것이라 생각한다. 강의나 실습 조교 등을 해 본 사람이라면 공감할텐데, 수강생이 일으키는 예외의 범위는 강사의 예상 범위를 뛰어넘는다. 가르치는 입장에서는 당연하다고 생각되는 부분에서도 오류가 발생하기 때문이다.\n수강 대상 강의 정보에 수강대상, 강의 수준이 나와있다. 본인 실력에 대하여 너무 과대평가하거나 과소평가하지 말고 냉정하게 생각해보면 자신이 초급인지, 초급과 중급 사이인지, 중급인지 알 수 있을 것이다. 만약 본인이 해당 강의를 수강하기에 적합할지 잘 모르겠다면 상담을 요청해 보는 것도 괜찮다.\n나는 실제로 초급과 중급 사이라고 생각하고 리눅스 SW 기본반을 들었었는데, 배운게 없는 것은 아니지만 이미 아는 내용을 중복으로 듣는 것 같은 느낌이 있었다. (물론 기본반을 들으면서 OS 중급반을 같이 듣는 것도 원인 중 하나라고 생각한다.)\n위에서 설명한 uftrace, ftrace, sysfs를 통한 디버깅 등을 직접 수행할 수 있는 사람이라면 중급 이상은 된다고 생각하면 될 것 같다. 현재까진 고급 주제를 다루는 완전 심화반은 열리지 않은 것으로 알고있다.\n리뷰 하는 이유 초반에 말했듯 시스템 \u0026amp; OS 관련 강의는 정말 찾아보기 힘들다. 대학교 강의를 제외하고는 기업 내부 초청 강연, 제품 홍보나 관련 협회의 교육이 거의 전부다. (물론 다른 IT관련 학원에도 그나마 관련된 강좌가 있겠지만, 입학생들에게 일단 전화걸고 보는 악명높은 학원은 당연히 고려대상에서 제외했다.) 웹, 모바일 어플리케이션 개발, 요새 뜨는 트렌드 관련 교육은 생활코딩, 인프런 등 무료나 저렴한 가격으로도 수강할 수 있다. 이런 시스템 \u0026amp; OS 관련 분야 강의가 더 많아져서 전체적인 파이가 커 지길 바라는 마음에 리뷰를 작성했다.\n","description":"","id":16,"section":"posts","tags":["리얼리눅스"],"title":"[강의 리뷰] 리얼리눅스 (리눅스 커널 위주)","uri":"https://devlog.jsyoo5b.net/ko/posts/review/lecture-reallinux-kernels/"},{"content":"GUI 기반으로 작성한 프로그램은 직관적이지만, 해당 기능을 사용하기 위해 마우스를 사용해야 하며, 이로 인해 자동화하기 어렵다는 문제점이 있다. 물론 매크로 등을 활용할 수 있지만, 사람이 직접 수행하지 않을 뿐, 결국 프로그램으로 마우스 클릭 등을 반복하는 것이다.\nGUI 기반으로 개발된 파일을 변환해주는 프로그램들을 CI/CD 과정에 사용하려 한다고 가정해보자.\n GUI를 실행하기 위한 Desktop Environment가 없는 Container/Build server일 수 있다. GUI가 있는 환경이라도, 해당 환경에 맞춰 매크로를 기록해야 한다. 매크로를 사용해도 Build server에 RDP 등으로 접속 시, 해상도 변경, 좌표 변경 등 이슈가 발생한다. 여러 GUI 기반 프로그램들을 실행할 때, 마우스 위치가 점유 자원으로서 병렬성을 방해한다. 해당 프로그램의 실행 결과도 GUI로 나타나므로, 이를 쉽게 확인할 수 없다.  위의 상황은 극단적으로 가정한 것이지만, 최소 1개 이상 실제 문제가 될 것이라 예상한다.\n목표  Window Manager(Windows Explorer, Gnome 등)나 Shell(Bash, Command Prompt 등)에서 실행 시, GUI 환경으로 실행 Shell에서 실행할 때 특정 인자를 입력하면(혹은 Windows Manager의 Shortcut에 인자 추가) GUI를 띄우지 않고,\n해당 인자에 따라 기능을 수행한 뒤 종료. 필요에 따라 진행 과정에 대한 Log를 출력한다. 해당 프로그램의 성공/실패 여부에 따라 확인할 수 있게 Error code를 반환하며 종료한다.  위의 목표를 개발자 기준의 요구사항으로 해석하면 아래와 같다.\n 기존의 GUI 실행에 관련된 코드를 뒤엎지 않고 기능을 추가해야 한다. 해당 프로그램 실행의 인자를 읽고, 특정 조건 시 GUI를 실행시키는 함수를 호출하지 않아야 한다. stdio (특히 stdout, stderr)가 해당 프로그램을 실행시킨 shell과 연결되어 있어야 한다. GUI를 실행시키지 않은 상태에서 원하는 exit code로 프로그램을 종료시켜야 한다. MFC같이 안 좋은 GUI framework에서 개발해야 한다.  진단 이제 MFC 프로그램을 작성하고, Shell에서 실행시켜보자. MFC 응용 프로그램 프로젝트를 ConsoleGuiTool로 가정하겠다. (대화 상자 기반으로 작성하였으나, 다른 종류도 크게 문제되지 않는다.) 빌드하고 Command Prompt에서 실행시켜보면 아래 스크린샷과 같은 상황을 확인할 수 있을 것이다.\n분명 해당 프로그램이 종료되지 않았음에도 Shell과의 연결이 끊어졌다. 요구사항 3, 4의 상황에서 문제가 생길 수 있다. (자세한 설명은 Command Prompt 명령어 설명에서 다루도록 한다.)\nConsole 실행 모드 추가하기 일단 수정해야 할 파일은 현재 MFC 프로그램의 진입점 부분이다. CWinApp을 상속하고 있는 클래스의 소스 코드를 찾자. (특별히 이름을 변경하지 않았다면, 프로젝트 이름과 같은 *.h, *.cpp일 것이다.)\nConsoleGuiTool.h ConsoleGuiTool.cpp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // ConsoleGuiTool.h : main header file for the PROJECT_NAME application //  #pragma once  #ifndef __AFXWIN_H__ \t#error \u0026#34;include \u0026#39;stdafx.h\u0026#39; before including this file for PCH\u0026#34; #endif  #include \u0026#34;resource.h\u0026#34;\t// main symbols // CConsoleGuiToolApp: // See ConsoleGuiTool.cpp for the implementation of this class //  class CConsoleGuiToolApp : public CWinApp { public: CConsoleGuiToolApp(); // Overrides public: virtual BOOL InitInstance(); // Implementation  DECLARE_MESSAGE_MAP() }; extern CConsoleGuiToolApp theApp;     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  // ConsoleGuiTool.cpp : Defines the class behaviors for the application. //  #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;ConsoleGuiTool.h\u0026#34;#include \u0026#34;ConsoleGuiToolDlg.h\u0026#34; #ifdef _DEBUG #define new DEBUG_NEW #endif  // CConsoleGuiToolApp  BEGIN_MESSAGE_MAP(CConsoleGuiToolApp, CWinApp) ON_COMMAND(ID_HELP, \u0026amp;CWinApp::OnHelp) END_MESSAGE_MAP() // CConsoleGuiToolApp construction  CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, \t// Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object  CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization  BOOL CConsoleGuiToolApp::InitInstance() { // InitCommonControlsEx() is required on Windows XP if an application \t// manifest specifies use of ComCtl32.dll version 6 or later to enable \t// visual styles. Otherwise, any window creation will fail. \tINITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // Set this to include all the common control classes you want to use \t// in your application. \tInitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(\u0026amp;InitCtrls); CWinApp::InitInstance(); // Create the shell manager, in case the dialog contains \t// any shell tree view or shell list view controls. \tCShellManager *pShellManager = new CShellManager; // Activate \u0026#34;Windows Native\u0026#34; visual manager for enabling themes in MFC controls \tCMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // Standard initialization \t// If you are not using these features and wish to reduce the size \t// of your final executable, you should remove from the following \t// the specific initialization routines you do not need \t// Change the registry key under which our settings are stored \t// TODO: You should modify this string to be something appropriate \t// such as the name of your company or organization \tSetRegistryKey(_T(\u0026#34;Local AppWizard-Generated Applications\u0026#34;)); CConsoleGuiToolDlg dlg; m_pMainWnd = \u0026amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) { // TODO: Place code here to handle when the dialog is \t// dismissed with OK \t} else if (nResponse == IDCANCEL) { // TODO: Place code here to handle when the dialog is \t// dismissed with Cancel \t} else if (nResponse == -1) { TRACE(traceAppMsg, 0, \u0026#34;Warning: dialog creation failed, so application is terminating unexpectedly.\\n\u0026#34;); TRACE(traceAppMsg, 0, \u0026#34;Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\u0026#34;); } // Delete the shell manager created above. \tif (pShellManager != NULL) { delete pShellManager; } // Since the dialog has been closed, return FALSE so that we exit the \t// application, rather than start the application\u0026#39;s message pump. \treturn FALSE; }       'use strict'; var containerId = JSON.parse(\"\\\"c70dcd1c314c424d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  해당 class에 기존 GUI환경의 init을 담당할 InitGuiWindow()와 콘솔모드로 실행할 RunConsole() 함수를 추가한다. 이후 기존의 InitInstance()함수를 InitGuiWindow()로 교체하고, 새로운 InitInstance()를 아래와 같이 작성한다.\nConsoleGuiTool.h ConsoleGuiTool.cpp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // ConsoleGuiTool.h : main header file for the PROJECT_NAME application //  #pragma once  #ifndef __AFXWIN_H__ \t#error \u0026#34;include \u0026#39;stdafx.h\u0026#39; before including this file for PCH\u0026#34; #endif  #include \u0026#34;resource.h\u0026#34;\t// main symbols // CConsoleGuiToolApp: // See ConsoleGuiTool.cpp for the implementation of this class //  class CConsoleGuiToolApp : public CWinApp { public: CConsoleGuiToolApp(); // Overrides public: virtual BOOL InitInstance(); // Implementation  DECLARE_MESSAGE_MAP() BOOL InitGuiWindow(); BOOL RunConsole(); }; extern CConsoleGuiToolApp theApp;     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  // ConsoleGuiTool.cpp : Defines the class behaviors for the application. //  #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;ConsoleGuiTool.h\u0026#34;#include \u0026#34;ConsoleGuiToolDlg.h\u0026#34; #ifdef _DEBUG #define new DEBUG_NEW #endif  // CConsoleGuiToolApp  BEGIN_MESSAGE_MAP(CConsoleGuiToolApp, CWinApp) ON_COMMAND(ID_HELP, \u0026amp;CWinApp::OnHelp) END_MESSAGE_MAP() // CConsoleGuiToolApp construction  CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, \t// Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object  CConsoleGuiToolApp theApp; // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() { int nArgCnt = __argc; if (nArgCnt == 1) { return InitGuiWindow(); } else { return RunConsole(); } } BOOL CConsoleGuiToolApp::InitGuiWindow() { // InitCommonControlsEx() is required on Windows XP if an application \t// manifest specifies use of ComCtl32.dll version 6 or later to enable \t// visual styles. Otherwise, any window creation will fail. \tINITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // Set this to include all the common control classes you want to use \t// in your application. \tInitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(\u0026amp;InitCtrls); CWinApp::InitInstance(); // Create the shell manager, in case the dialog contains \t// any shell tree view or shell list view controls. \tCShellManager *pShellManager = new CShellManager; // Activate \u0026#34;Windows Native\u0026#34; visual manager for enabling themes in MFC controls \tCMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // Standard initialization \t// If you are not using these features and wish to reduce the size \t// of your final executable, you should remove from the following \t// the specific initialization routines you do not need \t// Change the registry key under which our settings are stored \t// TODO: You should modify this string to be something appropriate \t// such as the name of your company or organization \tSetRegistryKey(_T(\u0026#34;Local AppWizard-Generated Applications\u0026#34;)); CConsoleGuiToolDlg dlg; m_pMainWnd = \u0026amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) { // TODO: Place code here to handle when the dialog is \t// dismissed with OK \t} else if (nResponse == IDCANCEL) { // TODO: Place code here to handle when the dialog is \t// dismissed with Cancel \t} else if (nResponse == -1) { TRACE(traceAppMsg, 0, \u0026#34;Warning: dialog creation failed, so application is terminating unexpectedly.\\n\u0026#34;); TRACE(traceAppMsg, 0, \u0026#34;Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\u0026#34;); } // Delete the shell manager created above. \tif (pShellManager != NULL) { delete pShellManager; } // Since the dialog has been closed, return FALSE so that we exit the \t// application, rather than start the application\u0026#39;s message pump. \treturn FALSE; } BOOL CConsoleGuiToolApp::RunConsole() { printf(\u0026#34;Program is running in console mode\\n\u0026#34;); Sleep(5000); printf(\u0026#34;It seems program did some job, 5 second passed\\n\u0026#34;); return FALSE; }       'use strict'; var containerId = JSON.parse(\"\\\"5b5d6d688170868e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  일단 콘솔 모드 진입 조건은 실행파일 뒤에 인자가 하나라도 붙는 것으로 설정했다. 콘솔 모드 진입시, 콘솔 모드로 실행된다는 메시지를 출력하고, 5초 이후 무언가 완료되었다고 하고 종료되게 설정하였다. 빌드하고 Command Prompt에서 실행시켜보면 아래 스크린샷과 같은 상황을 확인할 수 있을 것이다.\n일단 실행 인자 옵션에 따라 기존 GUI 구동을 유지한 상태에서, 콘솔 모드 실행에 성공했다. 하지만 printf()를 통한 메시지 출력이 되지 않는 것을 확인할 수 있다.\n프로그램을 실행시킨 shell과 stdio 연결 해당 증상의 원인은 MFC 프로그램 실행 시, stdio가 기존 shell에서 떨어지기 때문이다. MFC 프로그램을 실행시킨 부모 프로세스(Command Prompt 혹은 PowerShell)의 stdio와 연결해야한다. 기존의 RunConsole() 함수를 아래와 같이 수정한다. (코드 상단에 #include \u0026lt;iostream\u0026gt;을 해야한다.)\nConsoleGuiTool.cpp  114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135  BOOL CConsoleGuiToolApp::RunConsole() { if (AttachConsole(ATTACH_PARENT_PROCESS)) { FILE *pfStdin; FILE *pfStdout; FILE *pfStderr; freopen_s(\u0026amp;pfStdin, \u0026#34;CONIN$\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen_s(\u0026amp;pfStdout, \u0026#34;CONOUT$\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen_s(\u0026amp;pfStderr, \u0026#34;CONOUT$\u0026#34;, \u0026#34;w\u0026#34;, stderr); std::cin.clear(); std::cout.clear(); std::cerr.clear(); }  printf(\u0026#34;Program is running in console mode\\n\u0026#34;); Sleep(5000); printf(\u0026#34;It seems program did some job, 5 second passed\\n\u0026#34;); return FALSE; }       'use strict'; var containerId = JSON.parse(\"\\\"3460afee449507a4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  L116~128의 내용은 부모 프로세스의 콘솔에 연결하고 stdin, stdout, stderr를 다시 여는 작업을 수행한다.\n임의의 Exit Code로 종료시키기 원칙적으로는 main() 함수의 return 값으로 exit code를 보내는 것이 정석이나, 우리가 현재 수정 가능한 코드 범위에서는 main() 함수를 수정할 수 없기 때문에 차선책인 exit() 함수를 사용하면 된다.\nstdin의 연결 상태를 확인할 겸, 아래와 같이 RunConsole() 함수를 수정한다.\nConsoleGuiTool.cpp  114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  BOOL CConsoleGuiToolApp::RunConsole() { int nExitCode;  if (AttachConsole(ATTACH_PARENT_PROCESS)) { FILE *pfStdin; FILE *pfStdout; FILE *pfStderr; freopen_s(\u0026amp;pfStdin, \u0026#34;CONIN$\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen_s(\u0026amp;pfStdout, \u0026#34;CONOUT$\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen_s(\u0026amp;pfStderr, \u0026#34;CONOUT$\u0026#34;, \u0026#34;w\u0026#34;, stderr); std::cin.clear(); std::cout.clear(); std::cerr.clear(); } printf(\u0026#34;Program is running in console mode\\n\u0026#34;); Sleep(5000); printf(\u0026#34;It seems program did some job, 5 second passed\\n\u0026#34;); printf(\u0026#34;Enter exit code to get: \u0026#34;); std::cin \u0026gt;\u0026gt; nExitCode; exit(nExitCode); \treturn FALSE; }       'use strict'; var containerId = JSON.parse(\"\\\"c06209fd397e601c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  위 목표를 모두 달성했다. 이제 실행인자를 잘 입력 받았는지 확인하고, 이를 비교하기만 하면 된다.\n실행 인자 사용을 위한 추가 설명 이전의 설명은 CWinApp::InitInstance() 메서드를 수정하여 GUI를 띄우지 않고 콘솔에서 입출력을 수행하는 부분을 설명했다. 실행 인자를 입력받는 방법은 __argc, __argv, __wargv 전역변수를 활용한다. 해당 변수는 stdlib.h에서 제공하며, Microsoft에서만 제공하는 확장 기능이다. (C,C++ 표준이 아님) (Multi-Byte Character Set으로 빌드한 경우 __argv를, Unicode Character Set으로 빌드한 경우 __wargv를 사용)\n이외에도 GetCommandLine(), CWinApp::ParseCommandLine() 등의 방법으로도 실행 인자를 얻을 수 있다. 이 중 ParseCommandLine()에서 사용하는 CCommandLineInfo는 Windows에서 제공하는 기능의 일부를 해석해준다.\nCommand Prompt 명령어 설명 사실 Windows에서 제공하는 Command Prompt, PowerShell에서 GUI를 사용하는 프로그램을 실행시키면 자동으로 해당 shell에서 detach하게 되어있다. 현재 수정한 방식은 GUI를 화면에 출력하기 전에 기능을 수행하고 종료시킨 것이므로, 똑같이 shell에서 detach하게 되어있다.\nCommand Prompt에서 콘솔 모드 사용을 위해서는 아래와 같은 옵션을 고려해야 한다.\nCommand Prompt  \u0026gt; start /wait \\\u0026lt;PROGRAM\\\u0026gt;     'use strict'; var containerId = JSON.parse(\"\\\"53ad0ca79156a2e8\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  \u0026lt;PROGRAM\u0026gt;을 실행시키고, 해당 \u0026lt;PROGRAM\u0026gt;이 종료될 때 까지 기다린다.\nCommand Prompt  \u0026gt; cmd /v:on /c \u0026#34;echo !time! ...     'use strict'; var containerId = JSON.parse(\"\\\"2503a2ebbd12fc5a\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Batch file을 실행할 때, 환경변수 등은 %VAR%를 통해 그 값으로 치환할 수 있다. 하지만 위 예시와 같이 프로그램의 실행 시간을 측정하기 위해 한 명령행 안에 %VAR%로 넣을 경우, 즉시 치환된다.\n(!time! 대신 %time%로 입력 시, 실제 소요시간과 관계없이 같은 시간이 나타난다.) 해당 변수에 접근하는 순간 치환되길 원한다면, 위와 같이 !VAR!로 표기해야 한다. 또한 위와 같은 delayed environment variable expansion을 사용하려면 현재 콘솔에 옵션을 설정하거나 cmd로 실행시킬 때, /v:on 옵션을 주고 실행시켜야 한다.\n해설 C/C++로 작성한 프로그램의 기본 진입점은 main()함수이다. main()함수의 매개변수로 int argc, char** argv를 사용하여 실행 인자를 프로그램 내에서 확인할 수 있다.\n하지만 MFC로 프로젝트를 생성할 경우, main()함수를 개발자가 직접 편집할 수 없다. 이전의 코드에서 봤던 것 처럼 개발자가 수정 가능한 프로그램의 최초 진입 지점은 CWinApp::InitInstance() 메서드이다.\nmain()함수 역할을 수행하는 WinAPI에서 제공하는 진입점은 _tWinMain() 함수이다. MFC에서 작성된 _tWinMain()함수의 정의는 VC\\atlmfc\\src\\mfc\\appmodul.cpp에서 확인할 수 있다.\nVC\\atlmfc\\src\\mfc\\appmodul.cpp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // This is a part of the Microsoft Foundation Classes C++ library. // Copyright (C) Microsoft Corporation // All rights reserved. // // This source code is only intended as a supplement to the // Microsoft Foundation Classes Reference and related // electronic documentation provided with the library. // See these sources for detailed information regarding the // Microsoft Foundation Classes product.  #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;sal.h\u0026#34; ///////////////////////////////////////////////////////////////////////////// // export WinMain to force linkage to this module extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow); extern \u0026#34;C\u0026#34; int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow) #pragma warning(suppress: 4985) { // call shared/exported WinMain \treturn AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow); }  ///////////////////////////////////////////////////////////////////////////// // initialize app state such that it points to this module\u0026#39;s core state  BOOL AFXAPI AfxInitialize(BOOL bDLL, DWORD dwVersion) { AFX_MODULE_STATE* pModuleState = AfxGetModuleState(); pModuleState-\u0026gt;m_bDLL = (BYTE)bDLL; ASSERT(dwVersion \u0026lt;= _MFC_VER); UNUSED(dwVersion); // not used in release build #ifdef _AFXDLL \tpModuleState-\u0026gt;m_dwVersion = dwVersion; #endif :       'use strict'; var containerId = JSON.parse(\"\\\"fb1d7f5ea79911f0\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  _tWinMain()에서 호출하는 AfxWinMain()의 정의는 VC\\atlmfc\\src\\mfc\\winmain.cpp에서 확인할 수 있다.\nVC\\atlmfc\\src\\mfc\\winmain.cpp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  // This is a part of the Microsoft Foundation Classes C++ library. // Copyright (C) Microsoft Corporation // All rights reserved. // // This source code is only intended as a supplement to the // Microsoft Foundation Classes Reference and related // electronic documentation provided with the library. // See these sources for detailed information regarding the // Microsoft Foundation Classes product.  #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;sal.h\u0026#34; ///////////////////////////////////////////////////////////////////////////// // Standard WinMain implementation // Can be replaced as long as \u0026#39;AfxWinInit\u0026#39; is called first  int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, int nCmdShow) { ASSERT(hPrevInstance == NULL); int nReturnCode = -1; CWinThread* pThread = AfxGetThread(); CWinApp* pApp = AfxGetApp();  // AFX internal initialization \tif (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow)) goto InitFailure; // App global initializations (rare) \tif (pApp != NULL \u0026amp;\u0026amp; !pApp-\u0026gt;InitApplication()) goto InitFailure; // Perform specific initializations \tif (!pThread-\u0026gt;InitInstance()) \t{ if (pThread-\u0026gt;m_pMainWnd != NULL) { TRACE(traceAppMsg, 0, \u0026#34;Warning: Destroying non-NULL m_pMainWnd\\n\u0026#34;); pThread-\u0026gt;m_pMainWnd-\u0026gt;DestroyWindow(); } nReturnCode = pThread-\u0026gt;ExitInstance(); goto InitFailure; } nReturnCode = pThread-\u0026gt;Run(); InitFailure: #ifdef _DEBUG \t// Check for missing AfxLockTempMap calls \tif (AfxGetModuleThreadState()-\u0026gt;m_nTempMapLock != 0) { TRACE(traceAppMsg, 0, \u0026#34;Warning: Temp map lock count non-zero (%ld).\\n\u0026#34;, AfxGetModuleThreadState()-\u0026gt;m_nTempMapLock); } AfxLockTempMaps(); AfxUnlockTempMaps(-1); #endif  AfxWinTerm(); return nReturnCode; } /////////////////////////////////////////////////////////////////////////////       'use strict'; var containerId = JSON.parse(\"\\\"d67b2d0b98505a57\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  AfxGetApp()를 통해 개발자가 정의한 Application 변수의 주소를 얻고, 해당 변수에서 InitInstance() 메서드를 호출한다. 해당 함수는 개발자가 재정의할 수 있으며, 우리는 이 InitInstance()함수를 수정하여 MFC dialog를 띄우지 않고 콘솔에서 처리할 수 있도록 변형한 것이다.\nConsoleGuiTool.cpp  20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  : // CConsoleGuiToolApp construction  CConsoleGuiToolApp::CConsoleGuiToolApp() { // TODO: add construction code here, \t// Place all significant initialization in InitInstance } // The one and only CConsoleGuiToolApp object  CConsoleGuiToolApp theApp;  // CConsoleGuiToolApp initialization BOOL CConsoleGuiToolApp::InitInstance() :       'use strict'; var containerId = JSON.parse(\"\\\"1d75245703cd0acc\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  다른 GUI framework에서의 진입점 (main 함수) 아래는 각 C/C++로 작성된 GUI framework의 진입점이다. 대부분의 GUI framework는 main() 함수를 편집할 수 있다.\nWxWidget은 MFC와 같이 main() 함수를 편집할 수 없으므로, wxApp이 제공하는 메서드를 사용해야 한다.\nQT GTK\u0026#43; FLTK  #include \u0026lt;QApplication\u0026gt;#include \u0026lt;QCommandLineParser\u0026gt;#include \u0026lt;QCommandLineOption\u0026gt; #include \u0026#34;mainwindow.h\u0026#34; int main(int argc, char *argv[]) { Q_INIT_RESOURCE(application); QApplication app(argc, argv); QCoreApplication::setOrganizationName(\u0026#34;QtProject\u0026#34;); QCoreApplication::setApplicationName(\u0026#34;Application Example\u0026#34;); QCoreApplication::setApplicationVersion(QT_VERSION_STR); QCommandLineParser parser; parser.setApplicationDescription(QCoreApplication::applicationName()); parser.addHelpOption(); parser.addVersionOption(); parser.addPositionalArgument(\u0026#34;file\u0026#34;, \u0026#34;The file to open.\u0026#34;); parser.process(app); MainWindow mainWin; if (!parser.positionalArguments().isEmpty()) mainWin.loadFile(parser.positionalArguments().first()); mainWin.show(); return app.exec(); }   #include \u0026lt;gtk/gtk.h\u0026gt; #include \u0026#34;gtk_app.h\u0026#34; int main (int argc, char **argv) { GtkApplication *app; int status; app = gtk_application_new (\u0026#34;org.gtk.example\u0026#34;, G_APPLICATION_FLAGS_NONE); g_signal_connect (app, \u0026#34;activate\u0026#34;, G_CALLBACK (activate), NULL); status = g_application_run (G_APPLICATION (app), argc, argv); g_object_unref (app); return status; }   #include \u0026lt;FL/Fl.H\u0026gt;#include \u0026lt;FL/Fl_Window.H\u0026gt;#include \u0026lt;FL/Fl_Button.H\u0026gt; int main(int argc, char *argv[]) { Fl_Window* w = new Fl_Window(330, 190); new Fl_Button(110, 130, 100, 35, \u0026#34;Okay\u0026#34;); w-\u0026gt;end(); w-\u0026gt;show(argc, argv); return Fl::run(); }     'use strict'; var containerId = JSON.parse(\"\\\"47b9d8342ba476c1\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  참고 링크 [1] MFC 기본코드 분석(https://petra.tistory.com/1296)\n","description":"","id":17,"section":"posts","tags":["MFC","GUI"],"title":"MFC 프로그램의 콘솔 실행 모드 추가","uri":"https://devlog.jsyoo5b.net/ko/posts/mfc/console-mode/"},{"content":"Project Whitecat은 우리 집 안에 있는 모든 네트워크 관련 장비를 벽 안에 밀어넣는 프로젝트이다.\n벽 안에 뭘 밀어넣는다는 부분에서 에드거 앨런 포의 소설 검은 고양이에서 영감을 받아 현재 벽 색상인 흰색으로 바꿔서 이름지었다.\n이전의 네트워크는 뭐가 불만족스러웠길래? 처음 집 안의 네트워크를 뜯어고치게 된 원인은 아래와 같다.\n IPTV를 사용하고 있다. (셋톱박스가 필요하다.) 셋톱박스는 유선연결만 지원한다. 공유기는 거실에 있다. (셋톱박스가 거실 TV에 붙어 있기 때문에) 내 방에서 유선으로 컴퓨터를 쓰고 싶다. 내가 인터넷 쓸 때 셋톱박스에 영향을 주지 않았으면 좋겠다.  내가 게임 다운받는다고 3Mbps 이상의 대역폭을 사용하면 IPTV 화면이 멈추고 소리만 나오는 등의 문제가 있었다. 결국 나는 다운로드 대역폭을 낮추거나, 밤에 잘 때 대역폭을 높여 써야 하는 상황이었다. 밤에 잘 때도 WiFi로 연결되어 있기 때문에 최대 대역폭도 낮은 편이었다.\n이러느니 그냥 내 방에 공유기를 하나 따로 설치해서 쓰는게 낫겠다 생각해서 공유기를 사왔으나, 해당 공유기를 쓸 수 없었다. 이유는 간단하다. 각 벽에 있는 랜선 벽단자 중 거실에 있는 랜선 벽단자만 살아있기 때문이었다.\n통신 단자함 통신 단자함은 인터넷 배선(혹은 TV 케이블도)을 선택할 수 있는 박스를 말한다. 통신 단자함 박스는 보통 집 안(전력 차단기 근처) 혹은 바깥(집 근처 복도 쪽) 벽에 매설되어있다. (건물 상황에 따라서 IDF 단자함이라 한다.)\n출처: https://extrememanual.net/10935\n2010년대 이후에 지어진 건물은 아마도 위와 같은 형태의 통신 단자함으로 되어 있을 것이다. (초고속정보통신건물 인증제도 덕분에 일반화 된 것으로 알고 있다.) 단자함 내부에 RJ45포트로 연결할 수 있고, 내부에 스위칭 허브를 넣을 공간과 콘센트도 있다.\n한편 그 이전에 지어진 건물의 경우 위와 같은 형태의 통신 단자함을 볼 수 있을 것이다.(우리 집이 이 형태를 사용한다.) 이 단자함보다 더 이전 버전도 존재하지만, 2000년대에 인터넷 고속화 과정에서 대부분 위와 같이 변경되었을 것이다. 여기에 연결된 부분은 110 블럭이라 한다.\n(참고로 신형 통신 단자함 뒷편의 케이블 연결, 랜선 벽단자의 케이블 연결 부분은 키스톤 잭이라 한다.)\n위 사진은 다른 상태지만, 보통 외부 인터넷선(국선)과 집 안에 있는 방 중 1곳(우리 집의 경우, 거실)과 연결하게 되어있다. 즉, 다른 방의 랜선 벽단자는 연결이 끊겨 있는 상태이기 때문에 아무리 공유기를 연결하고 설정을 변경해도 인터넷이 안 되는 것이다. 현재 통신 단자함은 구형이라서 안에 스위칭 허브를 넣을 공간도 없고, 전원도 공급받을 수 없기 때문에 랜선 벽단자는 여전히 1개만 사용 가능했다.\n사실 신형 통신 단자함도 똑같이 110 블럭을 사용할 수도 있다. 통신 단자함 안에 스위칭 허브를 넣을 만큼의 공간적 여유, 콘센트 여부를 가지고 신형과 구형을 구분하면 될 것이다.\n그 외 다른 문제들 통신 단자함에서 외부 인터넷선과 거실 랜선 벽단자 사이 연결은 4가닥으로 되어있었다. 이론 상 4선만으로도 이더넷 사용은 가능하지만, 기가급 인터넷 사용을 위해선 8가닥으로 늘려줘야 했다.\n게다가 확인해보니 거실에서 연결된 공유기가 오래된 공유기라서 대역폭 관리를 잘 못하는 것이 확인되어, 이를 새로 산 신형 공유기로 교체하였다.\n편법으로 랜선 끌어오기 통신 단자함을 통해 각 랜선 벽단자가 연결되는 방식을 알아냈으므로, 간접적으로 랜선을 끌어 올 수 있는 방법이 생겼다.\n이더넷 선은 방향을 따지지 않으므로 (엄밀히 말하면 네트워크 장비와 단말 장비 간 방향을 따지긴 하나, 이를 자동으로 감지해서 변경하는 기능이 지원된다.) 가까운 방(Room2)의 랜선 벽단자를 출력 용도가 아닌 입력 용도로 사용한다. 통신 단자함에서는 Room2와 Room1을 연결해버리면 긴 랜선을 통해 최종적으로 내 방(Room1) 랜선 벽단자를 사용할 수 있다. (공유기에서 직접 연결된 회선으로) 그림에 보이는 집 구조처럼 내 방으로 직접 끌고 올 경우 바닥에 선이 걸리는데, 가까운 방으로 돌리면 최대한 벽에 붙여, 발에 걸리지 않게 할 수 있다.\n여전히 뭔가 불만족스러운데? 이전까지의 설명은 2019년 7월쯤 완료된 상태를 설명한 것이다. 하지만 여전히 불만족스러운 점이 있었다.\n 랜선에 연결하고 싶은 장비들은 다 내 방에 있는데 공유기는 여전히 거실에 있다. (장비가 늘어났음) 긴 랜선이 거실의 공유기에서 출발해서 다른 방으로 타고 들어간다. (최대한 안 보이게 하긴 했지만 여전히 거슬림) 공유기 설정 바꾸거나 재시작할때 셋톱박스가 영향을 받는다. (인터넷 망에서 IPTV를 분리해버리고 싶다)  이 문제를 해결하는 방법은 다음과 같았다.\n 스위칭 허브를 구매하여 외부 인터넷선에서 IPTV용, 공유기용으로 분리해버린다. 기존 거실의 랜선 벽단자는 셋톱박스만 연결한다. 공유기를 내 방에 설치한다. (셋톱박스의 연결만 해결되면 공유기가 굳이 거실에 있을 필요 없음)  문제는 스위칭 허브를 설치하기에 우리집 통신 단자함은 구형 통신단자함이므로 스위칭 허브를 밖에서 연결하고도 거실 랜선 벽단자로 회선 연결을 해야 했다. 또한 이전에 회선을 추가한 것과 달리 국선을 변경하는 작업, 랜선 벽단자를 건드리기 때문에 인터넷이 안 될 수도 있다. 나는 작업을 하고 있을테니 인터넷 접속 여부가 상관없지만, 부모님은 TV도 안되고 인터넷도 안되면 집에서 할 수 있는게 많이 줄어들기 때문에, 부모님이 집을 오랫동안 비울 때를 기다렸다.\n관로포설 관로포설은 벽 안에 선을 넣는 걸 말한다. 그러니깐 지금은 랜선 벽단자에 랜선이 1개만 연결되어 있는데, 선을 하나 더 추가하는 것이다. 2개 이상의 랜선을 꽂을 수 있는 벽단자를 찾던 중 아래와 같은 물건을 구입했다. 심지어 원하는 대로 랜선 단자와 TV케이블 단자 순서 등을 변경할 수 있는 물건이었다.\n그래서 내 방의 TV케이블 벽단자를 이걸로 교체하고, 내 방에서 거실 방향으로 관로포설하면 되겠다고 생각했다.\n하지만 TV케이블 벽단자를 뜯어본 뒤, 이 방법은 불가능한 것을 알게 되었다.\n 랜선 벽단자와 TV케이블 벽단자 내부가 이어져 있을줄 알았는데 각각 개별적인 박스로 구성되어있음. (뚫을 수 없는 두꺼운 플라스틱 재질) TV케이블 하나만 들어오는 줄 알았는데 릴레이 식으로 연결되어 있음. (TV케이블이 있을 공간이 필요함) 게다가 케이블이 통과하는 관로가 너무 좁아서 새로 추가가 불가능함.  어차피 IPTV보는데 TV케이블 뽑아버리면 되는거 아닐까 하는 생각도 잠시 들었었는데, 릴레이 식으로 연결되어 있는걸 봐선 다른 집으로도 연결되어 있을 가능성도 있을 것 같았고, 맘대로 뽑았다가 나중에 다시 복원시켜야 할 때는 답이 안 나오겠다 싶어서 결국 TV케이블쪽은 포기하고 기존 랜선 벽단자 안에 추가로 관로포설을 하기로 했다.\n확인해보니 내 방으로 들어오는 랜선 벽단자 내부에서 3개 선이 들어와서, 2개는 아까 room2, 거실쪽으로 배선되고, 짧은 하나만 내 방 벽단자로 연결되는 것이었다. 내 맘대로 이쪽 벽에서 저쪽 벽으로 보낼 수 있는 게 아니라, 이미 연결된 회선에 따라 가능/불가능 여부가 결정되는 것이었다. 내부적으로 튜브같은게 존재하는데, 이 튜브는 벽단자 - 벽단자 간에 연결되어 있고, 이 튜브 안에 랜선이 포설되어 있는 것이다.\n결국 내 방이 통신 단자함과 가장 가깝기 때문에, 그나마 랜선 추가가 가장 쉬운 상태였다. 기존 내 방과 통신단자함 사이에 연결된 랜선을 제거하고, 새로운 랜선 2개를 밀어넣었다. (접어서 2겹으로 밀어넣고, 반대편에서 가운데를 끊어버림으로서 2개를 넣음)\n관로포설, 통신 단자함 연결 시 주의사항 통신 단자함 내 각 단자 간 연결, 관로포설 시 해당 케이블이 단선인지, 연선인지 잘 확인해야 한다.\n출처: https://www.mirazon.com/network-cables-and-connectors-twisted-pair-cat5/\n대부분의 단선 케이블은 문제가 되지 않는다. 하지만 연선인 경우 문제가 되는데, 연선의 내부 두께가 얇기 때문에 110블럭/키스톤잭의 칼날이 연선의 전도체와 닿지 않을 수도 있다. 케이블이 칼날과 연결되지 않는데 단자 간 연결이나, 관로포설을 해 봤자 해당 케이블에서 전기가 흐르지 않기 때문에 단선된 상태와 똑같은 증상이 나타난다.\n각 선이 단선인지 연선인지 자르지 않고 구분하는 편법은 다음과 같다.\n 작업용 케이블(200m 이상 단위의 박스로 파는 케이블, 보통 길이만큼 잘라서 사용)은 단선일 가능성이 높다. 편의점, 할인마트 등에서 구매할 수 있는 케이블(대부분 5m~30m)은 연선일 가능성이 높다. 연선의 경우 내부 두께가 얇은 편이므로, 케이블 피복과 내부 선 사이에 공간이 많이 남는 편이다. 해당 케이블을 접거나 굽히는 등 모양을 만든 뒤, 해당 모양이 어느 정도 잘 유지되면 단선일 가능성이 높다.  통신 단자함 재배치 이후 통신 단자함에 새로 추가한 랜선을 꽂을 110 블럭을 배치했다.\n뽑아서 옮기는 와중에 110 블럭이 부러지는 일이 일어나긴 했다. 원래는 110블럭을 뽑거나 끼우는데 사용하는 전용 도구가 있는데, 그냥 펜치로 뽑고 끼우다가 틀어져서 부러졌다.\n공유기 배치 공유기는 거실쪽에서도 신호가 잘 닿도록 문 방향으로 배치했다.\n여기서 만족했으면 글 이름이 관로포설이었겠지? 그렇다. 여기서 또 뭔가 만족스럽지 않아서 Project Whitecat이 되어가는 것이다. 그 문제는 다음 글에서\u0026hellip;\n","description":"","id":18,"section":"posts","tags":["관로포설","DIY","네트워크"],"title":"Project Whitecat: 0. 집안 네트워크 뒤집어 놓기","uri":"https://devlog.jsyoo5b.net/ko/posts/project-whitecat/chap0-changing-home-network/"},{"content":"정규표현식은 특정한 규칙을 지닌 문자열의 집합에 대한 표현식이다. 정규표현식이 사용될 예시는 아래와 같다.\n E-mail 주소(abcd@efg.com) 형태의 문자열인지 확인하고 mailto: 처리를 하려 할 때 어떤 프로그램의 로그 파일 중 특정 이벤트나 메시지만을 필터링 하려는 경우 IDE의 도움 없이 코드에서 특정 변수만 이름을 변경하고자 하는 경우  위와 같이 주어진 문자열 속에서(대부분 긴) 내가 원하는 문자열을 패턴화 시켜 추출해내고, 교체할 수 있게 해 준다. 거의 대부분의 프로그래밍 언어는 정규표현식 기능을 제공한다.\n기초 정규표현식 본 포스트에서는 문자열 추출을 위해 필요한 가장 기초적인 기호 및 사용법에 대하여 설명한다. 좀 더 효율적으로 표현하기 위해 중요한 기술이나, 치환 등에 필요한 내용은 다음 포스트에서 다루도록 하겠다. 아래에서 설명하는 정규표현식의 표현법은 프로그래밍 언어, 환경마다 다를 수 있다. $var 는 변수를 표현하기 위함이다. 해당 문자열에 $가 포함된다는 뜻이 아니다.\n1. 리터럴 문자 기초적인 문자(일부 특수 기호)를 표현한다.\n   기호 의미 예시 / 추가 설명     $text $text 문자열 그대로 추출 /LINE/ -\u0026gt; INLINE 일치   \\t | \\v 수평 | 수직 방향 탭 을 표현함 예시 / 추가 설명 불필요   \\r 캐리지 리턴을 표현함 예시 / 추가 설명 불필요   \\n 줄넘김 (개행 문자) 을 표현함 예시 / 추가 설명 불필요   \\f 페이지 넘김을 표현함 예시 / 추가 설명 불필요   \\\\ 역슬래시 문자를 표현 예시 / 추가 설명 불필요   \\x$HX 16진수 $HX 의 값을 추출 /\\x61/ -\u0026gt; abcab 일치 (0x61 == \u0026lsquo;a\u0026rsquo;)   \\0$OCT 8진수 $OCT 의 값을 추출 예시 / 추가 설명 불필요    위의 표에 나와있는 항목 외에도 정규표현식에서 사용하는 특수문자들을 리터럴 값으로 표현하기 위해 \\로 escape를 사용한다. 하지만 정규표현식을 사용하는 환경에 따라 escape를 한 것을 리터럴로 취급하는지 혹은 반대인지 차이가 있을 수 있다.\n2. 문자 클래스 1개의 문자를 추출하기 위해, 비슷한 부류의 문자들을 종류에 따라 묶어 표현한다.\n   기호 의미 예시 / 추가 설명     [$keys] $keys에 속하는 모든 문자 /[01234]/ -\u0026gt; \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;4\u0026rsquo; 일치   [$a-$b] $a에서 $b 범위에 속하는 모든 문자 /[0-4]/ == /[01234]/   [^$a] $a를 제외한 모든 문자 /[^0-9]/ -\u0026gt; 숫자를 제외한 모든 글자 일치   . 개행 문자를 제외한 모든 문자 예시 / 추가 설명 불필요   \\w 알파벳(대+소), 숫자, _에 해당하는 모든 문자 /\\w/ == /[A-Za-z0-9_]/   \\W 알파벳(대+소), 숫자, _를 제외한 모든 문자 /\\W/ == /[^A-Za-z0-9_]/   \\d 모든 숫자(0~9) 문자 /\\d/ == /[0-9]/   \\D 모든 숫자를 제외한 모든 문자 /\\D/ == /[^0-9]/   \\s 모든 빈칸(스페이스, 탭, 줄바꿈) 문자 /\\s/ == /[ \\t\\r\\n\\v\\f]/   \\S 모든 빈칸(스페이스, 탭, 줄바꿈)을 제외한 문자 /\\S/ == /[^ \\t\\r\\n\\v\\f]/    3. 수량자 수량자를 통해 패턴의 표현 횟수를 줄이거나, 유연하게 처리하게 할 수 있다.\n   기호 의미 예시 / 추가 설명     {$t} 앞의 표현식을 $t번 반복하는 부분을 추출 /[\\da-fA-F]{2}/ -\u0026gt; 2자리 16진수 일치   {$t,} 앞의 표현식을 $t번 이상 반복하는 부분을 추출 /\\d{5}/ -\u0026gt; 5자리 이상의 숫자 일치   {$s,$e} 앞의 표현식을 $s번 이상, $e번 이하 반복하는 부분을 추출 /\\d{3,5}/ -\u0026gt; 3~5자리의 숫자 일치   ? 앞의 표현식이 0번 혹은 1번 나타나는 부분을 추출 /https?/ -\u0026gt; http, https 일치   * 앞의 표현식이 0번 이상 나타나는 부분을 추출 /\\w*/ == \\w{0,}   + 앞의 표현식이 1번 이상 나타나는 부분을 추출 /\\d+/ == \\d{1,}    수량자에는 추가적으로 게으른 문자(lazy evaluation)라는 개념이 있는데 이는 나중에 따로 다루도록 하겠다.\n4. 그룹 조건 수량자를 표현식 단위로 적용하거나, 표현식 여러 개를 묶어 OR 연산을 할 수도 있다.\n   기호 의미 예시 / 추가 설명     ($exp) 표현식 $exp를 묶어 수량자 연산 등을 가능케 함 /(0x[\\da-fA-F]{2} ?)+/ -\u0026gt; 16진법 배열 일치   ($e1|$e2) 표현식 $e1 이나 $e2 중 해당하는 부분을 추출 (OR) /(Str|string)/ -\u0026gt; Str, string 일치    5. 위치 지정 문자열 추출시 위치에 대한 조건을 둘 수 있다. 여기에서 $는 변수를 뜻하는 것이 아니라 글자 \u0026lsquo;$\u0026lsquo;를 뜻하는 것이다. 여기에서 설명하는 문자열은 일반적으로 \\r 혹은 \\n으로 구분되는 문장을 뜻한다. 단어의 기준은 일반적으로 \\s (스페이스, 탭, 줄바꿈) 사이의 글자들을 말한다.\n   기호 의미 예시 / 추가 설명     ^ 문자열의 시작 부분 /^An/ -\u0026gt; 문자열의 시작의 An Ancestor 에서 맨 앞의 An만 일치   $ 문자열의 끝 부분 /er$/ -\u0026gt; 문자열의 끝의 better stronger 에서 맨 끝의 er만 일치   \\b 단어의 경계 /\\bor/ -\u0026gt; organ, inventor 는 일치하지만 bored는 일치하지 않음   \\B 단어의 중간 /\\Bor/ -\u0026gt; bored 는 일치하지만 organ, inventor는 일치하지 않음    정규표현식 관련 사이트  언어/환경별 정규표현식 표현 비교 표  영문 위키 \u0026ldquo;Regular Expression\u0026rdquo;   정규표현식 공부할 수 있는 사이트  regexone : 설명을 보고 아래 예제를 맞추는 방식으로 진행하는 형태 regexcrossword : 가로세로 퍼즐처럼 문제풀이 (확인용)   언어/환경별 정규표현식 실험 사이트  https://regexr.com/ (Javascript, PCRE) http://regexstorm.net/tester (.NET) http://www.regexplanet.com/advanced/java/index.html (Java)   정규표현식 자동 생성  txt2re : 문자열을 입력하면 각 부분마다 표현하기 위한 정규표현식을 자동 생성해줌    ","description":"","id":19,"section":"posts","tags":["정규표현식"],"title":"정규표현식 기초","uri":"https://devlog.jsyoo5b.net/ko/posts/regex/basic/"}]